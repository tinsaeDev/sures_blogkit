import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values
} from "./chunk-VI6FVFLU.js";
import "./chunk-CEQRFMJQ.js";

// node_modules/@firebase/util/dist/index.esm.js
var CONSTANTS = {
  /**
   * @define {boolean} Whether this is the client Node.js SDK.
   */
  NODE_CLIENT: false,
  /**
   * @define {boolean} Whether this is the Admin Node.js SDK.
   */
  NODE_ADMIN: false,
  /**
   * Firebase SDK Version
   */
  SDK_VERSION: "${JSCORE_VERSION}"
};
var assert = function(assertion, message) {
  if (!assertion) {
    throw assertionError(message);
  }
};
var assertionError = function(message) {
  return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
};
var stringToByteArray = function(str) {
  var out = [];
  var p2 = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p2++] = c;
    } else if (c < 2048) {
      out[p2++] = c >> 6 | 192;
      out[p2++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p2++] = c >> 18 | 240;
      out[p2++] = c >> 12 & 63 | 128;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    } else {
      out[p2++] = c >> 12 | 224;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    }
  }
  return out;
};
var byteArrayToString = function(bytes) {
  var out = [];
  var pos = 0, c = 0;
  while (pos < bytes.length) {
    var c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      var c4 = bytes[pos++];
      var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c++] = String.fromCharCode(55296 + (u >> 10));
      out[c++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
var base64 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray: function(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    var output = [];
    for (var i = 0; i < input.length; i += 3) {
      var byte1 = input[i];
      var haveByte2 = i + 1 < input.length;
      var byte2 = haveByte2 ? input[i + 1] : 0;
      var haveByte3 = i + 2 < input.length;
      var byte3 = haveByte3 ? input[i + 2] : 0;
      var outByte1 = byte1 >> 2;
      var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      var outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString: function(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray(input), webSafe);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString: function(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray: function(input, webSafe) {
    this.init_();
    var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    var output = [];
    for (var i = 0; i < input.length; ) {
      var byte1 = charToByteMap[input.charAt(i++)];
      var haveByte2 = i < input.length;
      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      var haveByte3 = i < input.length;
      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      var haveByte4 = i < input.length;
      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      var outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          var outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_: function() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (var i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
var base64Encode = function(str) {
  var utf8Bytes = stringToByteArray(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
var base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
function deepCopy(value) {
  return deepExtend(void 0, value);
}
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date:
      var dateValue = source;
      return new Date(dateValue.getTime());
    case Object:
      if (target === void 0) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source;
  }
  for (var prop in source) {
    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source[prop]);
  }
  return target;
}
function isValidKey(key) {
  return key !== "__proto__";
}
var Deferred = (
  /** @class */
  function() {
    function Deferred2() {
      var _this = this;
      this.reject = function() {
      };
      this.resolve = function() {
      };
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
    }
    Deferred2.prototype.wrapCallback = function(callback) {
      var _this = this;
      return function(error2, value) {
        if (error2) {
          _this.reject(error2);
        } else {
          _this.resolve(value);
        }
        if (typeof callback === "function") {
          _this.promise.catch(function() {
          });
          if (callback.length === 1) {
            callback(error2);
          } else {
            callback(error2, value);
          }
        }
      };
    };
    return Deferred2;
  }()
);
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isNode() {
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch (e) {
    return false;
  }
}
function isBrowser() {
  return typeof self === "object" && self.self === self;
}
function isBrowserExtension() {
  var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
function isIE() {
  var ua3 = getUA();
  return ua3.indexOf("MSIE ") >= 0 || ua3.indexOf("Trident/") >= 0;
}
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
function isNodeSdk() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
function isIndexedDBAvailable() {
  return "indexedDB" in self && indexedDB != null;
}
function validateIndexedDBOpenable() {
  return new Promise(function(resolve, reject) {
    try {
      var preExist_1 = true;
      var DB_CHECK_NAME_1 = "validate-browser-context-for-indexeddb-analytics-module";
      var request_1 = window.indexedDB.open(DB_CHECK_NAME_1);
      request_1.onsuccess = function() {
        request_1.result.close();
        if (!preExist_1) {
          window.indexedDB.deleteDatabase(DB_CHECK_NAME_1);
        }
        resolve(true);
      };
      request_1.onupgradeneeded = function() {
        preExist_1 = false;
      };
      request_1.onerror = function() {
        var _a9;
        reject(((_a9 = request_1.error) === null || _a9 === void 0 ? void 0 : _a9.message) || "");
      };
    } catch (error2) {
      reject(error2);
    }
  });
}
function areCookiesEnabled() {
  if (!navigator || !navigator.cookieEnabled) {
    return false;
  }
  return true;
}
var ERROR_NAME = "FirebaseError";
var FirebaseError = (
  /** @class */
  function(_super) {
    __extends(FirebaseError2, _super);
    function FirebaseError2(code, message, customData) {
      var _this = _super.call(this, message) || this;
      _this.code = code;
      _this.customData = customData;
      _this.name = ERROR_NAME;
      Object.setPrototypeOf(_this, FirebaseError2.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_this, ErrorFactory.prototype.create);
      }
      return _this;
    }
    return FirebaseError2;
  }(Error)
);
var ErrorFactory = (
  /** @class */
  function() {
    function ErrorFactory2(service, serviceName, errors) {
      this.service = service;
      this.serviceName = serviceName;
      this.errors = errors;
    }
    ErrorFactory2.prototype.create = function(code) {
      var data = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        data[_i2 - 1] = arguments[_i2];
      }
      var customData = data[0] || {};
      var fullCode = this.service + "/" + code;
      var template = this.errors[code];
      var message = template ? replaceTemplate(template, customData) : "Error";
      var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
      var error2 = new FirebaseError(fullCode, fullMessage, customData);
      return error2;
    };
    return ErrorFactory2;
  }()
);
function replaceTemplate(template, data) {
  return template.replace(PATTERN, function(_2, key) {
    var value = data[key];
    return value != null ? String(value) : "<" + key + "?>";
  });
}
var PATTERN = /\{\$([^}]+)}/g;
function jsonEval(str) {
  return JSON.parse(str);
}
function stringify(data) {
  return JSON.stringify(data);
}
var decode = function(token) {
  var header = {}, claims = {}, data = {}, signature = "";
  try {
    var parts = token.split(".");
    header = jsonEval(base64Decode(parts[0]) || "");
    claims = jsonEval(base64Decode(parts[1]) || "");
    signature = parts[2];
    data = claims["d"] || {};
    delete claims["d"];
  } catch (e) {
  }
  return {
    header,
    claims,
    data,
    signature
  };
};
var isValidFormat = function(token) {
  var decoded = decode(token), claims = decoded.claims;
  return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
};
var isAdmin = function(token) {
  var claims = decode(token).claims;
  return typeof claims === "object" && claims["admin"] === true;
};
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return void 0;
  }
}
function isEmpty(obj) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function map(obj, fn2, contextObj) {
  var res = {};
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = fn2.call(contextObj, obj[key], key, obj);
    }
  }
  return res;
}
function querystring(querystringParams) {
  var params = [];
  var _loop_1 = function(key2, value2) {
    if (Array.isArray(value2)) {
      value2.forEach(function(arrayVal) {
        params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
    }
  };
  for (var _i2 = 0, _a9 = Object.entries(querystringParams); _i2 < _a9.length; _i2++) {
    var _b = _a9[_i2], key = _b[0], value = _b[1];
    _loop_1(key, value);
  }
  return params.length ? "&" + params.join("&") : "";
}
var Sha1 = (
  /** @class */
  function() {
    function Sha12() {
      this.chain_ = [];
      this.buf_ = [];
      this.W_ = [];
      this.pad_ = [];
      this.inbuf_ = 0;
      this.total_ = 0;
      this.blockSize = 512 / 8;
      this.pad_[0] = 128;
      for (var i = 1; i < this.blockSize; ++i) {
        this.pad_[i] = 0;
      }
      this.reset();
    }
    Sha12.prototype.reset = function() {
      this.chain_[0] = 1732584193;
      this.chain_[1] = 4023233417;
      this.chain_[2] = 2562383102;
      this.chain_[3] = 271733878;
      this.chain_[4] = 3285377520;
      this.inbuf_ = 0;
      this.total_ = 0;
    };
    Sha12.prototype.compress_ = function(buf, offset) {
      if (!offset) {
        offset = 0;
      }
      var W3 = this.W_;
      if (typeof buf === "string") {
        for (var i = 0; i < 16; i++) {
          W3[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
          offset += 4;
        }
      } else {
        for (var i = 0; i < 16; i++) {
          W3[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
          offset += 4;
        }
      }
      for (var i = 16; i < 80; i++) {
        var t3 = W3[i - 3] ^ W3[i - 8] ^ W3[i - 14] ^ W3[i - 16];
        W3[i] = (t3 << 1 | t3 >>> 31) & 4294967295;
      }
      var a = this.chain_[0];
      var b = this.chain_[1];
      var c = this.chain_[2];
      var d = this.chain_[3];
      var e = this.chain_[4];
      var f, k3;
      for (var i = 0; i < 80; i++) {
        if (i < 40) {
          if (i < 20) {
            f = d ^ b & (c ^ d);
            k3 = 1518500249;
          } else {
            f = b ^ c ^ d;
            k3 = 1859775393;
          }
        } else {
          if (i < 60) {
            f = b & c | d & (b | c);
            k3 = 2400959708;
          } else {
            f = b ^ c ^ d;
            k3 = 3395469782;
          }
        }
        var t3 = (a << 5 | a >>> 27) + f + e + k3 + W3[i] & 4294967295;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) & 4294967295;
        b = a;
        a = t3;
      }
      this.chain_[0] = this.chain_[0] + a & 4294967295;
      this.chain_[1] = this.chain_[1] + b & 4294967295;
      this.chain_[2] = this.chain_[2] + c & 4294967295;
      this.chain_[3] = this.chain_[3] + d & 4294967295;
      this.chain_[4] = this.chain_[4] + e & 4294967295;
    };
    Sha12.prototype.update = function(bytes, length) {
      if (bytes == null) {
        return;
      }
      if (length === void 0) {
        length = bytes.length;
      }
      var lengthMinusBlock = length - this.blockSize;
      var n2 = 0;
      var buf = this.buf_;
      var inbuf = this.inbuf_;
      while (n2 < length) {
        if (inbuf === 0) {
          while (n2 <= lengthMinusBlock) {
            this.compress_(bytes, n2);
            n2 += this.blockSize;
          }
        }
        if (typeof bytes === "string") {
          while (n2 < length) {
            buf[inbuf] = bytes.charCodeAt(n2);
            ++inbuf;
            ++n2;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        } else {
          while (n2 < length) {
            buf[inbuf] = bytes[n2];
            ++inbuf;
            ++n2;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        }
      }
      this.inbuf_ = inbuf;
      this.total_ += length;
    };
    Sha12.prototype.digest = function() {
      var digest = [];
      var totalBits = this.total_ * 8;
      if (this.inbuf_ < 56) {
        this.update(this.pad_, 56 - this.inbuf_);
      } else {
        this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
      }
      for (var i = this.blockSize - 1; i >= 56; i--) {
        this.buf_[i] = totalBits & 255;
        totalBits /= 256;
      }
      this.compress_(this.buf_);
      var n2 = 0;
      for (var i = 0; i < 5; i++) {
        for (var j2 = 24; j2 >= 0; j2 -= 8) {
          digest[n2] = this.chain_[i] >> j2 & 255;
          ++n2;
        }
      }
      return digest;
    };
    return Sha12;
  }()
);
function createSubscribe(executor, onNoObservers) {
  var proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
var ObserverProxy = (
  /** @class */
  function() {
    function ObserverProxy2(executor, onNoObservers) {
      var _this = this;
      this.observers = [];
      this.unsubscribes = [];
      this.observerCount = 0;
      this.task = Promise.resolve();
      this.finalized = false;
      this.onNoObservers = onNoObservers;
      this.task.then(function() {
        executor(_this);
      }).catch(function(e) {
        _this.error(e);
      });
    }
    ObserverProxy2.prototype.next = function(value) {
      this.forEachObserver(function(observer) {
        observer.next(value);
      });
    };
    ObserverProxy2.prototype.error = function(error2) {
      this.forEachObserver(function(observer) {
        observer.error(error2);
      });
      this.close(error2);
    };
    ObserverProxy2.prototype.complete = function() {
      this.forEachObserver(function(observer) {
        observer.complete();
      });
      this.close();
    };
    ObserverProxy2.prototype.subscribe = function(nextOrObserver, error2, complete) {
      var _this = this;
      var observer;
      if (nextOrObserver === void 0 && error2 === void 0 && complete === void 0) {
        throw new Error("Missing Observer.");
      }
      if (implementsAnyMethods(nextOrObserver, [
        "next",
        "error",
        "complete"
      ])) {
        observer = nextOrObserver;
      } else {
        observer = {
          next: nextOrObserver,
          error: error2,
          complete
        };
      }
      if (observer.next === void 0) {
        observer.next = noop;
      }
      if (observer.error === void 0) {
        observer.error = noop;
      }
      if (observer.complete === void 0) {
        observer.complete = noop;
      }
      var unsub = this.unsubscribeOne.bind(this, this.observers.length);
      if (this.finalized) {
        this.task.then(function() {
          try {
            if (_this.finalError) {
              observer.error(_this.finalError);
            } else {
              observer.complete();
            }
          } catch (e) {
          }
          return;
        });
      }
      this.observers.push(observer);
      return unsub;
    };
    ObserverProxy2.prototype.unsubscribeOne = function(i) {
      if (this.observers === void 0 || this.observers[i] === void 0) {
        return;
      }
      delete this.observers[i];
      this.observerCount -= 1;
      if (this.observerCount === 0 && this.onNoObservers !== void 0) {
        this.onNoObservers(this);
      }
    };
    ObserverProxy2.prototype.forEachObserver = function(fn2) {
      if (this.finalized) {
        return;
      }
      for (var i = 0; i < this.observers.length; i++) {
        this.sendOne(i, fn2);
      }
    };
    ObserverProxy2.prototype.sendOne = function(i, fn2) {
      var _this = this;
      this.task.then(function() {
        if (_this.observers !== void 0 && _this.observers[i] !== void 0) {
          try {
            fn2(_this.observers[i]);
          } catch (e) {
            if (typeof console !== "undefined" && console.error) {
              console.error(e);
            }
          }
        }
      });
    };
    ObserverProxy2.prototype.close = function(err) {
      var _this = this;
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      if (err !== void 0) {
        this.finalError = err;
      }
      this.task.then(function() {
        _this.observers = void 0;
        _this.onNoObservers = void 0;
      });
    };
    return ObserverProxy2;
  }()
);
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (var _i2 = 0, methods_1 = methods; _i2 < methods_1.length; _i2++) {
    var method = methods_1[_i2];
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop() {
}
var validateArgCount = function(fnName, minCount, maxCount, argCount) {
  var argError;
  if (argCount < minCount) {
    argError = "at least " + minCount;
  } else if (argCount > maxCount) {
    argError = maxCount === 0 ? "none" : "no more than " + maxCount;
  }
  if (argError) {
    var error2 = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
    throw new Error(error2);
  }
};
function errorPrefix(fnName, argumentNumber, optional) {
  var argName = "";
  switch (argumentNumber) {
    case 1:
      argName = optional ? "first" : "First";
      break;
    case 2:
      argName = optional ? "second" : "Second";
      break;
    case 3:
      argName = optional ? "third" : "Third";
      break;
    case 4:
      argName = optional ? "fourth" : "Fourth";
      break;
    default:
      throw new Error("errorPrefix called with argumentNumber > 4.  Need to update it?");
  }
  var error2 = fnName + " failed: ";
  error2 += argName + " argument ";
  return error2;
}
function validateCallback(fnName, argumentNumber, callback, optional) {
  if (optional && !callback) {
    return;
  }
  if (typeof callback !== "function") {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid function.");
  }
}
function validateContextObject(fnName, argumentNumber, context, optional) {
  if (optional && !context) {
    return;
  }
  if (typeof context !== "object" || context === null) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid context object.");
  }
}
var stringToByteArray$1 = function(str) {
  var out = [];
  var p2 = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      var high = c - 55296;
      i++;
      assert(i < str.length, "Surrogate pair missing trail surrogate.");
      var low = str.charCodeAt(i) - 56320;
      c = 65536 + (high << 10) + low;
    }
    if (c < 128) {
      out[p2++] = c;
    } else if (c < 2048) {
      out[p2++] = c >> 6 | 192;
      out[p2++] = c & 63 | 128;
    } else if (c < 65536) {
      out[p2++] = c >> 12 | 224;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    } else {
      out[p2++] = c >> 18 | 240;
      out[p2++] = c >> 12 & 63 | 128;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    }
  }
  return out;
};
var stringLength = function(str) {
  var p2 = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      p2++;
    } else if (c < 2048) {
      p2 += 2;
    } else if (c >= 55296 && c <= 56319) {
      p2 += 4;
      i++;
    } else {
      p2 += 3;
    }
  }
  return p2;
};
var DEFAULT_INTERVAL_MILLIS = 1e3;
var DEFAULT_BACKOFF_FACTOR = 2;
var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
var RANDOM_FACTOR = 0.5;
function calculateBackoffMillis(backoffCount, intervalMillis, backoffFactor) {
  if (intervalMillis === void 0) {
    intervalMillis = DEFAULT_INTERVAL_MILLIS;
  }
  if (backoffFactor === void 0) {
    backoffFactor = DEFAULT_BACKOFF_FACTOR;
  }
  var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
  var randomWait = Math.round(
    // A fraction of the backoff value to add/subtract.
    // Deviation: changes multiplication order to improve readability.
    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
    // if we add or subtract.
    (Math.random() - 0.5) * 2
  );
  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}

// node_modules/@firebase/component/dist/index.esm.js
var Component = (
  /** @class */
  function() {
    function Component2(name10, instanceFactory, type) {
      this.name = name10;
      this.instanceFactory = instanceFactory;
      this.type = type;
      this.multipleInstances = false;
      this.serviceProps = {};
      this.instantiationMode = "LAZY";
    }
    Component2.prototype.setInstantiationMode = function(mode) {
      this.instantiationMode = mode;
      return this;
    };
    Component2.prototype.setMultipleInstances = function(multipleInstances) {
      this.multipleInstances = multipleInstances;
      return this;
    };
    Component2.prototype.setServiceProps = function(props) {
      this.serviceProps = props;
      return this;
    };
    return Component2;
  }()
);
var DEFAULT_ENTRY_NAME = "[DEFAULT]";
var Provider = (
  /** @class */
  function() {
    function Provider2(name10, container) {
      this.name = name10;
      this.container = container;
      this.component = null;
      this.instances = /* @__PURE__ */ new Map();
      this.instancesDeferred = /* @__PURE__ */ new Map();
    }
    Provider2.prototype.get = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      if (!this.instancesDeferred.has(normalizedIdentifier)) {
        var deferred = new Deferred();
        this.instancesDeferred.set(normalizedIdentifier, deferred);
        try {
          var instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
      return this.instancesDeferred.get(normalizedIdentifier).promise;
    };
    Provider2.prototype.getImmediate = function(options) {
      var _a9 = __assign({ identifier: DEFAULT_ENTRY_NAME, optional: false }, options), identifier = _a9.identifier, optional = _a9.optional;
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      try {
        var instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        if (!instance) {
          if (optional) {
            return null;
          }
          throw Error("Service " + this.name + " is not available");
        }
        return instance;
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    };
    Provider2.prototype.getComponent = function() {
      return this.component;
    };
    Provider2.prototype.setComponent = function(component) {
      var e_1, _a9;
      if (component.name !== this.name) {
        throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
      }
      if (this.component) {
        throw Error("Component for " + this.name + " has already been provided");
      }
      this.component = component;
      if (isComponentEager(component)) {
        try {
          this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
        } catch (e) {
        }
      }
      try {
        for (var _b = __values(this.instancesDeferred.entries()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
          var _d = __read(_c2.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
          var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            var instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            instanceDeferred.resolve(instance);
          } catch (e) {
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a9 = _b.return))
            _a9.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    Provider2.prototype.clearInstance = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      this.instancesDeferred.delete(identifier);
      this.instances.delete(identifier);
    };
    Provider2.prototype.delete = function() {
      return __awaiter(this, void 0, void 0, function() {
        var services;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              services = Array.from(this.instances.values());
              return [4, Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function(service) {
                return "INTERNAL" in service;
              }).map(function(service) {
                return service.INTERNAL.delete();
              }))), __read(services.filter(function(service) {
                return "_delete" in service;
              }).map(function(service) {
                return service._delete();
              }))))];
            case 1:
              _a9.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Provider2.prototype.isComponentSet = function() {
      return this.component != null;
    };
    Provider2.prototype.isInitialized = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      return this.instances.has(identifier);
    };
    Provider2.prototype.initialize = function(opts) {
      if (opts === void 0) {
        opts = {};
      }
      var _a9 = opts.instanceIdentifier, instanceIdentifier = _a9 === void 0 ? DEFAULT_ENTRY_NAME : _a9, _b = opts.options, options = _b === void 0 ? {} : _b;
      var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (this.isInitialized(normalizedIdentifier)) {
        throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
      }
      if (!this.isComponentSet()) {
        throw Error("Component " + this.name + " has not been registered yet");
      }
      return this.getOrInitializeService({
        instanceIdentifier: normalizedIdentifier,
        options
      });
    };
    Provider2.prototype.getOrInitializeService = function(_a9) {
      var instanceIdentifier = _a9.instanceIdentifier, _b = _a9.options, options = _b === void 0 ? {} : _b;
      var instance = this.instances.get(instanceIdentifier);
      if (!instance && this.component) {
        instance = this.component.instanceFactory(this.container, {
          instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
          options
        });
        this.instances.set(instanceIdentifier, instance);
      }
      return instance || null;
    };
    Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
      if (this.component) {
        return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
      } else {
        return identifier;
      }
    };
    return Provider2;
  }()
);
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
var ComponentContainer = (
  /** @class */
  function() {
    function ComponentContainer2(name10) {
      this.name = name10;
      this.providers = /* @__PURE__ */ new Map();
    }
    ComponentContainer2.prototype.addComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        throw new Error("Component " + component.name + " has already been registered with " + this.name);
      }
      provider.setComponent(component);
    };
    ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        this.providers.delete(component.name);
      }
      this.addComponent(component);
    };
    ComponentContainer2.prototype.getProvider = function(name10) {
      if (this.providers.has(name10)) {
        return this.providers.get(name10);
      }
      var provider = new Provider(name10, this);
      this.providers.set(name10, provider);
      return provider;
    };
    ComponentContainer2.prototype.getProviders = function() {
      return Array.from(this.providers.values());
    };
    return ComponentContainer2;
  }()
);

// node_modules/@firebase/logger/dist/index.esm.js
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k3 = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k3++)
      r2[k3] = a[j2];
  return r2;
}
var _a;
var instances = [];
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
var levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
var defaultLogLevel = LogLevel.INFO;
var ConsoleMethod = (_a = {}, _a[LogLevel.DEBUG] = "log", _a[LogLevel.VERBOSE] = "log", _a[LogLevel.INFO] = "info", _a[LogLevel.WARN] = "warn", _a[LogLevel.ERROR] = "error", _a);
var defaultLogHandler = function(instance, logType) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (logType < instance.logLevel) {
    return;
  }
  var now = (/* @__PURE__ */ new Date()).toISOString();
  var method = ConsoleMethod[logType];
  if (method) {
    console[method].apply(console, __spreadArrays(["[" + now + "]  " + instance.name + ":"], args));
  } else {
    throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
  }
};
var Logger = (
  /** @class */
  function() {
    function Logger2(name10) {
      this.name = name10;
      this._logLevel = defaultLogLevel;
      this._logHandler = defaultLogHandler;
      this._userLogHandler = null;
      instances.push(this);
    }
    Object.defineProperty(Logger2.prototype, "logLevel", {
      get: function() {
        return this._logLevel;
      },
      set: function(val) {
        if (!(val in LogLevel)) {
          throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
        }
        this._logLevel = val;
      },
      enumerable: false,
      configurable: true
    });
    Logger2.prototype.setLogLevel = function(val) {
      this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
    };
    Object.defineProperty(Logger2.prototype, "logHandler", {
      get: function() {
        return this._logHandler;
      },
      set: function(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Logger2.prototype, "userLogHandler", {
      get: function() {
        return this._userLogHandler;
      },
      set: function(val) {
        this._userLogHandler = val;
      },
      enumerable: false,
      configurable: true
    });
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
      this._logHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
    };
    Logger2.prototype.log = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
      this._logHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
      this._logHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
      this._logHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
      this._logHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
    };
    return Logger2;
  }()
);
function setLogLevel(level) {
  instances.forEach(function(inst) {
    inst.setLogLevel(level);
  });
}
function setUserLogHandler(logCallback, options) {
  var _loop_1 = function(instance2) {
    var customLogLevel = null;
    if (options && options.level) {
      customLogLevel = levelStringToEnum[options.level];
    }
    if (logCallback === null) {
      instance2.userLogHandler = null;
    } else {
      instance2.userLogHandler = function(instance3, level) {
        var args = [];
        for (var _i3 = 2; _i3 < arguments.length; _i3++) {
          args[_i3 - 2] = arguments[_i3];
        }
        var message = args.map(function(arg) {
          if (arg == null) {
            return null;
          } else if (typeof arg === "string") {
            return arg;
          } else if (typeof arg === "number" || typeof arg === "boolean") {
            return arg.toString();
          } else if (arg instanceof Error) {
            return arg.message;
          } else {
            try {
              return JSON.stringify(arg);
            } catch (ignored) {
              return null;
            }
          }
        }).filter(function(arg) {
          return arg;
        }).join(" ");
        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
          logCallback({
            level: LogLevel[level].toLowerCase(),
            message,
            args,
            type: instance3.name
          });
        }
      };
    }
  };
  for (var _i2 = 0, instances_1 = instances; _i2 < instances_1.length; _i2++) {
    var instance = instances_1[_i2];
    _loop_1(instance);
  }
}

// node_modules/@firebase/app/dist/index.esm.js
var _a2;
var ERRORS = (_a2 = {}, _a2[
  "no-app"
  /* NO_APP */
] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", _a2[
  "bad-app-name"
  /* BAD_APP_NAME */
] = "Illegal App name: '{$appName}", _a2[
  "duplicate-app"
  /* DUPLICATE_APP */
] = "Firebase App named '{$appName}' already exists", _a2[
  "app-deleted"
  /* APP_DELETED */
] = "Firebase App named '{$appName}' already deleted", _a2[
  "invalid-app-argument"
  /* INVALID_APP_ARGUMENT */
] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", _a2[
  "invalid-log-argument"
  /* INVALID_LOG_ARGUMENT */
] = "First argument to `onLog` must be null or a function.", _a2);
var ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
var name = "@firebase/app";
var version = "0.6.17";
var name$1 = "@firebase/analytics";
var name$2 = "@firebase/auth";
var name$3 = "@firebase/database";
var name$4 = "@firebase/functions";
var name$5 = "@firebase/installations";
var name$6 = "@firebase/messaging";
var name$7 = "@firebase/performance";
var name$8 = "@firebase/remote-config";
var name$9 = "@firebase/storage";
var name$a = "@firebase/firestore";
var name$b = "firebase-wrapper";
var _a$1;
var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
var PLATFORM_LOG_STRING = (_a$1 = {}, _a$1[name] = "fire-core", _a$1[name$1] = "fire-analytics", _a$1[name$2] = "fire-auth", _a$1[name$3] = "fire-rtdb", _a$1[name$4] = "fire-fn", _a$1[name$5] = "fire-iid", _a$1[name$6] = "fire-fcm", _a$1[name$7] = "fire-perf", _a$1[name$8] = "fire-rc", _a$1[name$9] = "fire-gcs", _a$1[name$a] = "fire-fst", _a$1["fire-js"] = "fire-js", _a$1[name$b] = "fire-js-all", _a$1);
var logger = new Logger("@firebase/app");
var FirebaseAppImpl = (
  /** @class */
  function() {
    function FirebaseAppImpl2(options, config, firebase_) {
      var _this = this;
      this.firebase_ = firebase_;
      this.isDeleted_ = false;
      this.name_ = config.name;
      this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
      this.options_ = deepCopy(options);
      this.container = new ComponentContainer(config.name);
      this._addComponent(new Component(
        "app",
        function() {
          return _this;
        },
        "PUBLIC"
        /* PUBLIC */
      ));
      this.firebase_.INTERNAL.components.forEach(function(component) {
        return _this._addComponent(component);
      });
    }
    Object.defineProperty(FirebaseAppImpl2.prototype, "automaticDataCollectionEnabled", {
      get: function() {
        this.checkDestroyed_();
        return this.automaticDataCollectionEnabled_;
      },
      set: function(val) {
        this.checkDestroyed_();
        this.automaticDataCollectionEnabled_ = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseAppImpl2.prototype, "name", {
      get: function() {
        this.checkDestroyed_();
        return this.name_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseAppImpl2.prototype, "options", {
      get: function() {
        this.checkDestroyed_();
        return this.options_;
      },
      enumerable: false,
      configurable: true
    });
    FirebaseAppImpl2.prototype.delete = function() {
      var _this = this;
      return new Promise(function(resolve) {
        _this.checkDestroyed_();
        resolve();
      }).then(function() {
        _this.firebase_.INTERNAL.removeApp(_this.name_);
        return Promise.all(_this.container.getProviders().map(function(provider) {
          return provider.delete();
        }));
      }).then(function() {
        _this.isDeleted_ = true;
      });
    };
    FirebaseAppImpl2.prototype._getService = function(name10, instanceIdentifier) {
      if (instanceIdentifier === void 0) {
        instanceIdentifier = DEFAULT_ENTRY_NAME2;
      }
      this.checkDestroyed_();
      return this.container.getProvider(name10).getImmediate({
        identifier: instanceIdentifier
      });
    };
    FirebaseAppImpl2.prototype._removeServiceInstance = function(name10, instanceIdentifier) {
      if (instanceIdentifier === void 0) {
        instanceIdentifier = DEFAULT_ENTRY_NAME2;
      }
      this.container.getProvider(name10).clearInstance(instanceIdentifier);
    };
    FirebaseAppImpl2.prototype._addComponent = function(component) {
      try {
        this.container.addComponent(component);
      } catch (e) {
        logger.debug("Component " + component.name + " failed to register with FirebaseApp " + this.name, e);
      }
    };
    FirebaseAppImpl2.prototype._addOrOverwriteComponent = function(component) {
      this.container.addOrOverwriteComponent(component);
    };
    FirebaseAppImpl2.prototype.toJSON = function() {
      return {
        name: this.name,
        automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
        options: this.options
      };
    };
    FirebaseAppImpl2.prototype.checkDestroyed_ = function() {
      if (this.isDeleted_) {
        throw ERROR_FACTORY.create("app-deleted", { appName: this.name_ });
      }
    };
    return FirebaseAppImpl2;
  }()
);
FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log("dc");
var version$1 = "8.3.1";
function createFirebaseNamespaceCore(firebaseAppImpl) {
  var apps = {};
  var components = /* @__PURE__ */ new Map();
  var namespace = {
    // Hack to prevent Babel from modifying the object returned
    // as the firebase namespace.
    // @ts-ignore
    __esModule: true,
    initializeApp: initializeApp2,
    // @ts-ignore
    app,
    registerVersion,
    setLogLevel,
    onLog,
    // @ts-ignore
    apps: null,
    SDK_VERSION: version$1,
    INTERNAL: {
      registerComponent,
      removeApp,
      components,
      useAsService
    }
  };
  namespace["default"] = namespace;
  Object.defineProperty(namespace, "apps", {
    get: getApps
  });
  function removeApp(name10) {
    delete apps[name10];
  }
  function app(name10) {
    name10 = name10 || DEFAULT_ENTRY_NAME2;
    if (!contains(apps, name10)) {
      throw ERROR_FACTORY.create("no-app", { appName: name10 });
    }
    return apps[name10];
  }
  app["App"] = firebaseAppImpl;
  function initializeApp2(options, rawConfig) {
    if (rawConfig === void 0) {
      rawConfig = {};
    }
    if (typeof rawConfig !== "object" || rawConfig === null) {
      var name_1 = rawConfig;
      rawConfig = { name: name_1 };
    }
    var config = rawConfig;
    if (config.name === void 0) {
      config.name = DEFAULT_ENTRY_NAME2;
    }
    var name10 = config.name;
    if (typeof name10 !== "string" || !name10) {
      throw ERROR_FACTORY.create("bad-app-name", {
        appName: String(name10)
      });
    }
    if (contains(apps, name10)) {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name10 });
    }
    var app2 = new firebaseAppImpl(options, config, namespace);
    apps[name10] = app2;
    return app2;
  }
  function getApps() {
    return Object.keys(apps).map(function(name10) {
      return apps[name10];
    });
  }
  function registerComponent(component) {
    var componentName = component.name;
    if (components.has(componentName)) {
      logger.debug("There were multiple attempts to register component " + componentName + ".");
      return component.type === "PUBLIC" ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        namespace[componentName]
      ) : null;
    }
    components.set(componentName, component);
    if (component.type === "PUBLIC") {
      var serviceNamespace = function(appArg) {
        if (appArg === void 0) {
          appArg = app();
        }
        if (typeof appArg[componentName] !== "function") {
          throw ERROR_FACTORY.create("invalid-app-argument", {
            appName: componentName
          });
        }
        return appArg[componentName]();
      };
      if (component.serviceProps !== void 0) {
        deepExtend(serviceNamespace, component.serviceProps);
      }
      namespace[componentName] = serviceNamespace;
      firebaseAppImpl.prototype[componentName] = // TODO: The eslint disable can be removed and the 'ignoreRestArgs'
      // option added to the no-explicit-any rule when ESlint releases it.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function() {
        var args = [];
        for (var _i3 = 0; _i3 < arguments.length; _i3++) {
          args[_i3] = arguments[_i3];
        }
        var serviceFxn = this._getService.bind(this, componentName);
        return serviceFxn.apply(this, component.multipleInstances ? args : []);
      };
    }
    for (var _i2 = 0, _a9 = Object.keys(apps); _i2 < _a9.length; _i2++) {
      var appName = _a9[_i2];
      apps[appName]._addComponent(component);
    }
    return component.type === "PUBLIC" ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      namespace[componentName]
    ) : null;
  }
  function registerVersion(libraryKeyOrName, version10, variant) {
    var _a9;
    var library = (_a9 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a9 !== void 0 ? _a9 : libraryKeyOrName;
    if (variant) {
      library += "-" + variant;
    }
    var libraryMismatch = library.match(/\s|\//);
    var versionMismatch = version10.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
      var warning = [
        'Unable to register library "' + library + '" with version "' + version10 + '":'
      ];
      if (libraryMismatch) {
        warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
      }
      if (libraryMismatch && versionMismatch) {
        warning.push("and");
      }
      if (versionMismatch) {
        warning.push('version name "' + version10 + '" contains illegal characters (whitespace or "/")');
      }
      logger.warn(warning.join(" "));
      return;
    }
    registerComponent(new Component(
      library + "-version",
      function() {
        return { library, version: version10 };
      },
      "VERSION"
      /* VERSION */
    ));
  }
  function onLog(logCallback, options) {
    if (logCallback !== null && typeof logCallback !== "function") {
      throw ERROR_FACTORY.create(
        "invalid-log-argument"
        /* INVALID_LOG_ARGUMENT */
      );
    }
    setUserLogHandler(logCallback, options);
  }
  function useAsService(app2, name10) {
    if (name10 === "serverAuth") {
      return null;
    }
    var useService = name10;
    return useService;
  }
  return namespace;
}
function createFirebaseNamespace() {
  var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
  namespace.INTERNAL = __assign(__assign({}, namespace.INTERNAL), {
    createFirebaseNamespace,
    extendNamespace,
    createSubscribe,
    ErrorFactory,
    deepExtend
  });
  function extendNamespace(props) {
    deepExtend(namespace, props);
  }
  return namespace;
}
var firebase = createFirebaseNamespace();
var PlatformLoggerService = (
  /** @class */
  function() {
    function PlatformLoggerService2(container) {
      this.container = container;
    }
    PlatformLoggerService2.prototype.getPlatformInfoString = function() {
      var providers = this.container.getProviders();
      return providers.map(function(provider) {
        if (isVersionServiceProvider(provider)) {
          var service = provider.getImmediate();
          return service.library + "/" + service.version;
        } else {
          return null;
        }
      }).filter(function(logString) {
        return logString;
      }).join(" ");
    };
    return PlatformLoggerService2;
  }()
);
function isVersionServiceProvider(provider) {
  var component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
function registerCoreComponents(firebase2, variant) {
  firebase2.INTERNAL.registerComponent(new Component(
    "platform-logger",
    function(container) {
      return new PlatformLoggerService(container);
    },
    "PRIVATE"
    /* PRIVATE */
  ));
  firebase2.registerVersion(name, version, variant);
  firebase2.registerVersion("fire-js", "");
}
if (isBrowser() && self.firebase !== void 0) {
  logger.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  ");
  sdkVersion = self.firebase.SDK_VERSION;
  if (sdkVersion && sdkVersion.indexOf("LITE") >= 0) {
    logger.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ");
  }
}
var sdkVersion;
var initializeApp = firebase.initializeApp;
firebase.initializeApp = function() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  if (isNode()) {
    logger.warn(`
      Warning: This is a browser-targeted Firebase bundle but it appears it is being
      run in a Node environment.  If running in a Node environment, make sure you
      are using the bundle specified by the "main" field in package.json.
      
      If you are using Webpack, you can specify "main" as the first item in
      "resolve.mainFields":
      https://webpack.js.org/configuration/resolve/#resolvemainfields
      
      If using Rollup, use the @rollup/plugin-node-resolve plugin and specify "main"
      as the first item in "mainFields", e.g. ['main', 'module'].
      https://github.com/rollup/@rollup/plugin-node-resolve
      `);
  }
  return initializeApp.apply(void 0, args);
};
var firebase$1 = firebase;
registerCoreComponents(firebase$1);
var index_esm_default = firebase$1;

// node_modules/@firebase/auth/dist/auth.esm.js
(function() {
  var k3, aa3 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
    a != Array.prototype && a != Object.prototype && (a[b] = c.value);
  };
  function ba3(a) {
    a = ["object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global, a];
    for (var b = 0; b < a.length; ++b) {
      var c = a[b];
      if (c && c.Math == Math)
        return c;
    }
    return globalThis;
  }
  var ca3 = ba3(this);
  function da3(a, b) {
    if (b) {
      var c = ca3;
      a = a.split(".");
      for (var d = 0; d < a.length - 1; d++) {
        var e = a[d];
        e in c || (c[e] = {});
        c = c[e];
      }
      a = a[a.length - 1];
      d = c[a];
      b = b(d);
      b != d && null != b && aa3(c, a, { configurable: true, writable: true, value: b });
    }
  }
  function ea3(a) {
    var b = 0;
    return function() {
      return b < a.length ? { done: false, value: a[b++] } : { done: true };
    };
  }
  function fa3(a) {
    var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return b ? b.call(a) : { next: ea3(a) };
  }
  da3("Promise", function(a) {
    function b(g) {
      this.b = 0;
      this.c = void 0;
      this.a = [];
      var h2 = this.f();
      try {
        g(h2.resolve, h2.reject);
      } catch (m) {
        h2.reject(m);
      }
    }
    function c() {
      this.a = null;
    }
    function d(g) {
      return g instanceof b ? g : new b(function(h2) {
        h2(g);
      });
    }
    if (a)
      return a;
    c.prototype.b = function(g) {
      if (null == this.a) {
        this.a = [];
        var h2 = this;
        this.c(function() {
          h2.g();
        });
      }
      this.a.push(g);
    };
    var e = ca3.setTimeout;
    c.prototype.c = function(g) {
      e(g, 0);
    };
    c.prototype.g = function() {
      for (; this.a && this.a.length; ) {
        var g = this.a;
        this.a = [];
        for (var h2 = 0; h2 < g.length; ++h2) {
          var m = g[h2];
          g[h2] = null;
          try {
            m();
          } catch (p2) {
            this.f(p2);
          }
        }
      }
      this.a = null;
    };
    c.prototype.f = function(g) {
      this.c(function() {
        throw g;
      });
    };
    b.prototype.f = function() {
      function g(p2) {
        return function(v2) {
          m || (m = true, p2.call(h2, v2));
        };
      }
      var h2 = this, m = false;
      return { resolve: g(this.m), reject: g(this.g) };
    };
    b.prototype.m = function(g) {
      if (g === this)
        this.g(new TypeError("A Promise cannot resolve to itself"));
      else if (g instanceof b)
        this.s(g);
      else {
        a:
          switch (typeof g) {
            case "object":
              var h2 = null != g;
              break a;
            case "function":
              h2 = true;
              break a;
            default:
              h2 = false;
          }
        h2 ? this.v(g) : this.h(g);
      }
    };
    b.prototype.v = function(g) {
      var h2 = void 0;
      try {
        h2 = g.then;
      } catch (m) {
        this.g(m);
        return;
      }
      "function" == typeof h2 ? this.u(h2, g) : this.h(g);
    };
    b.prototype.g = function(g) {
      this.i(2, g);
    };
    b.prototype.h = function(g) {
      this.i(1, g);
    };
    b.prototype.i = function(g, h2) {
      if (0 != this.b)
        throw Error("Cannot settle(" + g + ", " + h2 + "): Promise already settled in state" + this.b);
      this.b = g;
      this.c = h2;
      this.l();
    };
    b.prototype.l = function() {
      if (null != this.a) {
        for (var g = 0; g < this.a.length; ++g)
          f.b(this.a[g]);
        this.a = null;
      }
    };
    var f = new c();
    b.prototype.s = function(g) {
      var h2 = this.f();
      g.Qa(h2.resolve, h2.reject);
    };
    b.prototype.u = function(g, h2) {
      var m = this.f();
      try {
        g.call(h2, m.resolve, m.reject);
      } catch (p2) {
        m.reject(p2);
      }
    };
    b.prototype.then = function(g, h2) {
      function m(A3, Q3) {
        return "function" == typeof A3 ? function(ya2) {
          try {
            p2(A3(ya2));
          } catch (Ad2) {
            v2(Ad2);
          }
        } : Q3;
      }
      var p2, v2, B2 = new b(function(A3, Q3) {
        p2 = A3;
        v2 = Q3;
      });
      this.Qa(m(g, p2), m(h2, v2));
      return B2;
    };
    b.prototype.catch = function(g) {
      return this.then(void 0, g);
    };
    b.prototype.Qa = function(g, h2) {
      function m() {
        switch (p2.b) {
          case 1:
            g(p2.c);
            break;
          case 2:
            h2(p2.c);
            break;
          default:
            throw Error("Unexpected state: " + p2.b);
        }
      }
      var p2 = this;
      null == this.a ? f.b(m) : this.a.push(m);
    };
    b.resolve = d;
    b.reject = function(g) {
      return new b(function(h2, m) {
        m(g);
      });
    };
    b.race = function(g) {
      return new b(function(h2, m) {
        for (var p2 = fa3(g), v2 = p2.next(); !v2.done; v2 = p2.next())
          d(v2.value).Qa(h2, m);
      });
    };
    b.all = function(g) {
      var h2 = fa3(g), m = h2.next();
      return m.done ? d([]) : new b(function(p2, v2) {
        function B2(ya2) {
          return function(Ad2) {
            A3[ya2] = Ad2;
            Q3--;
            0 == Q3 && p2(A3);
          };
        }
        var A3 = [], Q3 = 0;
        do
          A3.push(void 0), Q3++, d(m.value).Qa(B2(A3.length - 1), v2), m = h2.next();
        while (!m.done);
      });
    };
    return b;
  });
  var ha3 = ha3 || {}, l = this || self, ia2 = /^[\w+/_-]+[=]{0,2}$/, ja3 = null;
  function ka3(a) {
    return (a = a.querySelector && a.querySelector("script[nonce]")) && (a = a.nonce || a.getAttribute("nonce")) && ia2.test(a) ? a : "";
  }
  function la2() {
  }
  function ma3(a) {
    var b = typeof a;
    return "object" != b ? b : a ? Array.isArray(a) ? "array" : b : "null";
  }
  function na3(a) {
    var b = ma3(a);
    return "array" == b || "object" == b && "number" == typeof a.length;
  }
  function oa3(a) {
    return "function" == ma3(a);
  }
  function n2(a) {
    var b = typeof a;
    return "object" == b && null != a || "function" == b;
  }
  function pa3(a) {
    return Object.prototype.hasOwnProperty.call(a, qa3) && a[qa3] || (a[qa3] = ++ra3);
  }
  var qa3 = "closure_uid_" + (1e9 * Math.random() >>> 0), ra3 = 0;
  function sa3(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }
  function ta3(a, b, c) {
    if (!a)
      throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function() {
        var e = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(e, d);
        return a.apply(b, e);
      };
    }
    return function() {
      return a.apply(b, arguments);
    };
  }
  function q3(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q3 = sa3 : q3 = ta3;
    return q3.apply(null, arguments);
  }
  function ua3(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
      var d = c.slice();
      d.push.apply(d, arguments);
      return a.apply(this, d);
    };
  }
  var va2 = Date.now;
  function r2(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.ab = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  }
  function wa2(a) {
    return a;
  }
  ;
  function t3(a, b, c) {
    this.code = xa2 + a;
    this.message = b || za3[a] || "";
    this.a = c || null;
  }
  r2(t3, Error);
  t3.prototype.w = function() {
    var a = { code: this.code, message: this.message };
    this.a && (a.serverResponse = this.a);
    return a;
  };
  t3.prototype.toJSON = function() {
    return this.w();
  };
  function Aa3(a) {
    var b = a && a.code;
    return b ? new t3(b.substring(xa2.length), a.message, a.serverResponse) : null;
  }
  var xa2 = "auth/", za3 = {
    "admin-restricted-operation": "This operation is restricted to administrators only.",
    "argument-error": "",
    "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
    "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
    "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
    "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
    "cordova-not-ready": "Cordova framework is not ready.",
    "cors-unsupported": "This browser is not supported.",
    "credential-already-in-use": "This credential is already associated with a different user account.",
    "custom-token-mismatch": "The custom token corresponds to a different audience.",
    "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
    "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
    "email-change-needs-verification": "Multi-factor users must always have a verified email.",
    "email-already-in-use": "The email address is already in use by another account.",
    "expired-action-code": "The action code has expired. ",
    "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
    "internal-error": "An internal error has occurred.",
    "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
    "invalid-app-id": "The mobile app identifier is not registed for the current project.",
    "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
    "invalid-auth-event": "An internal error has occurred.",
    "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.",
    "invalid-continue-uri": "The continue URL provided in the request is invalid.",
    "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
    "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
    "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.",
    "invalid-email": "The email address is badly formatted.",
    "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
    "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
    "invalid-credential": "The supplied auth credential is malformed or has expired.",
    "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
    "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.",
    "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
    "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
    "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
    "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
    "wrong-password": "The password is invalid or the user does not have a password.",
    "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
    "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
    "invalid-provider-id": "The specified provider ID is invalid.",
    "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
    "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
    "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
    "invalid-tenant-id": "The Auth instance's tenant ID is invalid.",
    "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.",
    "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.",
    "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
    "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
    "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
    "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
    "missing-continue-uri": "A continue URL must be provided in the request.",
    "missing-iframe-start": "An internal error has occurred.",
    "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
    "missing-multi-factor-info": "No second factor identifier is provided.",
    "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.",
    "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
    "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
    "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
    "app-deleted": "This instance of FirebaseApp has been deleted.",
    "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
    "network-request-failed": "A network error (such as timeout, interrupted connection or unreachable host) has occurred.",
    "no-auth-event": "An internal error has occurred.",
    "no-such-provider": "User was not linked to an account with the given provider.",
    "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
    "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
    "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
    "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
    "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
    "provider-already-linked": "User can only be linked to one identity for the given provider.",
    "quota-exceeded": "The project's quota for this operation has been exceeded.",
    "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
    "redirect-operation-pending": "A redirect sign-in operation is already pending.",
    "rejected-credential": "The request contains malformed or mismatching credentials.",
    "second-factor-already-in-use": "The second factor is already enrolled on this account.",
    "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.",
    "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID",
    timeout: "The operation has timed out.",
    "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
    "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
    "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
    "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
    "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
    "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.",
    "unverified-email": "The operation requires a verified email.",
    "user-cancelled": "The user did not grant your application the permissions it requested.",
    "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
    "user-disabled": "The user account has been disabled by an administrator.",
    "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
    "user-signed-out": "",
    "weak-password": "The password must be 6 characters long or more.",
    "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled."
  };
  var Ba3 = { ld: { Ta: "https://staging-identitytoolkit.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/", Za: "https://staging-securetoken.sandbox.googleapis.com/v1/token", Wa: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/", id: "b" }, sd: { Ta: "https://www.googleapis.com/identitytoolkit/v3/relyingparty/", Za: "https://securetoken.googleapis.com/v1/token", Wa: "https://identitytoolkit.googleapis.com/v2/", id: "p" }, ud: {
    Ta: "https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",
    Za: "https://staging-securetoken.sandbox.googleapis.com/v1/token",
    Wa: "https://staging-identitytoolkit.sandbox.googleapis.com/v2/",
    id: "s"
  }, vd: { Ta: "https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/", Za: "https://test-securetoken.sandbox.googleapis.com/v1/token", Wa: "https://test-identitytoolkit.sandbox.googleapis.com/v2/", id: "t" } };
  function Ca3(a) {
    for (var b in Ba3)
      if (Ba3[b].id === a)
        return a = Ba3[b], { firebaseEndpoint: a.Ta, secureTokenEndpoint: a.Za, identityPlatformEndpoint: a.Wa };
    return null;
  }
  var Da3;
  Da3 = Ca3("__EID__") ? "__EID__" : void 0;
  function Ea3(a) {
    if (!a)
      return false;
    try {
      return !!a.$goog_Thenable;
    } catch (b) {
      return false;
    }
  }
  ;
  function u(a) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, u);
    else {
      var b = Error().stack;
      b && (this.stack = b);
    }
    a && (this.message = String(a));
  }
  r2(u, Error);
  u.prototype.name = "CustomError";
  function Fa3(a, b) {
    a = a.split("%s");
    for (var c = "", d = a.length - 1, e = 0; e < d; e++)
      c += a[e] + (e < b.length ? b[e] : "%s");
    u.call(this, c + a[d]);
  }
  r2(Fa3, u);
  Fa3.prototype.name = "AssertionError";
  function Ga3(a, b) {
    throw new Fa3("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
  }
  ;
  function Ha3(a, b) {
    this.c = a;
    this.f = b;
    this.b = 0;
    this.a = null;
  }
  Ha3.prototype.get = function() {
    if (0 < this.b) {
      this.b--;
      var a = this.a;
      this.a = a.next;
      a.next = null;
    } else
      a = this.c();
    return a;
  };
  function Ia3(a, b) {
    a.f(b);
    100 > a.b && (a.b++, b.next = a.a, a.a = b);
  }
  ;
  function Ja3() {
    this.b = this.a = null;
  }
  var La3 = new Ha3(function() {
    return new Ka3();
  }, function(a) {
    a.reset();
  });
  Ja3.prototype.add = function(a, b) {
    var c = La3.get();
    c.set(a, b);
    this.b ? this.b.next = c : this.a = c;
    this.b = c;
  };
  function Ma3() {
    var a = Na2, b = null;
    a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);
    return b;
  }
  function Ka3() {
    this.next = this.b = this.a = null;
  }
  Ka3.prototype.set = function(a, b) {
    this.a = a;
    this.b = b;
    this.next = null;
  };
  Ka3.prototype.reset = function() {
    this.next = this.b = this.a = null;
  };
  var Oa2 = Array.prototype.indexOf ? function(a, b) {
    return Array.prototype.indexOf.call(a, b, void 0);
  } : function(a, b) {
    if ("string" === typeof a)
      return "string" !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0);
    for (var c = 0; c < a.length; c++)
      if (c in a && a[c] === b)
        return c;
    return -1;
  }, w2 = Array.prototype.forEach ? function(a, b, c) {
    Array.prototype.forEach.call(a, b, c);
  } : function(a, b, c) {
    for (var d = a.length, e = "string" === typeof a ? a.split("") : a, f = 0; f < d; f++)
      f in e && b.call(c, e[f], f, a);
  };
  function Pa2(a, b) {
    for (var c = "string" === typeof a ? a.split("") : a, d = a.length - 1; 0 <= d; --d)
      d in c && b.call(void 0, c[d], d, a);
  }
  var Qa3 = Array.prototype.filter ? function(a, b) {
    return Array.prototype.filter.call(a, b, void 0);
  } : function(a, b) {
    for (var c = a.length, d = [], e = 0, f = "string" === typeof a ? a.split("") : a, g = 0; g < c; g++)
      if (g in f) {
        var h2 = f[g];
        b.call(void 0, h2, g, a) && (d[e++] = h2);
      }
    return d;
  }, Ra3 = Array.prototype.map ? function(a, b) {
    return Array.prototype.map.call(a, b, void 0);
  } : function(a, b) {
    for (var c = a.length, d = Array(c), e = "string" === typeof a ? a.split("") : a, f = 0; f < c; f++)
      f in e && (d[f] = b.call(void 0, e[f], f, a));
    return d;
  }, Sa2 = Array.prototype.some ? function(a, b) {
    return Array.prototype.some.call(a, b, void 0);
  } : function(a, b) {
    for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a))
        return true;
    return false;
  };
  function Ta3(a) {
    a: {
      var b = Ua3;
      for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
        if (e in d && b.call(void 0, d[e], e, a)) {
          b = e;
          break a;
        }
      b = -1;
    }
    return 0 > b ? null : "string" === typeof a ? a.charAt(b) : a[b];
  }
  function Va3(a, b) {
    return 0 <= Oa2(a, b);
  }
  function Wa3(a, b) {
    b = Oa2(a, b);
    var c;
    (c = 0 <= b) && Array.prototype.splice.call(a, b, 1);
    return c;
  }
  function Xa3(a, b) {
    var c = 0;
    Pa2(a, function(d, e) {
      b.call(void 0, d, e, a) && 1 == Array.prototype.splice.call(a, e, 1).length && c++;
    });
  }
  function Ya3(a) {
    return Array.prototype.concat.apply([], arguments);
  }
  function Za3(a) {
    var b = a.length;
    if (0 < b) {
      for (var c = Array(b), d = 0; d < b; d++)
        c[d] = a[d];
      return c;
    }
    return [];
  }
  ;
  var $a3 = String.prototype.trim ? function(a) {
    return a.trim();
  } : function(a) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
  }, ab2 = /&/g, bb2 = /</g, cb2 = />/g, db2 = /"/g, eb2 = /'/g, fb = /\x00/g, gb2 = /[\x00&<>"']/;
  function x3(a, b) {
    return -1 != a.indexOf(b);
  }
  function hb2(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  ;
  var ib2;
  a: {
    var jb2 = l.navigator;
    if (jb2) {
      var kb2 = jb2.userAgent;
      if (kb2) {
        ib2 = kb2;
        break a;
      }
    }
    ib2 = "";
  }
  function y2(a) {
    return x3(ib2, a);
  }
  ;
  function lb2(a, b) {
    for (var c in a)
      b.call(void 0, a[c], c, a);
  }
  function mb2(a) {
    for (var b in a)
      return false;
    return true;
  }
  function nb2(a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  }
  var ob2 = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function z3(a, b) {
    for (var c, d, e = 1; e < arguments.length; e++) {
      d = arguments[e];
      for (c in d)
        a[c] = d[c];
      for (var f = 0; f < ob2.length; f++)
        c = ob2[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  }
  ;
  function pb2(a, b) {
    a: {
      try {
        var c = a && a.ownerDocument, d = c && (c.defaultView || c.parentWindow);
        d = d || l;
        if (d.Element && d.Location) {
          var e = d;
          break a;
        }
      } catch (g) {
      }
      e = null;
    }
    if (e && "undefined" != typeof e[b] && (!a || !(a instanceof e[b]) && (a instanceof e.Location || a instanceof e.Element))) {
      if (n2(a))
        try {
          var f = a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a);
        } catch (g) {
          f = "<object could not be stringified>";
        }
      else
        f = void 0 === a ? "undefined" : null === a ? "null" : typeof a;
      Ga3(
        "Argument is not a %s (or a non-Element, non-Location mock); got: %s",
        b,
        f
      );
    }
  }
  ;
  function qb2(a, b) {
    this.a = a === rb && b || "";
    this.b = sb2;
  }
  qb2.prototype.sa = true;
  qb2.prototype.ra = function() {
    return this.a;
  };
  qb2.prototype.toString = function() {
    return "Const{" + this.a + "}";
  };
  function tb2(a) {
    if (a instanceof qb2 && a.constructor === qb2 && a.b === sb2)
      return a.a;
    Ga3("expected object of type Const, got '" + a + "'");
    return "type_error:Const";
  }
  var sb2 = {}, rb = {};
  var ub2;
  function vb2() {
    if (void 0 === ub2) {
      var a = null, b = l.trustedTypes;
      if (b && b.createPolicy) {
        try {
          a = b.createPolicy("goog#html", { createHTML: wa2, createScript: wa2, createScriptURL: wa2 });
        } catch (c) {
          l.console && l.console.error(c.message);
        }
        ub2 = a;
      } else
        ub2 = a;
    }
    return ub2;
  }
  ;
  function wb2(a, b) {
    this.a = b === xb2 ? a : "";
  }
  wb2.prototype.sa = true;
  wb2.prototype.ra = function() {
    return this.a.toString();
  };
  wb2.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.a + "}";
  };
  function yb2(a) {
    if (a instanceof wb2 && a.constructor === wb2)
      return a.a;
    Ga3("expected object of type TrustedResourceUrl, got '" + a + "' of type " + ma3(a));
    return "type_error:TrustedResourceUrl";
  }
  function zb2(a, b) {
    var c = tb2(a);
    if (!Ab2.test(c))
      throw Error("Invalid TrustedResourceUrl format: " + c);
    a = c.replace(Bb2, function(d, e) {
      if (!Object.prototype.hasOwnProperty.call(b, e))
        throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b));
      d = b[e];
      return d instanceof qb2 ? tb2(d) : encodeURIComponent(String(d));
    });
    return Cb2(a);
  }
  var Bb2 = /%{(\w+)}/g, Ab2 = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, xb2 = {};
  function Cb2(a) {
    var b = vb2();
    a = b ? b.createScriptURL(a) : a;
    return new wb2(a, xb2);
  }
  ;
  function C2(a, b) {
    this.a = b === Db2 ? a : "";
  }
  C2.prototype.sa = true;
  C2.prototype.ra = function() {
    return this.a.toString();
  };
  C2.prototype.toString = function() {
    return "SafeUrl{" + this.a + "}";
  };
  function Eb2(a) {
    if (a instanceof C2 && a.constructor === C2)
      return a.a;
    Ga3("expected object of type SafeUrl, got '" + a + "' of type " + ma3(a));
    return "type_error:SafeUrl";
  }
  var Fb2 = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|font\/\w+|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i, Gb2 = /^data:(.*);base64,[a-z0-9+\/]+=*$/i, Hb2 = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
  function Ib2(a) {
    if (a instanceof C2)
      return a;
    a = "object" == typeof a && a.sa ? a.ra() : String(a);
    if (Hb2.test(a))
      a = new C2(a, Db2);
    else {
      a = String(a);
      a = a.replace(/(%0A|%0D)/g, "");
      var b = a.match(Gb2);
      a = b && Fb2.test(b[1]) ? new C2(a, Db2) : null;
    }
    return a;
  }
  function Jb2(a) {
    if (a instanceof C2)
      return a;
    a = "object" == typeof a && a.sa ? a.ra() : String(a);
    Hb2.test(a) || (a = "about:invalid#zClosurez");
    return new C2(a, Db2);
  }
  var Db2 = {}, Kb2 = new C2("about:invalid#zClosurez", Db2);
  function Lb2(a, b, c) {
    this.a = c === Mb2 ? a : "";
  }
  Lb2.prototype.sa = true;
  Lb2.prototype.ra = function() {
    return this.a.toString();
  };
  Lb2.prototype.toString = function() {
    return "SafeHtml{" + this.a + "}";
  };
  function Nb2(a) {
    if (a instanceof Lb2 && a.constructor === Lb2)
      return a.a;
    Ga3("expected object of type SafeHtml, got '" + a + "' of type " + ma3(a));
    return "type_error:SafeHtml";
  }
  var Mb2 = {};
  function Ob2(a, b) {
    pb2(a, "HTMLScriptElement");
    a.src = yb2(b);
    (b = a.ownerDocument && a.ownerDocument.defaultView) && b != l ? b = ka3(b.document) : (null === ja3 && (ja3 = ka3(l.document)), b = ja3);
    b && a.setAttribute("nonce", b);
  }
  function Pb2(a, b, c, d) {
    a = a instanceof C2 ? a : Jb2(a);
    b = b || l;
    c = c instanceof qb2 ? tb2(c) : c || "";
    return b.open(Eb2(a), c, d, void 0);
  }
  ;
  function Qb2(a, b) {
    for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length; )
      d += c.shift() + e.shift();
    return d + c.join("%s");
  }
  function Rb2(a) {
    gb2.test(a) && (-1 != a.indexOf("&") && (a = a.replace(ab2, "&amp;")), -1 != a.indexOf("<") && (a = a.replace(bb2, "&lt;")), -1 != a.indexOf(">") && (a = a.replace(cb2, "&gt;")), -1 != a.indexOf('"') && (a = a.replace(db2, "&quot;")), -1 != a.indexOf("'") && (a = a.replace(eb2, "&#39;")), -1 != a.indexOf("\0") && (a = a.replace(fb, "&#0;")));
    return a;
  }
  ;
  function Sb2(a) {
    Sb2[" "](a);
    return a;
  }
  Sb2[" "] = la2;
  function Tb2(a, b) {
    var c = Ub2;
    return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
  }
  ;
  var Vb2 = y2("Opera"), Wb2 = y2("Trident") || y2("MSIE"), Xb2 = y2("Edge"), Yb2 = Xb2 || Wb2, Zb2 = y2("Gecko") && !(x3(ib2.toLowerCase(), "webkit") && !y2("Edge")) && !(y2("Trident") || y2("MSIE")) && !y2("Edge"), $b2 = x3(ib2.toLowerCase(), "webkit") && !y2("Edge");
  function ac3() {
    var a = l.document;
    return a ? a.documentMode : void 0;
  }
  var bc3;
  a: {
    var cc3 = "", dc3 = function() {
      var a = ib2;
      if (Zb2)
        return /rv:([^\);]+)(\)|;)/.exec(a);
      if (Xb2)
        return /Edge\/([\d\.]+)/.exec(a);
      if (Wb2)
        return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
      if ($b2)
        return /WebKit\/(\S+)/.exec(a);
      if (Vb2)
        return /(?:Version)[ \/]?(\S+)/.exec(a);
    }();
    dc3 && (cc3 = dc3 ? dc3[1] : "");
    if (Wb2) {
      var ec3 = ac3();
      if (null != ec3 && ec3 > parseFloat(cc3)) {
        bc3 = String(ec3);
        break a;
      }
    }
    bc3 = cc3;
  }
  var Ub2 = {};
  function fc3(a) {
    return Tb2(a, function() {
      for (var b = 0, c = $a3(String(bc3)).split("."), d = $a3(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
        var g = c[f] || "", h2 = d[f] || "";
        do {
          g = /(\d*)(\D*)(.*)/.exec(g) || ["", "", "", ""];
          h2 = /(\d*)(\D*)(.*)/.exec(h2) || ["", "", "", ""];
          if (0 == g[0].length && 0 == h2[0].length)
            break;
          b = hb2(0 == g[1].length ? 0 : parseInt(g[1], 10), 0 == h2[1].length ? 0 : parseInt(h2[1], 10)) || hb2(0 == g[2].length, 0 == h2[2].length) || hb2(g[2], h2[2]);
          g = g[3];
          h2 = h2[3];
        } while (0 == b);
      }
      return 0 <= b;
    });
  }
  var gc3;
  if (l.document && Wb2) {
    var hc3 = ac3();
    gc3 = hc3 ? hc3 : parseInt(bc3, 10) || void 0;
  } else
    gc3 = void 0;
  var ic3 = gc3;
  try {
    new self.OffscreenCanvas(0, 0).getContext("2d");
  } catch (a) {
  }
  var jc3 = !Wb2 || 9 <= Number(ic3);
  function kc3(a) {
    var b = document;
    return "string" === typeof a ? b.getElementById(a) : a;
  }
  function lc3(a, b) {
    lb2(b, function(c, d) {
      c && "object" == typeof c && c.sa && (c = c.ra());
      "style" == d ? a.style.cssText = c : "class" == d ? a.className = c : "for" == d ? a.htmlFor = c : mc3.hasOwnProperty(d) ? a.setAttribute(mc3[d], c) : 0 == d.lastIndexOf("aria-", 0) || 0 == d.lastIndexOf("data-", 0) ? a.setAttribute(d, c) : a[d] = c;
    });
  }
  var mc3 = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };
  function nc3(a, b, c) {
    var d = arguments, e = document, f = String(d[0]), g = d[1];
    if (!jc3 && g && (g.name || g.type)) {
      f = ["<", f];
      g.name && f.push(' name="', Rb2(g.name), '"');
      if (g.type) {
        f.push(' type="', Rb2(g.type), '"');
        var h2 = {};
        z3(h2, g);
        delete h2.type;
        g = h2;
      }
      f.push(">");
      f = f.join("");
    }
    f = oc3(e, f);
    g && ("string" === typeof g ? f.className = g : Array.isArray(g) ? f.className = g.join(" ") : lc3(f, g));
    2 < d.length && pc3(e, f, d);
    return f;
  }
  function pc3(a, b, c) {
    function d(h2) {
      h2 && b.appendChild("string" === typeof h2 ? a.createTextNode(h2) : h2);
    }
    for (var e = 2; e < c.length; e++) {
      var f = c[e];
      if (!na3(f) || n2(f) && 0 < f.nodeType)
        d(f);
      else {
        a: {
          if (f && "number" == typeof f.length) {
            if (n2(f)) {
              var g = "function" == typeof f.item || "string" == typeof f.item;
              break a;
            }
            if (oa3(f)) {
              g = "function" == typeof f.item;
              break a;
            }
          }
          g = false;
        }
        w2(g ? Za3(f) : f, d);
      }
    }
  }
  function oc3(a, b) {
    b = String(b);
    "application/xhtml+xml" === a.contentType && (b = b.toLowerCase());
    return a.createElement(b);
  }
  ;
  function qc3(a) {
    l.setTimeout(function() {
      throw a;
    }, 0);
  }
  var rc3;
  function sc3() {
    var a = l.MessageChannel;
    "undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !y2("Presto") && (a = function() {
      var e = oc3(document, "IFRAME");
      e.style.display = "none";
      document.documentElement.appendChild(e);
      var f = e.contentWindow;
      e = f.document;
      e.open();
      e.close();
      var g = "callImmediate" + Math.random(), h2 = "file:" == f.location.protocol ? "*" : f.location.protocol + "//" + f.location.host;
      e = q3(function(m) {
        if (("*" == h2 || m.origin == h2) && m.data == g)
          this.port1.onmessage();
      }, this);
      f.addEventListener("message", e, false);
      this.port1 = {};
      this.port2 = { postMessage: function() {
        f.postMessage(g, h2);
      } };
    });
    if ("undefined" !== typeof a && !y2("Trident") && !y2("MSIE")) {
      var b = new a(), c = {}, d = c;
      b.port1.onmessage = function() {
        if (void 0 !== c.next) {
          c = c.next;
          var e = c.Gb;
          c.Gb = null;
          e();
        }
      };
      return function(e) {
        d.next = { Gb: e };
        d = d.next;
        b.port2.postMessage(0);
      };
    }
    return function(e) {
      l.setTimeout(e, 0);
    };
  }
  ;
  function tc2(a, b) {
    uc3 || vc3();
    wc3 || (uc3(), wc3 = true);
    Na2.add(a, b);
  }
  var uc3;
  function vc3() {
    if (l.Promise && l.Promise.resolve) {
      var a = l.Promise.resolve(void 0);
      uc3 = function() {
        a.then(xc2);
      };
    } else
      uc3 = function() {
        var b = xc2;
        !oa3(l.setImmediate) || l.Window && l.Window.prototype && !y2("Edge") && l.Window.prototype.setImmediate == l.setImmediate ? (rc3 || (rc3 = sc3()), rc3(b)) : l.setImmediate(b);
      };
  }
  var wc3 = false, Na2 = new Ja3();
  function xc2() {
    for (var a; a = Ma3(); ) {
      try {
        a.a.call(a.b);
      } catch (b) {
        qc3(b);
      }
      Ia3(La3, a);
    }
    wc3 = false;
  }
  ;
  function D3(a, b) {
    this.a = yc3;
    this.i = void 0;
    this.f = this.b = this.c = null;
    this.g = this.h = false;
    if (a != la2)
      try {
        var c = this;
        a.call(b, function(d) {
          zc3(c, Ac3, d);
        }, function(d) {
          if (!(d instanceof Bc3))
            try {
              if (d instanceof Error)
                throw d;
              throw Error("Promise rejected.");
            } catch (e) {
            }
          zc3(c, Cc3, d);
        });
      } catch (d) {
        zc3(this, Cc3, d);
      }
  }
  var yc3 = 0, Ac3 = 2, Cc3 = 3;
  function Dc3() {
    this.next = this.f = this.b = this.g = this.a = null;
    this.c = false;
  }
  Dc3.prototype.reset = function() {
    this.f = this.b = this.g = this.a = null;
    this.c = false;
  };
  var Ec3 = new Ha3(function() {
    return new Dc3();
  }, function(a) {
    a.reset();
  });
  function Fc3(a, b, c) {
    var d = Ec3.get();
    d.g = a;
    d.b = b;
    d.f = c;
    return d;
  }
  function E3(a) {
    if (a instanceof D3)
      return a;
    var b = new D3(la2);
    zc3(b, Ac3, a);
    return b;
  }
  function F3(a) {
    return new D3(function(b, c) {
      c(a);
    });
  }
  function Gc3(a, b, c) {
    Hc2(a, b, c, null) || tc2(ua3(b, a));
  }
  function Ic3(a) {
    return new D3(function(b, c) {
      var d = a.length, e = [];
      if (d)
        for (var f = function(p2, v2) {
          d--;
          e[p2] = v2;
          0 == d && b(e);
        }, g = function(p2) {
          c(p2);
        }, h2 = 0, m; h2 < a.length; h2++)
          m = a[h2], Gc3(m, ua3(f, h2), g);
      else
        b(e);
    });
  }
  function Jc2(a) {
    return new D3(function(b) {
      var c = a.length, d = [];
      if (c)
        for (var e = function(h2, m, p2) {
          c--;
          d[h2] = m ? { Pb: true, value: p2 } : { Pb: false, reason: p2 };
          0 == c && b(d);
        }, f = 0, g; f < a.length; f++)
          g = a[f], Gc3(g, ua3(e, f, true), ua3(e, f, false));
      else
        b(d);
    });
  }
  D3.prototype.then = function(a, b, c) {
    return Kc3(this, oa3(a) ? a : null, oa3(b) ? b : null, c);
  };
  D3.prototype.$goog_Thenable = true;
  k3 = D3.prototype;
  k3.oa = function(a, b) {
    a = Fc3(a, a, b);
    a.c = true;
    Lc3(this, a);
    return this;
  };
  k3.o = function(a, b) {
    return Kc3(this, null, a, b);
  };
  k3.cancel = function(a) {
    if (this.a == yc3) {
      var b = new Bc3(a);
      tc2(function() {
        Mc3(this, b);
      }, this);
    }
  };
  function Mc3(a, b) {
    if (a.a == yc3)
      if (a.c) {
        var c = a.c;
        if (c.b) {
          for (var d = 0, e = null, f = null, g = c.b; g && (g.c || (d++, g.a == a && (e = g), !(e && 1 < d))); g = g.next)
            e || (f = g);
          e && (c.a == yc3 && 1 == d ? Mc3(c, b) : (f ? (d = f, d.next == c.f && (c.f = d), d.next = d.next.next) : Nc3(c), Oc3(c, e, Cc3, b)));
        }
        a.c = null;
      } else
        zc3(a, Cc3, b);
  }
  function Lc3(a, b) {
    a.b || a.a != Ac3 && a.a != Cc3 || Pc3(a);
    a.f ? a.f.next = b : a.b = b;
    a.f = b;
  }
  function Kc3(a, b, c, d) {
    var e = Fc3(null, null, null);
    e.a = new D3(function(f, g) {
      e.g = b ? function(h2) {
        try {
          var m = b.call(d, h2);
          f(m);
        } catch (p2) {
          g(p2);
        }
      } : f;
      e.b = c ? function(h2) {
        try {
          var m = c.call(d, h2);
          void 0 === m && h2 instanceof Bc3 ? g(h2) : f(m);
        } catch (p2) {
          g(p2);
        }
      } : g;
    });
    e.a.c = a;
    Lc3(a, e);
    return e.a;
  }
  k3.$c = function(a) {
    this.a = yc3;
    zc3(this, Ac3, a);
  };
  k3.ad = function(a) {
    this.a = yc3;
    zc3(this, Cc3, a);
  };
  function zc3(a, b, c) {
    a.a == yc3 && (a === c && (b = Cc3, c = new TypeError("Promise cannot resolve to itself")), a.a = 1, Hc2(c, a.$c, a.ad, a) || (a.i = c, a.a = b, a.c = null, Pc3(a), b != Cc3 || c instanceof Bc3 || Qc2(a, c)));
  }
  function Hc2(a, b, c, d) {
    if (a instanceof D3)
      return Lc3(a, Fc3(b || la2, c || null, d)), true;
    if (Ea3(a))
      return a.then(b, c, d), true;
    if (n2(a))
      try {
        var e = a.then;
        if (oa3(e))
          return Rc3(a, e, b, c, d), true;
      } catch (f) {
        return c.call(d, f), true;
      }
    return false;
  }
  function Rc3(a, b, c, d, e) {
    function f(m) {
      h2 || (h2 = true, d.call(e, m));
    }
    function g(m) {
      h2 || (h2 = true, c.call(e, m));
    }
    var h2 = false;
    try {
      b.call(a, g, f);
    } catch (m) {
      f(m);
    }
  }
  function Pc3(a) {
    a.h || (a.h = true, tc2(a.gc, a));
  }
  function Nc3(a) {
    var b = null;
    a.b && (b = a.b, a.b = b.next, b.next = null);
    a.b || (a.f = null);
    return b;
  }
  k3.gc = function() {
    for (var a; a = Nc3(this); )
      Oc3(this, a, this.a, this.i);
    this.h = false;
  };
  function Oc3(a, b, c, d) {
    if (c == Cc3 && b.b && !b.c)
      for (; a && a.g; a = a.c)
        a.g = false;
    if (b.a)
      b.a.c = null, Sc3(b, c, d);
    else
      try {
        b.c ? b.g.call(b.f) : Sc3(b, c, d);
      } catch (e) {
        Tc3.call(null, e);
      }
    Ia3(Ec3, b);
  }
  function Sc3(a, b, c) {
    b == Ac3 ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
  }
  function Qc2(a, b) {
    a.g = true;
    tc2(function() {
      a.g && Tc3.call(null, b);
    });
  }
  var Tc3 = qc3;
  function Bc3(a) {
    u.call(this, a);
  }
  r2(Bc3, u);
  Bc3.prototype.name = "cancel";
  function Uc3() {
    0 != Vc3 && (Wc2[pa3(this)] = this);
    this.xa = this.xa;
    this.pa = this.pa;
  }
  var Vc3 = 0, Wc2 = {};
  Uc3.prototype.xa = false;
  function Xc2(a) {
    if (!a.xa && (a.xa = true, a.Da(), 0 != Vc3)) {
      var b = pa3(a);
      if (0 != Vc3 && a.pa && 0 < a.pa.length)
        throw Error(a + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");
      delete Wc2[b];
    }
  }
  Uc3.prototype.Da = function() {
    if (this.pa)
      for (; this.pa.length; )
        this.pa.shift()();
  };
  var Yc2 = Object.freeze || function(a) {
    return a;
  };
  var Zc2 = !Wb2 || 9 <= Number(ic3), $c2 = Wb2 && !fc3("9"), ad2 = function() {
    if (!l.addEventListener || !Object.defineProperty)
      return false;
    var a = false, b = Object.defineProperty({}, "passive", { get: function() {
      a = true;
    } });
    try {
      l.addEventListener("test", la2, b), l.removeEventListener("test", la2, b);
    } catch (c) {
    }
    return a;
  }();
  function G3(a, b) {
    this.type = a;
    this.b = this.target = b;
    this.defaultPrevented = false;
  }
  G3.prototype.preventDefault = function() {
    this.defaultPrevented = true;
  };
  function bd2(a, b) {
    G3.call(this, a ? a.type : "");
    this.relatedTarget = this.b = this.target = null;
    this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
    this.key = "";
    this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
    this.pointerId = 0;
    this.pointerType = "";
    this.a = null;
    if (a) {
      var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
      this.target = a.target || a.srcElement;
      this.b = b;
      if (b = a.relatedTarget) {
        if (Zb2) {
          a: {
            try {
              Sb2(b.nodeName);
              var e = true;
              break a;
            } catch (f) {
            }
            e = false;
          }
          e || (b = null);
        }
      } else
        "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);
      this.relatedTarget = b;
      d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
      this.button = a.button;
      this.key = a.key || "";
      this.ctrlKey = a.ctrlKey;
      this.altKey = a.altKey;
      this.shiftKey = a.shiftKey;
      this.metaKey = a.metaKey;
      this.pointerId = a.pointerId || 0;
      this.pointerType = "string" === typeof a.pointerType ? a.pointerType : cd2[a.pointerType] || "";
      this.a = a;
      a.defaultPrevented && this.preventDefault();
    }
  }
  r2(bd2, G3);
  var cd2 = Yc2({ 2: "touch", 3: "pen", 4: "mouse" });
  bd2.prototype.preventDefault = function() {
    bd2.ab.preventDefault.call(this);
    var a = this.a;
    if (a.preventDefault)
      a.preventDefault();
    else if (a.returnValue = false, $c2)
      try {
        if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
          a.keyCode = -1;
      } catch (b) {
      }
  };
  bd2.prototype.g = function() {
    return this.a;
  };
  var dd2 = "closure_listenable_" + (1e6 * Math.random() | 0), ed2 = 0;
  function fd2(a, b, c, d, e) {
    this.listener = a;
    this.proxy = null;
    this.src = b;
    this.type = c;
    this.capture = !!d;
    this.Va = e;
    this.key = ++ed2;
    this.va = this.Pa = false;
  }
  function gd2(a) {
    a.va = true;
    a.listener = null;
    a.proxy = null;
    a.src = null;
    a.Va = null;
  }
  ;
  function hd2(a) {
    this.src = a;
    this.a = {};
    this.b = 0;
  }
  hd2.prototype.add = function(a, b, c, d, e) {
    var f = a.toString();
    a = this.a[f];
    a || (a = this.a[f] = [], this.b++);
    var g = id2(a, b, d, e);
    -1 < g ? (b = a[g], c || (b.Pa = false)) : (b = new fd2(b, this.src, f, !!d, e), b.Pa = c, a.push(b));
    return b;
  };
  function jd2(a, b) {
    var c = b.type;
    c in a.a && Wa3(a.a[c], b) && (gd2(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }
  function id2(a, b, c, d) {
    for (var e = 0; e < a.length; ++e) {
      var f = a[e];
      if (!f.va && f.listener == b && f.capture == !!c && f.Va == d)
        return e;
    }
    return -1;
  }
  ;
  var kd2 = "closure_lm_" + (1e6 * Math.random() | 0), ld2 = {}, md2 = 0;
  function nd2(a, b, c, d, e) {
    if (d && d.once)
      od2(a, b, c, d, e);
    else if (Array.isArray(b))
      for (var f = 0; f < b.length; f++)
        nd2(a, b[f], c, d, e);
    else
      c = pd2(c), a && a[dd2] ? qd2(a, b, c, n2(d) ? !!d.capture : !!d, e) : rd2(a, b, c, false, d, e);
  }
  function rd2(a, b, c, d, e, f) {
    if (!b)
      throw Error("Invalid event type");
    var g = n2(e) ? !!e.capture : !!e, h2 = sd2(a);
    h2 || (a[kd2] = h2 = new hd2(a));
    c = h2.add(b, c, d, g, f);
    if (!c.proxy) {
      d = td2();
      c.proxy = d;
      d.src = a;
      d.listener = c;
      if (a.addEventListener)
        ad2 || (e = g), void 0 === e && (e = false), a.addEventListener(b.toString(), d, e);
      else if (a.attachEvent)
        a.attachEvent(ud2(b.toString()), d);
      else if (a.addListener && a.removeListener)
        a.addListener(d);
      else
        throw Error("addEventListener and attachEvent are unavailable.");
      md2++;
    }
  }
  function td2() {
    var a = vd2, b = Zc2 ? function(c) {
      return a.call(b.src, b.listener, c);
    } : function(c) {
      c = a.call(b.src, b.listener, c);
      if (!c)
        return c;
    };
    return b;
  }
  function od2(a, b, c, d, e) {
    if (Array.isArray(b))
      for (var f = 0; f < b.length; f++)
        od2(a, b[f], c, d, e);
    else
      c = pd2(c), a && a[dd2] ? wd2(a, b, c, n2(d) ? !!d.capture : !!d, e) : rd2(a, b, c, true, d, e);
  }
  function xd2(a, b, c, d, e) {
    if (Array.isArray(b))
      for (var f = 0; f < b.length; f++)
        xd2(a, b[f], c, d, e);
    else
      (d = n2(d) ? !!d.capture : !!d, c = pd2(c), a && a[dd2]) ? (a = a.v, b = String(b).toString(), b in a.a && (f = a.a[b], c = id2(f, c, d, e), -1 < c && (gd2(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], a.b--)))) : a && (a = sd2(a)) && (b = a.a[b.toString()], a = -1, b && (a = id2(b, c, d, e)), (c = -1 < a ? b[a] : null) && yd2(c));
  }
  function yd2(a) {
    if ("number" !== typeof a && a && !a.va) {
      var b = a.src;
      if (b && b[dd2])
        jd2(b.v, a);
      else {
        var c = a.type, d = a.proxy;
        b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(ud2(c), d) : b.addListener && b.removeListener && b.removeListener(d);
        md2--;
        (c = sd2(b)) ? (jd2(c, a), 0 == c.b && (c.src = null, b[kd2] = null)) : gd2(a);
      }
    }
  }
  function ud2(a) {
    return a in ld2 ? ld2[a] : ld2[a] = "on" + a;
  }
  function zd2(a, b, c, d) {
    var e = true;
    if (a = sd2(a)) {
      if (b = a.a[b.toString()])
        for (b = b.concat(), a = 0; a < b.length; a++) {
          var f = b[a];
          f && f.capture == c && !f.va && (f = Bd2(f, d), e = e && false !== f);
        }
    }
    return e;
  }
  function Bd2(a, b) {
    var c = a.listener, d = a.Va || a.src;
    a.Pa && yd2(a);
    return c.call(d, b);
  }
  function vd2(a, b) {
    if (a.va)
      return true;
    if (!Zc2) {
      if (!b)
        a: {
          b = ["window", "event"];
          for (var c = l, d = 0; d < b.length; d++)
            if (c = c[b[d]], null == c) {
              b = null;
              break a;
            }
          b = c;
        }
      d = b;
      b = new bd2(d, this);
      c = true;
      if (!(0 > d.keyCode || void 0 != d.returnValue)) {
        a: {
          var e = false;
          if (0 == d.keyCode)
            try {
              d.keyCode = -1;
              break a;
            } catch (g) {
              e = true;
            }
          if (e || void 0 == d.returnValue)
            d.returnValue = true;
        }
        d = [];
        for (e = b.b; e; e = e.parentNode)
          d.push(e);
        a = a.type;
        for (e = d.length - 1; 0 <= e; e--) {
          b.b = d[e];
          var f = zd2(d[e], a, true, b);
          c = c && f;
        }
        for (e = 0; e < d.length; e++)
          b.b = d[e], f = zd2(d[e], a, false, b), c = c && f;
      }
      return c;
    }
    return Bd2(
      a,
      new bd2(b, this)
    );
  }
  function sd2(a) {
    a = a[kd2];
    return a instanceof hd2 ? a : null;
  }
  var Cd2 = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function pd2(a) {
    if (oa3(a))
      return a;
    a[Cd2] || (a[Cd2] = function(b) {
      return a.handleEvent(b);
    });
    return a[Cd2];
  }
  ;
  function H3() {
    Uc3.call(this);
    this.v = new hd2(this);
    this.ac = this;
    this.gb = null;
  }
  r2(H3, Uc3);
  H3.prototype[dd2] = true;
  H3.prototype.addEventListener = function(a, b, c, d) {
    nd2(this, a, b, c, d);
  };
  H3.prototype.removeEventListener = function(a, b, c, d) {
    xd2(this, a, b, c, d);
  };
  H3.prototype.dispatchEvent = function(a) {
    var b, c = this.gb;
    if (c)
      for (b = []; c; c = c.gb)
        b.push(c);
    c = this.ac;
    var d = a.type || a;
    if ("string" === typeof a)
      a = new G3(a, c);
    else if (a instanceof G3)
      a.target = a.target || c;
    else {
      var e = a;
      a = new G3(d, c);
      z3(a, e);
    }
    e = true;
    if (b)
      for (var f = b.length - 1; 0 <= f; f--) {
        var g = a.b = b[f];
        e = Dd2(g, d, true, a) && e;
      }
    g = a.b = c;
    e = Dd2(g, d, true, a) && e;
    e = Dd2(g, d, false, a) && e;
    if (b)
      for (f = 0; f < b.length; f++)
        g = a.b = b[f], e = Dd2(g, d, false, a) && e;
    return e;
  };
  H3.prototype.Da = function() {
    H3.ab.Da.call(this);
    if (this.v) {
      var a = this.v, b = 0, c;
      for (c in a.a) {
        for (var d = a.a[c], e = 0; e < d.length; e++)
          ++b, gd2(d[e]);
        delete a.a[c];
        a.b--;
      }
    }
    this.gb = null;
  };
  function qd2(a, b, c, d, e) {
    a.v.add(String(b), c, false, d, e);
  }
  function wd2(a, b, c, d, e) {
    a.v.add(String(b), c, true, d, e);
  }
  function Dd2(a, b, c, d) {
    b = a.v.a[String(b)];
    if (!b)
      return true;
    b = b.concat();
    for (var e = true, f = 0; f < b.length; ++f) {
      var g = b[f];
      if (g && !g.va && g.capture == c) {
        var h2 = g.listener, m = g.Va || g.src;
        g.Pa && jd2(a.v, g);
        e = false !== h2.call(m, d) && e;
      }
    }
    return e && !d.defaultPrevented;
  }
  ;
  function Ed2(a, b, c) {
    if (oa3(a))
      c && (a = q3(a, c));
    else if (a && "function" == typeof a.handleEvent)
      a = q3(a.handleEvent, a);
    else
      throw Error("Invalid listener argument");
    return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
  }
  function Fd2(a) {
    var b = null;
    return new D3(function(c, d) {
      b = Ed2(function() {
        c(void 0);
      }, a);
      -1 == b && d(Error("Failed to schedule timer."));
    }).o(function(c) {
      l.clearTimeout(b);
      throw c;
    });
  }
  ;
  function Gd2(a) {
    if (a.W && "function" == typeof a.W)
      return a.W();
    if ("string" === typeof a)
      return a.split("");
    if (na3(a)) {
      for (var b = [], c = a.length, d = 0; d < c; d++)
        b.push(a[d]);
      return b;
    }
    b = [];
    c = 0;
    for (d in a)
      b[c++] = a[d];
    return b;
  }
  function Hd2(a) {
    if (a.Y && "function" == typeof a.Y)
      return a.Y();
    if (!a.W || "function" != typeof a.W) {
      if (na3(a) || "string" === typeof a) {
        var b = [];
        a = a.length;
        for (var c = 0; c < a; c++)
          b.push(c);
        return b;
      }
      b = [];
      c = 0;
      for (var d in a)
        b[c++] = d;
      return b;
    }
  }
  function Id2(a, b) {
    if (a.forEach && "function" == typeof a.forEach)
      a.forEach(b, void 0);
    else if (na3(a) || "string" === typeof a)
      w2(a, b, void 0);
    else
      for (var c = Hd2(a), d = Gd2(a), e = d.length, f = 0; f < e; f++)
        b.call(void 0, d[f], c && c[f], a);
  }
  ;
  function Jd2(a, b) {
    this.b = {};
    this.a = [];
    this.c = 0;
    var c = arguments.length;
    if (1 < c) {
      if (c % 2)
        throw Error("Uneven number of arguments");
      for (var d = 0; d < c; d += 2)
        this.set(arguments[d], arguments[d + 1]);
    } else if (a)
      if (a instanceof Jd2)
        for (c = a.Y(), d = 0; d < c.length; d++)
          this.set(c[d], a.get(c[d]));
      else
        for (d in a)
          this.set(d, a[d]);
  }
  k3 = Jd2.prototype;
  k3.W = function() {
    Kd2(this);
    for (var a = [], b = 0; b < this.a.length; b++)
      a.push(this.b[this.a[b]]);
    return a;
  };
  k3.Y = function() {
    Kd2(this);
    return this.a.concat();
  };
  k3.clear = function() {
    this.b = {};
    this.c = this.a.length = 0;
  };
  function Kd2(a) {
    if (a.c != a.a.length) {
      for (var b = 0, c = 0; b < a.a.length; ) {
        var d = a.a[b];
        Ld2(a.b, d) && (a.a[c++] = d);
        b++;
      }
      a.a.length = c;
    }
    if (a.c != a.a.length) {
      var e = {};
      for (c = b = 0; b < a.a.length; )
        d = a.a[b], Ld2(e, d) || (a.a[c++] = d, e[d] = 1), b++;
      a.a.length = c;
    }
  }
  k3.get = function(a, b) {
    return Ld2(this.b, a) ? this.b[a] : b;
  };
  k3.set = function(a, b) {
    Ld2(this.b, a) || (this.c++, this.a.push(a));
    this.b[a] = b;
  };
  k3.forEach = function(a, b) {
    for (var c = this.Y(), d = 0; d < c.length; d++) {
      var e = c[d], f = this.get(e);
      a.call(b, f, e, this);
    }
  };
  function Ld2(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  ;
  var Md2 = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
  function Nd2(a, b) {
    if (a) {
      a = a.split("&");
      for (var c = 0; c < a.length; c++) {
        var d = a[c].indexOf("="), e = null;
        if (0 <= d) {
          var f = a[c].substring(0, d);
          e = a[c].substring(d + 1);
        } else
          f = a[c];
        b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
      }
    }
  }
  ;
  function Od2(a, b) {
    this.a = this.l = this.c = "";
    this.g = null;
    this.h = this.f = "";
    this.i = false;
    var c;
    a instanceof Od2 ? (this.i = void 0 !== b ? b : a.i, Pd2(this, a.c), this.l = a.l, this.a = a.a, Qd2(this, a.g), this.f = a.f, Rd(this, Sd(a.b)), this.h = a.h) : a && (c = String(a).match(Md2)) ? (this.i = !!b, Pd2(this, c[1] || "", true), this.l = Td(c[2] || ""), this.a = Td(c[3] || "", true), Qd2(this, c[4]), this.f = Td(c[5] || "", true), Rd(this, c[6] || "", true), this.h = Td(c[7] || "")) : (this.i = !!b, this.b = new Ud(null, this.i));
  }
  Od2.prototype.toString = function() {
    var a = [], b = this.c;
    b && a.push(Vd(b, Wd, true), ":");
    var c = this.a;
    if (c || "file" == b)
      a.push("//"), (b = this.l) && a.push(Vd(b, Wd, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.g, null != c && a.push(":", String(c));
    if (c = this.f)
      this.a && "/" != c.charAt(0) && a.push("/"), a.push(Vd(c, "/" == c.charAt(0) ? Xd : Yd, true));
    (c = this.b.toString()) && a.push("?", c);
    (c = this.h) && a.push("#", Vd(c, Zd));
    return a.join("");
  };
  Od2.prototype.resolve = function(a) {
    var b = new Od2(this), c = !!a.c;
    c ? Pd2(b, a.c) : c = !!a.l;
    c ? b.l = a.l : c = !!a.a;
    c ? b.a = a.a : c = null != a.g;
    var d = a.f;
    if (c)
      Qd2(b, a.g);
    else if (c = !!a.f) {
      if ("/" != d.charAt(0))
        if (this.a && !this.f)
          d = "/" + d;
        else {
          var e = b.f.lastIndexOf("/");
          -1 != e && (d = b.f.substr(0, e + 1) + d);
        }
      e = d;
      if (".." == e || "." == e)
        d = "";
      else if (x3(e, "./") || x3(e, "/.")) {
        d = 0 == e.lastIndexOf("/", 0);
        e = e.split("/");
        for (var f = [], g = 0; g < e.length; ) {
          var h2 = e[g++];
          "." == h2 ? d && g == e.length && f.push("") : ".." == h2 ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), d && g == e.length && f.push("")) : (f.push(h2), d = true);
        }
        d = f.join("/");
      } else
        d = e;
    }
    c ? b.f = d : c = "" !== a.b.toString();
    c ? Rd(b, Sd(a.b)) : c = !!a.h;
    c && (b.h = a.h);
    return b;
  };
  function Pd2(a, b, c) {
    a.c = c ? Td(b, true) : b;
    a.c && (a.c = a.c.replace(/:$/, ""));
  }
  function Qd2(a, b) {
    if (b) {
      b = Number(b);
      if (isNaN(b) || 0 > b)
        throw Error("Bad port number " + b);
      a.g = b;
    } else
      a.g = null;
  }
  function Rd(a, b, c) {
    b instanceof Ud ? (a.b = b, $d(a.b, a.i)) : (c || (b = Vd(b, ae2)), a.b = new Ud(b, a.i));
  }
  function I3(a, b, c) {
    a.b.set(b, c);
  }
  function be2(a, b) {
    return a.b.get(b);
  }
  function J3(a) {
    return a instanceof Od2 ? new Od2(a) : new Od2(a, void 0);
  }
  function ce2(a, b, c, d) {
    var e = new Od2(null, void 0);
    a && Pd2(e, a);
    b && (e.a = b);
    c && Qd2(e, c);
    d && (e.f = d);
    return e;
  }
  function Td(a, b) {
    return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
  }
  function Vd(a, b, c) {
    return "string" === typeof a ? (a = encodeURI(a).replace(b, de2), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
  }
  function de2(a) {
    a = a.charCodeAt(0);
    return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
  }
  var Wd = /[#\/\?@]/g, Yd = /[#\?:]/g, Xd = /[#\?]/g, ae2 = /[#\?@]/g, Zd = /#/g;
  function Ud(a, b) {
    this.b = this.a = null;
    this.c = a || null;
    this.f = !!b;
  }
  function ee2(a) {
    a.a || (a.a = new Jd2(), a.b = 0, a.c && Nd2(a.c, function(b, c) {
      a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
    }));
  }
  function fe2(a) {
    var b = Hd2(a);
    if ("undefined" == typeof b)
      throw Error("Keys are undefined");
    var c = new Ud(null, void 0);
    a = Gd2(a);
    for (var d = 0; d < b.length; d++) {
      var e = b[d], f = a[d];
      Array.isArray(f) ? ge2(c, e, f) : c.add(e, f);
    }
    return c;
  }
  k3 = Ud.prototype;
  k3.add = function(a, b) {
    ee2(this);
    this.c = null;
    a = he2(this, a);
    var c = this.a.get(a);
    c || this.a.set(a, c = []);
    c.push(b);
    this.b += 1;
    return this;
  };
  function ie2(a, b) {
    ee2(a);
    b = he2(a, b);
    Ld2(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, a = a.a, Ld2(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && Kd2(a)));
  }
  k3.clear = function() {
    this.a = this.c = null;
    this.b = 0;
  };
  function je2(a, b) {
    ee2(a);
    b = he2(a, b);
    return Ld2(a.a.b, b);
  }
  k3.forEach = function(a, b) {
    ee2(this);
    this.a.forEach(function(c, d) {
      w2(c, function(e) {
        a.call(b, e, d, this);
      }, this);
    }, this);
  };
  k3.Y = function() {
    ee2(this);
    for (var a = this.a.W(), b = this.a.Y(), c = [], d = 0; d < b.length; d++)
      for (var e = a[d], f = 0; f < e.length; f++)
        c.push(b[d]);
    return c;
  };
  k3.W = function(a) {
    ee2(this);
    var b = [];
    if ("string" === typeof a)
      je2(this, a) && (b = Ya3(b, this.a.get(he2(this, a))));
    else {
      a = this.a.W();
      for (var c = 0; c < a.length; c++)
        b = Ya3(b, a[c]);
    }
    return b;
  };
  k3.set = function(a, b) {
    ee2(this);
    this.c = null;
    a = he2(this, a);
    je2(this, a) && (this.b -= this.a.get(a).length);
    this.a.set(a, [b]);
    this.b += 1;
    return this;
  };
  k3.get = function(a, b) {
    if (!a)
      return b;
    a = this.W(a);
    return 0 < a.length ? String(a[0]) : b;
  };
  function ge2(a, b, c) {
    ie2(a, b);
    0 < c.length && (a.c = null, a.a.set(he2(a, b), Za3(c)), a.b += c.length);
  }
  k3.toString = function() {
    if (this.c)
      return this.c;
    if (!this.a)
      return "";
    for (var a = [], b = this.a.Y(), c = 0; c < b.length; c++) {
      var d = b[c], e = encodeURIComponent(String(d));
      d = this.W(d);
      for (var f = 0; f < d.length; f++) {
        var g = e;
        "" !== d[f] && (g += "=" + encodeURIComponent(String(d[f])));
        a.push(g);
      }
    }
    return this.c = a.join("&");
  };
  function Sd(a) {
    var b = new Ud();
    b.c = a.c;
    a.a && (b.a = new Jd2(a.a), b.b = a.b);
    return b;
  }
  function he2(a, b) {
    b = String(b);
    a.f && (b = b.toLowerCase());
    return b;
  }
  function $d(a, b) {
    b && !a.f && (ee2(a), a.c = null, a.a.forEach(function(c, d) {
      var e = d.toLowerCase();
      d != e && (ie2(this, d), ge2(this, e, c));
    }, a));
    a.f = b;
  }
  ;
  function ke2(a) {
    var b = [];
    le2(new me2(), a, b);
    return b.join("");
  }
  function me2() {
  }
  function le2(a, b, c) {
    if (null == b)
      c.push("null");
    else {
      if ("object" == typeof b) {
        if (Array.isArray(b)) {
          var d = b;
          b = d.length;
          c.push("[");
          for (var e = "", f = 0; f < b; f++)
            c.push(e), le2(a, d[f], c), e = ",";
          c.push("]");
          return;
        }
        if (b instanceof String || b instanceof Number || b instanceof Boolean)
          b = b.valueOf();
        else {
          c.push("{");
          e = "";
          for (d in b)
            Object.prototype.hasOwnProperty.call(b, d) && (f = b[d], "function" != typeof f && (c.push(e), ne2(d, c), c.push(":"), le2(a, f, c), e = ","));
          c.push("}");
          return;
        }
      }
      switch (typeof b) {
        case "string":
          ne2(b, c);
          break;
        case "number":
          c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");
          break;
        case "boolean":
          c.push(String(b));
          break;
        case "function":
          c.push("null");
          break;
        default:
          throw Error("Unknown type: " + typeof b);
      }
    }
  }
  var oe2 = { '"': '\\"', "\\": "\\\\", "/": "\\/", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\u000b" }, pe2 = /\uffff/.test("") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
  function ne2(a, b) {
    b.push('"', a.replace(pe2, function(c) {
      var d = oe2[c];
      d || (d = "\\u" + (c.charCodeAt(0) | 65536).toString(16).substr(1), oe2[c] = d);
      return d;
    }), '"');
  }
  ;
  function qe2() {
    var a = K3();
    return Wb2 && !!ic3 && 11 == ic3 || /Edge\/\d+/.test(a);
  }
  function re2() {
    return l.window && l.window.location.href || self && self.location && self.location.href || "";
  }
  function se2(a, b) {
    b = b || l.window;
    var c = "about:blank";
    a && (c = Eb2(Ib2(a) || Kb2));
    b.location.href = c;
  }
  function te2(a, b) {
    var c = [], d;
    for (d in a)
      d in b ? typeof a[d] != typeof b[d] ? c.push(d) : "object" == typeof a[d] && null != a[d] && null != b[d] ? 0 < te2(a[d], b[d]).length && c.push(d) : a[d] !== b[d] && c.push(d) : c.push(d);
    for (d in b)
      d in a || c.push(d);
    return c;
  }
  function ue2() {
    var a = K3();
    a = ve2(a) != we2 ? null : (a = a.match(/\sChrome\/(\d+)/i)) && 2 == a.length ? parseInt(a[1], 10) : null;
    return a && 30 > a ? false : !Wb2 || !ic3 || 9 < ic3;
  }
  function xe2(a) {
    a = (a || K3()).toLowerCase();
    return a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/) ? true : false;
  }
  function ye2(a) {
    a = a || l.window;
    try {
      a.close();
    } catch (b) {
    }
  }
  function ze2(a, b, c) {
    var d = Math.floor(1e9 * Math.random()).toString();
    b = b || 500;
    c = c || 600;
    var e = (window.screen.availHeight - c) / 2, f = (window.screen.availWidth - b) / 2;
    b = { width: b, height: c, top: 0 < e ? e : 0, left: 0 < f ? f : 0, location: true, resizable: true, statusbar: true, toolbar: false };
    c = K3().toLowerCase();
    d && (b.target = d, x3(c, "crios/") && (b.target = "_blank"));
    ve2(K3()) == Ae2 && (a = a || "http://localhost", b.scrollbars = true);
    c = a || "";
    (a = b) || (a = {});
    d = window;
    b = c instanceof C2 ? c : Ib2("undefined" != typeof c.href ? c.href : String(c)) || Kb2;
    c = a.target || c.target;
    e = [];
    for (g in a)
      switch (g) {
        case "width":
        case "height":
        case "top":
        case "left":
          e.push(g + "=" + a[g]);
          break;
        case "target":
        case "noopener":
        case "noreferrer":
          break;
        default:
          e.push(g + "=" + (a[g] ? 1 : 0));
      }
    var g = e.join(",");
    if ((y2("iPhone") && !y2("iPod") && !y2("iPad") || y2("iPad") || y2("iPod")) && d.navigator && d.navigator.standalone && c && "_self" != c)
      g = oc3(document, "A"), pb2(g, "HTMLAnchorElement"), b = b instanceof C2 ? b : Jb2(b), g.href = Eb2(b), g.setAttribute("target", c), a.noreferrer && g.setAttribute("rel", "noreferrer"), a = document.createEvent("MouseEvent"), a.initMouseEvent("click", true, true, d, 1), g.dispatchEvent(a), g = {};
    else if (a.noreferrer) {
      if (g = Pb2("", d, c, g), a = Eb2(b), g && (Yb2 && x3(a, ";") && (a = "'" + a.replace(/'/g, "%27") + "'"), g.opener = null, a = '<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + Rb2(a) + '">', a = (d = vb2()) ? d.createHTML(a) : a, a = new Lb2(a, null, Mb2), d = g.document))
        d.write(Nb2(a)), d.close();
    } else
      (g = Pb2(b, d, c, g)) && a.noopener && (g.opener = null);
    if (g)
      try {
        g.focus();
      } catch (h2) {
      }
    return g;
  }
  function Be2(a) {
    return new D3(function(b) {
      function c() {
        Fd2(2e3).then(function() {
          if (!a || a.closed)
            b();
          else
            return c();
        });
      }
      return c();
    });
  }
  var Ce2 = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, De2 = /^[^@]+@[^@]+$/;
  function Ee2() {
    var a = null;
    return new D3(function(b) {
      "complete" == l.document.readyState ? b() : (a = function() {
        b();
      }, od2(window, "load", a));
    }).o(function(b) {
      xd2(window, "load", a);
      throw b;
    });
  }
  function Fe2() {
    return Ge2(void 0) ? Ee2().then(function() {
      return new D3(function(a, b) {
        var c = l.document, d = setTimeout(function() {
          b(Error("Cordova framework is not ready."));
        }, 1e3);
        c.addEventListener("deviceready", function() {
          clearTimeout(d);
          a();
        }, false);
      });
    }) : F3(Error("Cordova must run in an Android or iOS file scheme."));
  }
  function Ge2(a) {
    a = a || K3();
    return !("file:" !== He2() && "ionic:" !== He2() || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
  }
  function Ie2() {
    var a = l.window;
    try {
      return !(!a || a == a.top);
    } catch (b) {
      return false;
    }
  }
  function Je2() {
    return "undefined" !== typeof l.WorkerGlobalScope && "function" === typeof l.importScripts;
  }
  function Ke2() {
    return index_esm_default.INTERNAL.hasOwnProperty("reactNative") ? "ReactNative" : index_esm_default.INTERNAL.hasOwnProperty("node") ? "Node" : Je2() ? "Worker" : "Browser";
  }
  function Le2() {
    var a = Ke2();
    return "ReactNative" === a || "Node" === a;
  }
  function Me2() {
    for (var a = 50, b = []; 0 < a; )
      b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
    return b.join("");
  }
  var Ae2 = "Firefox", we2 = "Chrome";
  function ve2(a) {
    var b = a.toLowerCase();
    if (x3(b, "opera/") || x3(b, "opr/") || x3(b, "opios/"))
      return "Opera";
    if (x3(b, "iemobile"))
      return "IEMobile";
    if (x3(b, "msie") || x3(b, "trident/"))
      return "IE";
    if (x3(b, "edge/"))
      return "Edge";
    if (x3(b, "firefox/"))
      return Ae2;
    if (x3(b, "silk/"))
      return "Silk";
    if (x3(b, "blackberry"))
      return "Blackberry";
    if (x3(b, "webos"))
      return "Webos";
    if (!x3(b, "safari/") || x3(b, "chrome/") || x3(b, "crios/") || x3(b, "android"))
      if (!x3(b, "chrome/") && !x3(b, "crios/") || x3(b, "edge/")) {
        if (x3(b, "android"))
          return "Android";
        if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && 2 == a.length)
          return a[1];
      } else
        return we2;
    else
      return "Safari";
    return "Other";
  }
  var Ne2 = { md: "FirebaseCore-web", od: "FirebaseUI-web" };
  function Oe2(a, b) {
    b = b || [];
    var c = [], d = {}, e;
    for (e in Ne2)
      d[Ne2[e]] = true;
    for (e = 0; e < b.length; e++)
      "undefined" !== typeof d[b[e]] && (delete d[b[e]], c.push(b[e]));
    c.sort();
    b = c;
    b.length || (b = ["FirebaseCore-web"]);
    c = Ke2();
    "Browser" === c ? (d = K3(), c = ve2(d)) : "Worker" === c && (d = K3(), c = ve2(d) + "-" + c);
    return c + "/JsCore/" + a + "/" + b.join(",");
  }
  function K3() {
    return l.navigator && l.navigator.userAgent || "";
  }
  function L4(a, b) {
    a = a.split(".");
    b = b || l;
    for (var c = 0; c < a.length && "object" == typeof b && null != b; c++)
      b = b[a[c]];
    c != a.length && (b = void 0);
    return b;
  }
  function Pe2() {
    try {
      var a = l.localStorage, b = Qe2();
      if (a)
        return a.setItem(b, "1"), a.removeItem(b), qe2() ? !!l.indexedDB : true;
    } catch (c) {
      return Je2() && !!l.indexedDB;
    }
    return false;
  }
  function Re2() {
    return (Se2() || "chrome-extension:" === He2() || Ge2()) && !Le2() && Pe2() && !Je2();
  }
  function Se2() {
    return "http:" === He2() || "https:" === He2();
  }
  function He2() {
    return l.location && l.location.protocol || null;
  }
  function Te2(a) {
    a = a || K3();
    return xe2(a) || ve2(a) == Ae2 ? false : true;
  }
  function Ue2(a) {
    return "undefined" === typeof a ? null : ke2(a);
  }
  function Ve2(a) {
    var b = {}, c;
    for (c in a)
      a.hasOwnProperty(c) && null !== a[c] && void 0 !== a[c] && (b[c] = a[c]);
    return b;
  }
  function We2(a) {
    if (null !== a)
      return JSON.parse(a);
  }
  function Qe2(a) {
    return a ? a : Math.floor(1e9 * Math.random()).toString();
  }
  function Xe2(a) {
    a = a || K3();
    return "Safari" == ve2(a) || a.toLowerCase().match(/iphone|ipad|ipod/) ? false : true;
  }
  function Ye2() {
    var a = l.___jsl;
    if (a && a.H) {
      for (var b in a.H)
        if (a.H[b].r = a.H[b].r || [], a.H[b].L = a.H[b].L || [], a.H[b].r = a.H[b].L.concat(), a.CP)
          for (var c = 0; c < a.CP.length; c++)
            a.CP[c] = null;
    }
  }
  function Ze2(a, b) {
    if (a > b)
      throw Error("Short delay should be less than long delay!");
    this.a = a;
    this.c = b;
    a = K3();
    b = Ke2();
    this.b = xe2(a) || "ReactNative" === b;
  }
  Ze2.prototype.get = function() {
    var a = l.navigator;
    return (a && "boolean" === typeof a.onLine && (Se2() || "chrome-extension:" === He2() || "undefined" !== typeof a.connection) ? a.onLine : 1) ? this.b ? this.c : this.a : Math.min(5e3, this.a);
  };
  function $e2() {
    var a = l.document;
    return a && "undefined" !== typeof a.visibilityState ? "visible" == a.visibilityState : true;
  }
  function af() {
    var a = l.document, b = null;
    return $e2() || !a ? E3() : new D3(function(c) {
      b = function() {
        $e2() && (a.removeEventListener("visibilitychange", b, false), c());
      };
      a.addEventListener("visibilitychange", b, false);
    }).o(function(c) {
      a.removeEventListener("visibilitychange", b, false);
      throw c;
    });
  }
  function bf(a) {
    try {
      var b = new Date(parseInt(a, 10));
      if (!isNaN(b.getTime()) && !/[^0-9]/.test(a))
        return b.toUTCString();
    } catch (c) {
    }
    return null;
  }
  function cf() {
    return !(!L4("fireauth.oauthhelper", l) && !L4("fireauth.iframe", l));
  }
  function df() {
    var a = l.navigator;
    return a && a.serviceWorker && a.serviceWorker.controller || null;
  }
  function ef() {
    var a = l.navigator;
    return a && a.serviceWorker ? E3().then(function() {
      return a.serviceWorker.ready;
    }).then(function(b) {
      return b.active || null;
    }).o(function() {
      return null;
    }) : E3(null);
  }
  ;
  var ff = {};
  function gf(a) {
    ff[a] || (ff[a] = true, "undefined" !== typeof console && "function" === typeof console.warn && console.warn(a));
  }
  ;
  var hf;
  try {
    var jf = {};
    Object.defineProperty(jf, "abcd", { configurable: true, enumerable: true, value: 1 });
    Object.defineProperty(jf, "abcd", { configurable: true, enumerable: true, value: 2 });
    hf = 2 == jf.abcd;
  } catch (a) {
    hf = false;
  }
  function M3(a, b, c) {
    hf ? Object.defineProperty(a, b, { configurable: true, enumerable: true, value: c }) : a[b] = c;
  }
  function N3(a, b) {
    if (b)
      for (var c in b)
        b.hasOwnProperty(c) && M3(a, c, b[c]);
  }
  function kf(a) {
    var b = {};
    N3(b, a);
    return b;
  }
  function lf(a) {
    var b = {}, c;
    for (c in a)
      a.hasOwnProperty(c) && (b[c] = a[c]);
    return b;
  }
  function mf(a, b) {
    if (!b || !b.length)
      return true;
    if (!a)
      return false;
    for (var c = 0; c < b.length; c++) {
      var d = a[b[c]];
      if (void 0 === d || null === d || "" === d)
        return false;
    }
    return true;
  }
  function nf(a) {
    var b = a;
    if ("object" == typeof a && null != a) {
      b = "length" in a ? [] : {};
      for (var c in a)
        M3(b, c, nf(a[c]));
    }
    return b;
  }
  ;
  function of(a) {
    var b = a && (a[pf] ? "phone" : null);
    if (b && a && a[qf]) {
      M3(this, "uid", a[qf]);
      M3(this, "displayName", a[rf] || null);
      var c = null;
      a[sf] && (c = new Date(a[sf]).toUTCString());
      M3(this, "enrollmentTime", c);
      M3(this, "factorId", b);
    } else
      throw new t3("internal-error", "Internal assert: invalid MultiFactorInfo object");
  }
  of.prototype.w = function() {
    return { uid: this.uid, displayName: this.displayName, factorId: this.factorId, enrollmentTime: this.enrollmentTime };
  };
  function tf(a) {
    try {
      var b = new uf(a);
    } catch (c) {
      b = null;
    }
    return b;
  }
  var rf = "displayName", sf = "enrolledAt", qf = "mfaEnrollmentId", pf = "phoneInfo";
  function uf(a) {
    of.call(this, a);
    M3(this, "phoneNumber", a[pf]);
  }
  r2(uf, of);
  uf.prototype.w = function() {
    var a = uf.ab.w.call(this);
    a.phoneNumber = this.phoneNumber;
    return a;
  };
  function vf(a) {
    var b = {}, c = a[wf], d = a[xf], e = a[yf];
    a = tf(a[zf]);
    if (!e || e != Af && e != Bf && !c || e == Bf && !d || e == Cf && !a)
      throw Error("Invalid checkActionCode response!");
    e == Bf ? (b[Df] = c || null, b[Ef] = c || null, b[Ff] = d) : (b[Df] = d || null, b[Ef] = d || null, b[Ff] = c || null);
    b[Gf] = a || null;
    M3(this, Hf, e);
    M3(this, If, nf(b));
  }
  var Cf = "REVERT_SECOND_FACTOR_ADDITION", Af = "EMAIL_SIGNIN", Bf = "VERIFY_AND_CHANGE_EMAIL", wf = "email", zf = "mfaInfo", xf = "newEmail", yf = "requestType", Ff = "email", Df = "fromEmail", Gf = "multiFactorInfo", Ef = "previousEmail", If = "data", Hf = "operation";
  function Jf(a) {
    a = J3(a);
    var b = be2(a, Kf) || null, c = be2(a, Lf) || null, d = be2(a, Mf) || null;
    d = d ? Nf[d] || null : null;
    if (!b || !c || !d)
      throw new t3("argument-error", Kf + ", " + Lf + "and " + Mf + " are required in a valid action code URL.");
    N3(this, { apiKey: b, operation: d, code: c, continueUrl: be2(a, Of) || null, languageCode: be2(a, Pf) || null, tenantId: be2(a, Qf) || null });
  }
  var Kf = "apiKey", Lf = "oobCode", Of = "continueUrl", Pf = "languageCode", Mf = "mode", Qf = "tenantId", Nf = { recoverEmail: "RECOVER_EMAIL", resetPassword: "PASSWORD_RESET", revertSecondFactorAddition: Cf, signIn: Af, verifyAndChangeEmail: Bf, verifyEmail: "VERIFY_EMAIL" };
  function Rf(a) {
    try {
      return new Jf(a);
    } catch (b) {
      return null;
    }
  }
  ;
  function Sf(a) {
    var b = a[Tf];
    if ("undefined" === typeof b)
      throw new t3("missing-continue-uri");
    if ("string" !== typeof b || "string" === typeof b && !b.length)
      throw new t3("invalid-continue-uri");
    this.h = b;
    this.b = this.a = null;
    this.g = false;
    var c = a[Uf];
    if (c && "object" === typeof c) {
      b = c[Vf];
      var d = c[Wf];
      c = c[Xf];
      if ("string" === typeof b && b.length) {
        this.a = b;
        if ("undefined" !== typeof d && "boolean" !== typeof d)
          throw new t3("argument-error", Wf + " property must be a boolean when specified.");
        this.g = !!d;
        if ("undefined" !== typeof c && ("string" !== typeof c || "string" === typeof c && !c.length))
          throw new t3("argument-error", Xf + " property must be a non empty string when specified.");
        this.b = c || null;
      } else {
        if ("undefined" !== typeof b)
          throw new t3("argument-error", Vf + " property must be a non empty string when specified.");
        if ("undefined" !== typeof d || "undefined" !== typeof c)
          throw new t3("missing-android-pkg-name");
      }
    } else if ("undefined" !== typeof c)
      throw new t3("argument-error", Uf + " property must be a non null object when specified.");
    this.f = null;
    if ((b = a[Yf]) && "object" === typeof b)
      if (b = b[Zf], "string" === typeof b && b.length)
        this.f = b;
      else {
        if ("undefined" !== typeof b)
          throw new t3("argument-error", Zf + " property must be a non empty string when specified.");
      }
    else if ("undefined" !== typeof b)
      throw new t3("argument-error", Yf + " property must be a non null object when specified.");
    b = a[$f];
    if ("undefined" !== typeof b && "boolean" !== typeof b)
      throw new t3("argument-error", $f + " property must be a boolean when specified.");
    this.c = !!b;
    a = a[ag];
    if ("undefined" !== typeof a && ("string" !== typeof a || "string" === typeof a && !a.length))
      throw new t3("argument-error", ag + " property must be a non empty string when specified.");
    this.i = a || null;
  }
  var Uf = "android", ag = "dynamicLinkDomain", $f = "handleCodeInApp", Yf = "iOS", Tf = "url", Wf = "installApp", Xf = "minimumVersion", Vf = "packageName", Zf = "bundleId";
  function bg(a) {
    var b = {};
    b.continueUrl = a.h;
    b.canHandleCodeInApp = a.c;
    if (b.androidPackageName = a.a)
      b.androidMinimumVersion = a.b, b.androidInstallApp = a.g;
    b.iOSBundleId = a.f;
    b.dynamicLinkDomain = a.i;
    for (var c in b)
      null === b[c] && delete b[c];
    return b;
  }
  ;
  function cg(a) {
    return Ra3(a, function(b) {
      b = b.toString(16);
      return 1 < b.length ? b : "0" + b;
    }).join("");
  }
  ;
  var dg = null;
  function eg(a) {
    var b = [];
    fg(a, function(c) {
      b.push(c);
    });
    return b;
  }
  function fg(a, b) {
    function c(m) {
      for (; d < a.length; ) {
        var p2 = a.charAt(d++), v2 = dg[p2];
        if (null != v2)
          return v2;
        if (!/^[\s\xa0]*$/.test(p2))
          throw Error("Unknown base64 encoding at char: " + p2);
      }
      return m;
    }
    gg();
    for (var d = 0; ; ) {
      var e = c(-1), f = c(0), g = c(64), h2 = c(64);
      if (64 === h2 && -1 === e)
        break;
      b(e << 2 | f >> 4);
      64 != g && (b(f << 4 & 240 | g >> 2), 64 != h2 && b(g << 6 & 192 | h2));
    }
  }
  function gg() {
    if (!dg) {
      dg = {};
      for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++)
        for (var d = a.concat(b[c].split("")), e = 0; e < d.length; e++) {
          var f = d[e];
          void 0 === dg[f] && (dg[f] = e);
        }
    }
  }
  ;
  function hg(a) {
    var b = ig(a);
    if (!(b && b.sub && b.iss && b.aud && b.exp))
      throw Error("Invalid JWT");
    this.h = a;
    this.a = b.exp;
    this.i = b.sub;
    a = Date.now() / 1e3;
    this.g = b.iat || (a > this.a ? this.a : a);
    this.b = b.provider_id || b.firebase && b.firebase.sign_in_provider || null;
    this.f = b.firebase && b.firebase.tenant || null;
    this.c = !!b.is_anonymous || "anonymous" == this.b;
  }
  hg.prototype.T = function() {
    return this.f;
  };
  hg.prototype.l = function() {
    return this.c;
  };
  hg.prototype.toString = function() {
    return this.h;
  };
  function jg(a) {
    try {
      return new hg(a);
    } catch (b) {
      return null;
    }
  }
  function ig(a) {
    if (!a)
      return null;
    a = a.split(".");
    if (3 != a.length)
      return null;
    a = a[1];
    for (var b = (4 - a.length % 4) % 4, c = 0; c < b; c++)
      a += ".";
    try {
      var d = eg(a);
      a = [];
      for (c = b = 0; b < d.length; ) {
        var e = d[b++];
        if (128 > e)
          a[c++] = String.fromCharCode(e);
        else if (191 < e && 224 > e) {
          var f = d[b++];
          a[c++] = String.fromCharCode((e & 31) << 6 | f & 63);
        } else if (239 < e && 365 > e) {
          f = d[b++];
          var g = d[b++], h2 = d[b++], m = ((e & 7) << 18 | (f & 63) << 12 | (g & 63) << 6 | h2 & 63) - 65536;
          a[c++] = String.fromCharCode(55296 + (m >> 10));
          a[c++] = String.fromCharCode(56320 + (m & 1023));
        } else
          f = d[b++], g = d[b++], a[c++] = String.fromCharCode((e & 15) << 12 | (f & 63) << 6 | g & 63);
      }
      return JSON.parse(a.join(""));
    } catch (p2) {
    }
    return null;
  }
  ;
  var kg = "oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "), lg = ["client_id", "response_type", "scope", "redirect_uri", "state"], mg = { nd: { Ja: "locale", ua: 700, ta: 600, fa: "facebook.com", Xa: lg }, pd: { Ja: null, ua: 500, ta: 750, fa: "github.com", Xa: lg }, qd: { Ja: "hl", ua: 515, ta: 680, fa: "google.com", Xa: lg }, wd: { Ja: "lang", ua: 485, ta: 705, fa: "twitter.com", Xa: kg }, kd: { Ja: "locale", ua: 640, ta: 600, fa: "apple.com", Xa: [] } };
  function ng(a) {
    for (var b in mg)
      if (mg[b].fa == a)
        return mg[b];
    return null;
  }
  ;
  function og(a) {
    var b = {};
    b["facebook.com"] = pg;
    b["google.com"] = qg;
    b["github.com"] = rg;
    b["twitter.com"] = sg;
    var c = a && a[tg];
    try {
      if (c)
        return b[c] ? new b[c](a) : new ug(a);
      if ("undefined" !== typeof a[vg])
        return new wg(a);
    } catch (d) {
    }
    return null;
  }
  var vg = "idToken", tg = "providerId";
  function wg(a) {
    var b = a[tg];
    if (!b && a[vg]) {
      var c = jg(a[vg]);
      c && c.b && (b = c.b);
    }
    if (!b)
      throw Error("Invalid additional user info!");
    if ("anonymous" == b || "custom" == b)
      b = null;
    c = false;
    "undefined" !== typeof a.isNewUser ? c = !!a.isNewUser : "identitytoolkit#SignupNewUserResponse" === a.kind && (c = true);
    M3(this, "providerId", b);
    M3(this, "isNewUser", c);
  }
  function ug(a) {
    wg.call(this, a);
    a = We2(a.rawUserInfo || "{}");
    M3(this, "profile", nf(a || {}));
  }
  r2(ug, wg);
  function pg(a) {
    ug.call(this, a);
    if ("facebook.com" != this.providerId)
      throw Error("Invalid provider ID!");
  }
  r2(pg, ug);
  function rg(a) {
    ug.call(this, a);
    if ("github.com" != this.providerId)
      throw Error("Invalid provider ID!");
    M3(this, "username", this.profile && this.profile.login || null);
  }
  r2(rg, ug);
  function qg(a) {
    ug.call(this, a);
    if ("google.com" != this.providerId)
      throw Error("Invalid provider ID!");
  }
  r2(qg, ug);
  function sg(a) {
    ug.call(this, a);
    if ("twitter.com" != this.providerId)
      throw Error("Invalid provider ID!");
    M3(this, "username", a.screenName || null);
  }
  r2(sg, ug);
  function xg(a) {
    var b = J3(a), c = be2(b, "link"), d = be2(J3(c), "link");
    b = be2(b, "deep_link_id");
    return be2(J3(b), "link") || b || d || c || a;
  }
  ;
  function yg(a, b) {
    if (!a && !b)
      throw new t3("internal-error", "Internal assert: no raw session string available");
    if (a && b)
      throw new t3("internal-error", "Internal assert: unable to determine the session type");
    this.a = a || null;
    this.b = b || null;
    this.type = this.a ? zg : Ag;
  }
  var zg = "enroll", Ag = "signin";
  yg.prototype.Ha = function() {
    return this.a ? E3(this.a) : E3(this.b);
  };
  yg.prototype.w = function() {
    return this.type == zg ? { multiFactorSession: { idToken: this.a } } : { multiFactorSession: { pendingCredential: this.b } };
  };
  function Bg() {
  }
  Bg.prototype.ka = function() {
  };
  Bg.prototype.b = function() {
  };
  Bg.prototype.c = function() {
  };
  Bg.prototype.w = function() {
  };
  function Cg(a, b) {
    return a.then(function(c) {
      if (c[Dg]) {
        var d = jg(c[Dg]);
        if (!d || b != d.i)
          throw new t3("user-mismatch");
        return c;
      }
      throw new t3("user-mismatch");
    }).o(function(c) {
      throw c && c.code && c.code == xa2 + "user-not-found" ? new t3("user-mismatch") : c;
    });
  }
  function Eg(a, b) {
    if (b)
      this.a = b;
    else
      throw new t3("internal-error", "failed to construct a credential");
    M3(this, "providerId", a);
    M3(this, "signInMethod", a);
  }
  Eg.prototype.ka = function(a) {
    return Fg(a, Gg(this));
  };
  Eg.prototype.b = function(a, b) {
    var c = Gg(this);
    c.idToken = b;
    return Hg(a, c);
  };
  Eg.prototype.c = function(a, b) {
    return Cg(Ig(a, Gg(this)), b);
  };
  function Gg(a) {
    return { pendingToken: a.a, requestUri: "http://localhost" };
  }
  Eg.prototype.w = function() {
    return { providerId: this.providerId, signInMethod: this.signInMethod, pendingToken: this.a };
  };
  function Jg(a) {
    if (a && a.providerId && a.signInMethod && 0 == a.providerId.indexOf("saml.") && a.pendingToken)
      try {
        return new Eg(a.providerId, a.pendingToken);
      } catch (b) {
      }
    return null;
  }
  function Kg(a, b, c) {
    this.a = null;
    if (b.idToken || b.accessToken)
      b.idToken && M3(this, "idToken", b.idToken), b.accessToken && M3(this, "accessToken", b.accessToken), b.nonce && !b.pendingToken && M3(this, "nonce", b.nonce), b.pendingToken && (this.a = b.pendingToken);
    else if (b.oauthToken && b.oauthTokenSecret)
      M3(this, "accessToken", b.oauthToken), M3(this, "secret", b.oauthTokenSecret);
    else
      throw new t3("internal-error", "failed to construct a credential");
    M3(this, "providerId", a);
    M3(this, "signInMethod", c);
  }
  Kg.prototype.ka = function(a) {
    return Fg(a, Lg(this));
  };
  Kg.prototype.b = function(a, b) {
    var c = Lg(this);
    c.idToken = b;
    return Hg(a, c);
  };
  Kg.prototype.c = function(a, b) {
    var c = Lg(this);
    return Cg(Ig(a, c), b);
  };
  function Lg(a) {
    var b = {};
    a.idToken && (b.id_token = a.idToken);
    a.accessToken && (b.access_token = a.accessToken);
    a.secret && (b.oauth_token_secret = a.secret);
    b.providerId = a.providerId;
    a.nonce && !a.a && (b.nonce = a.nonce);
    b = { postBody: fe2(b).toString(), requestUri: "http://localhost" };
    a.a && (delete b.postBody, b.pendingToken = a.a);
    return b;
  }
  Kg.prototype.w = function() {
    var a = { providerId: this.providerId, signInMethod: this.signInMethod };
    this.idToken && (a.oauthIdToken = this.idToken);
    this.accessToken && (a.oauthAccessToken = this.accessToken);
    this.secret && (a.oauthTokenSecret = this.secret);
    this.nonce && (a.nonce = this.nonce);
    this.a && (a.pendingToken = this.a);
    return a;
  };
  function Mg(a) {
    if (a && a.providerId && a.signInMethod) {
      var b = { idToken: a.oauthIdToken, accessToken: a.oauthTokenSecret ? null : a.oauthAccessToken, oauthTokenSecret: a.oauthTokenSecret, oauthToken: a.oauthTokenSecret && a.oauthAccessToken, nonce: a.nonce, pendingToken: a.pendingToken };
      try {
        return new Kg(a.providerId, b, a.signInMethod);
      } catch (c) {
      }
    }
    return null;
  }
  function Ng(a, b) {
    this.Qc = b || [];
    N3(this, { providerId: a, isOAuthProvider: true });
    this.Ib = {};
    this.pb = (ng(a) || {}).Ja || null;
    this.ob = null;
  }
  Ng.prototype.Ka = function(a) {
    this.Ib = nb2(a);
    return this;
  };
  function Og(a) {
    if ("string" !== typeof a || 0 != a.indexOf("saml."))
      throw new t3("argument-error", 'SAML provider IDs must be prefixed with "saml."');
    Ng.call(this, a, []);
  }
  r2(Og, Ng);
  function Pg(a) {
    Ng.call(this, a, lg);
    this.a = [];
  }
  r2(Pg, Ng);
  Pg.prototype.Ca = function(a) {
    Va3(this.a, a) || this.a.push(a);
    return this;
  };
  Pg.prototype.Qb = function() {
    return Za3(this.a);
  };
  Pg.prototype.credential = function(a, b) {
    var c;
    n2(a) ? c = { idToken: a.idToken || null, accessToken: a.accessToken || null, nonce: a.rawNonce || null } : c = { idToken: a || null, accessToken: b || null };
    if (!c.idToken && !c.accessToken)
      throw new t3("argument-error", "credential failed: must provide the ID token and/or the access token.");
    return new Kg(this.providerId, c, this.providerId);
  };
  function Qg() {
    Pg.call(this, "facebook.com");
  }
  r2(Qg, Pg);
  M3(Qg, "PROVIDER_ID", "facebook.com");
  M3(Qg, "FACEBOOK_SIGN_IN_METHOD", "facebook.com");
  function Rg(a) {
    if (!a)
      throw new t3("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
    var b = a;
    n2(a) && (b = a.accessToken);
    return new Qg().credential({ accessToken: b });
  }
  function Sg() {
    Pg.call(this, "github.com");
  }
  r2(Sg, Pg);
  M3(Sg, "PROVIDER_ID", "github.com");
  M3(Sg, "GITHUB_SIGN_IN_METHOD", "github.com");
  function Tg(a) {
    if (!a)
      throw new t3("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
    var b = a;
    n2(a) && (b = a.accessToken);
    return new Sg().credential({ accessToken: b });
  }
  function Ug() {
    Pg.call(this, "google.com");
    this.Ca("profile");
  }
  r2(Ug, Pg);
  M3(Ug, "PROVIDER_ID", "google.com");
  M3(Ug, "GOOGLE_SIGN_IN_METHOD", "google.com");
  function Vg(a, b) {
    var c = a;
    n2(a) && (c = a.idToken, b = a.accessToken);
    return new Ug().credential({ idToken: c, accessToken: b });
  }
  function Wg() {
    Ng.call(this, "twitter.com", kg);
  }
  r2(Wg, Ng);
  M3(Wg, "PROVIDER_ID", "twitter.com");
  M3(Wg, "TWITTER_SIGN_IN_METHOD", "twitter.com");
  function Xg(a, b) {
    var c = a;
    n2(c) || (c = { oauthToken: a, oauthTokenSecret: b });
    if (!c.oauthToken || !c.oauthTokenSecret)
      throw new t3("argument-error", "credential failed: expected 2 arguments (the OAuth access token and secret).");
    return new Kg("twitter.com", c, "twitter.com");
  }
  function Yg(a, b, c) {
    this.a = a;
    this.f = b;
    M3(this, "providerId", "password");
    M3(this, "signInMethod", c === Zg.EMAIL_LINK_SIGN_IN_METHOD ? Zg.EMAIL_LINK_SIGN_IN_METHOD : Zg.EMAIL_PASSWORD_SIGN_IN_METHOD);
  }
  Yg.prototype.ka = function(a) {
    return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD ? O3(a, $g, { email: this.a, oobCode: this.f }) : O3(a, ah, { email: this.a, password: this.f });
  };
  Yg.prototype.b = function(a, b) {
    return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD ? O3(a, bh, { idToken: b, email: this.a, oobCode: this.f }) : O3(a, ch, { idToken: b, email: this.a, password: this.f });
  };
  Yg.prototype.c = function(a, b) {
    return Cg(this.ka(a), b);
  };
  Yg.prototype.w = function() {
    return { email: this.a, password: this.f, signInMethod: this.signInMethod };
  };
  function dh(a) {
    return a && a.email && a.password ? new Yg(a.email, a.password, a.signInMethod) : null;
  }
  function Zg() {
    N3(this, { providerId: "password", isOAuthProvider: false });
  }
  function eh(a, b) {
    b = fh(b);
    if (!b)
      throw new t3("argument-error", "Invalid email link!");
    return new Yg(a, b.code, Zg.EMAIL_LINK_SIGN_IN_METHOD);
  }
  function fh(a) {
    a = xg(a);
    return (a = Rf(a)) && a.operation === Af ? a : null;
  }
  N3(Zg, { PROVIDER_ID: "password" });
  N3(Zg, { EMAIL_LINK_SIGN_IN_METHOD: "emailLink" });
  N3(Zg, { EMAIL_PASSWORD_SIGN_IN_METHOD: "password" });
  function gh(a) {
    if (!(a.eb && a.cb || a.La && a.ea))
      throw new t3("internal-error");
    this.a = a;
    M3(this, "providerId", "phone");
    this.fa = "phone";
    M3(this, "signInMethod", "phone");
  }
  gh.prototype.ka = function(a) {
    return a.fb(hh(this));
  };
  gh.prototype.b = function(a, b) {
    var c = hh(this);
    c.idToken = b;
    return O3(a, ih, c);
  };
  gh.prototype.c = function(a, b) {
    var c = hh(this);
    c.operation = "REAUTH";
    a = O3(a, jh, c);
    return Cg(a, b);
  };
  gh.prototype.w = function() {
    var a = { providerId: "phone" };
    this.a.eb && (a.verificationId = this.a.eb);
    this.a.cb && (a.verificationCode = this.a.cb);
    this.a.La && (a.temporaryProof = this.a.La);
    this.a.ea && (a.phoneNumber = this.a.ea);
    return a;
  };
  function kh(a) {
    if (a && "phone" === a.providerId && (a.verificationId && a.verificationCode || a.temporaryProof && a.phoneNumber)) {
      var b = {};
      w2(["verificationId", "verificationCode", "temporaryProof", "phoneNumber"], function(c) {
        a[c] && (b[c] = a[c]);
      });
      return new gh(b);
    }
    return null;
  }
  function hh(a) {
    return a.a.La && a.a.ea ? { temporaryProof: a.a.La, phoneNumber: a.a.ea } : { sessionInfo: a.a.eb, code: a.a.cb };
  }
  function lh(a) {
    try {
      this.a = a || index_esm_default.auth();
    } catch (b) {
      throw new t3("argument-error", "Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");
    }
    N3(this, { providerId: "phone", isOAuthProvider: false });
  }
  lh.prototype.fb = function(a, b) {
    var c = this.a.a;
    return E3(b.verify()).then(function(d) {
      if ("string" !== typeof d)
        throw new t3("argument-error", "An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");
      switch (b.type) {
        case "recaptcha":
          var e = n2(a) ? a.session : null, f = n2(a) ? a.phoneNumber : a, g;
          e && e.type == zg ? g = e.Ha().then(function(h2) {
            return mh(c, { idToken: h2, phoneEnrollmentInfo: { phoneNumber: f, recaptchaToken: d } });
          }) : e && e.type == Ag ? g = e.Ha().then(function(h2) {
            return nh(
              c,
              { mfaPendingCredential: h2, mfaEnrollmentId: a.multiFactorHint && a.multiFactorHint.uid || a.multiFactorUid, phoneSignInInfo: { recaptchaToken: d } }
            );
          }) : g = oh(c, { phoneNumber: f, recaptchaToken: d });
          return g.then(function(h2) {
            "function" === typeof b.reset && b.reset();
            return h2;
          }, function(h2) {
            "function" === typeof b.reset && b.reset();
            throw h2;
          });
        default:
          throw new t3("argument-error", 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');
      }
    });
  };
  function ph(a, b) {
    if (!a)
      throw new t3("missing-verification-id");
    if (!b)
      throw new t3("missing-verification-code");
    return new gh({ eb: a, cb: b });
  }
  N3(lh, { PROVIDER_ID: "phone" });
  N3(lh, { PHONE_SIGN_IN_METHOD: "phone" });
  function qh(a) {
    if (a.temporaryProof && a.phoneNumber)
      return new gh({ La: a.temporaryProof, ea: a.phoneNumber });
    var b = a && a.providerId;
    if (!b || "password" === b)
      return null;
    var c = a && a.oauthAccessToken, d = a && a.oauthTokenSecret, e = a && a.nonce, f = a && a.oauthIdToken, g = a && a.pendingToken;
    try {
      switch (b) {
        case "google.com":
          return Vg(f, c);
        case "facebook.com":
          return Rg(c);
        case "github.com":
          return Tg(c);
        case "twitter.com":
          return Xg(c, d);
        default:
          return c || d || f || g ? g ? 0 == b.indexOf("saml.") ? new Eg(b, g) : new Kg(b, {
            pendingToken: g,
            idToken: a.oauthIdToken,
            accessToken: a.oauthAccessToken
          }, b) : new Pg(b).credential({ idToken: f, accessToken: c, rawNonce: e }) : null;
      }
    } catch (h2) {
      return null;
    }
  }
  function rh(a) {
    if (!a.isOAuthProvider)
      throw new t3("invalid-oauth-provider");
  }
  ;
  function sh(a, b, c, d, e, f, g) {
    this.c = a;
    this.b = b || null;
    this.g = c || null;
    this.f = d || null;
    this.i = f || null;
    this.h = g || null;
    this.a = e || null;
    if (this.g || this.a) {
      if (this.g && this.a)
        throw new t3("invalid-auth-event");
      if (this.g && !this.f)
        throw new t3("invalid-auth-event");
    } else
      throw new t3("invalid-auth-event");
  }
  sh.prototype.getUid = function() {
    var a = [];
    a.push(this.c);
    this.b && a.push(this.b);
    this.f && a.push(this.f);
    this.h && a.push(this.h);
    return a.join("-");
  };
  sh.prototype.T = function() {
    return this.h;
  };
  sh.prototype.w = function() {
    return { type: this.c, eventId: this.b, urlResponse: this.g, sessionId: this.f, postBody: this.i, tenantId: this.h, error: this.a && this.a.w() };
  };
  function th(a) {
    a = a || {};
    return a.type ? new sh(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && Aa3(a.error), a.postBody, a.tenantId) : null;
  }
  ;
  function uh() {
    this.b = null;
    this.a = [];
  }
  var vh = null;
  function wh(a) {
    var b = vh;
    b.a.push(a);
    b.b || (b.b = function(c) {
      for (var d = 0; d < b.a.length; d++)
        b.a[d](c);
    }, a = L4("universalLinks.subscribe", l), "function" === typeof a && a(null, b.b));
  }
  ;
  function xh(a) {
    var b = "unauthorized-domain", c = void 0, d = J3(a);
    a = d.a;
    d = d.c;
    "chrome-extension" == d ? c = Qb2("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : "http" == d || "https" == d ? c = Qb2("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : b = "operation-not-supported-in-this-environment";
    t3.call(this, b, c);
  }
  r2(xh, t3);
  function yh(a, b, c) {
    t3.call(this, a, c);
    a = b || {};
    a.Jb && M3(this, "email", a.Jb);
    a.ea && M3(this, "phoneNumber", a.ea);
    a.credential && M3(this, "credential", a.credential);
    a.Zb && M3(this, "tenantId", a.Zb);
  }
  r2(yh, t3);
  yh.prototype.w = function() {
    var a = { code: this.code, message: this.message };
    this.email && (a.email = this.email);
    this.phoneNumber && (a.phoneNumber = this.phoneNumber);
    this.tenantId && (a.tenantId = this.tenantId);
    var b = this.credential && this.credential.w();
    b && z3(a, b);
    return a;
  };
  yh.prototype.toJSON = function() {
    return this.w();
  };
  function zh(a) {
    if (a.code) {
      var b = a.code || "";
      0 == b.indexOf(xa2) && (b = b.substring(xa2.length));
      var c = { credential: qh(a), Zb: a.tenantId };
      if (a.email)
        c.Jb = a.email;
      else if (a.phoneNumber)
        c.ea = a.phoneNumber;
      else if (!c.credential)
        return new t3(b, a.message || void 0);
      return new yh(b, c, a.message);
    }
    return null;
  }
  ;
  function Ah() {
  }
  Ah.prototype.c = null;
  function Bh(a) {
    return a.c || (a.c = a.b());
  }
  ;
  var Ch;
  function Dh() {
  }
  r2(Dh, Ah);
  Dh.prototype.a = function() {
    var a = Eh(this);
    return a ? new ActiveXObject(a) : new XMLHttpRequest();
  };
  Dh.prototype.b = function() {
    var a = {};
    Eh(this) && (a[0] = true, a[1] = true);
    return a;
  };
  function Eh(a) {
    if (!a.f && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
      for (var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0; c < b.length; c++) {
        var d = b[c];
        try {
          return new ActiveXObject(d), a.f = d;
        } catch (e) {
        }
      }
      throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
    }
    return a.f;
  }
  Ch = new Dh();
  function Fh() {
  }
  r2(Fh, Ah);
  Fh.prototype.a = function() {
    var a = new XMLHttpRequest();
    if ("withCredentials" in a)
      return a;
    if ("undefined" != typeof XDomainRequest)
      return new Gh();
    throw Error("Unsupported browser");
  };
  Fh.prototype.b = function() {
    return {};
  };
  function Gh() {
    this.a = new XDomainRequest();
    this.readyState = 0;
    this.onreadystatechange = null;
    this.responseType = this.responseText = this.response = "";
    this.status = -1;
    this.statusText = "";
    this.a.onload = q3(this.qc, this);
    this.a.onerror = q3(this.Sb, this);
    this.a.onprogress = q3(this.rc, this);
    this.a.ontimeout = q3(this.vc, this);
  }
  k3 = Gh.prototype;
  k3.open = function(a, b, c) {
    if (null != c && !c)
      throw Error("Only async requests are supported.");
    this.a.open(a, b);
  };
  k3.send = function(a) {
    if (a)
      if ("string" == typeof a)
        this.a.send(a);
      else
        throw Error("Only string data is supported");
    else
      this.a.send();
  };
  k3.abort = function() {
    this.a.abort();
  };
  k3.setRequestHeader = function() {
  };
  k3.getResponseHeader = function(a) {
    return "content-type" == a.toLowerCase() ? this.a.contentType : "";
  };
  k3.qc = function() {
    this.status = 200;
    this.response = this.responseText = this.a.responseText;
    Hh(this, 4);
  };
  k3.Sb = function() {
    this.status = 500;
    this.response = this.responseText = "";
    Hh(this, 4);
  };
  k3.vc = function() {
    this.Sb();
  };
  k3.rc = function() {
    this.status = 200;
    Hh(this, 1);
  };
  function Hh(a, b) {
    a.readyState = b;
    if (a.onreadystatechange)
      a.onreadystatechange();
  }
  k3.getAllResponseHeaders = function() {
    return "content-type: " + this.a.contentType;
  };
  function Ih(a, b, c) {
    this.reset(a, b, c, void 0, void 0);
  }
  Ih.prototype.a = null;
  var Jh = 0;
  Ih.prototype.reset = function(a, b, c, d, e) {
    "number" == typeof e || Jh++;
    d || va2();
    delete this.a;
  };
  function Kh(a) {
    this.f = a;
    this.b = this.c = this.a = null;
  }
  function Lh(a, b) {
    this.name = a;
    this.value = b;
  }
  Lh.prototype.toString = function() {
    return this.name;
  };
  var Mh = new Lh("SEVERE", 1e3), Nh = new Lh("WARNING", 900), Oh = new Lh("CONFIG", 700), Ph = new Lh("FINE", 500);
  function Qh(a) {
    if (a.c)
      return a.c;
    if (a.a)
      return Qh(a.a);
    Ga3("Root logger has no level set.");
    return null;
  }
  Kh.prototype.log = function(a, b, c) {
    if (a.value >= Qh(this).value)
      for (oa3(b) && (b = b()), a = new Ih(a, String(b), this.f), c && (a.a = c), c = this; c; )
        c = c.a;
  };
  var Rh = {}, Sh = null;
  function Th(a) {
    Sh || (Sh = new Kh(""), Rh[""] = Sh, Sh.c = Oh);
    var b;
    if (!(b = Rh[a])) {
      b = new Kh(a);
      var c = a.lastIndexOf("."), d = a.substr(c + 1);
      c = Th(a.substr(0, c));
      c.b || (c.b = {});
      c.b[d] = b;
      b.a = c;
      Rh[a] = b;
    }
    return b;
  }
  ;
  function Uh(a, b) {
    a && a.log(Ph, b, void 0);
  }
  ;
  function Vh(a) {
    this.f = a;
  }
  r2(Vh, Ah);
  Vh.prototype.a = function() {
    return new Wh(this.f);
  };
  Vh.prototype.b = /* @__PURE__ */ function(a) {
    return function() {
      return a;
    };
  }({});
  function Wh(a) {
    H3.call(this);
    this.u = a;
    this.h = void 0;
    this.readyState = Xh;
    this.status = 0;
    this.responseType = this.responseText = this.response = this.statusText = "";
    this.onreadystatechange = null;
    this.l = new Headers();
    this.b = null;
    this.s = "GET";
    this.f = "";
    this.a = false;
    this.i = Th("goog.net.FetchXmlHttp");
    this.m = this.c = this.g = null;
  }
  r2(Wh, H3);
  var Xh = 0;
  k3 = Wh.prototype;
  k3.open = function(a, b) {
    if (this.readyState != Xh)
      throw this.abort(), Error("Error reopening a connection");
    this.s = a;
    this.f = b;
    this.readyState = 1;
    Yh(this);
  };
  k3.send = function(a) {
    if (1 != this.readyState)
      throw this.abort(), Error("need to call open() first. ");
    this.a = true;
    var b = { headers: this.l, method: this.s, credentials: this.h, cache: void 0 };
    a && (b.body = a);
    this.u.fetch(new Request(this.f, b)).then(this.uc.bind(this), this.Ua.bind(this));
  };
  k3.abort = function() {
    this.response = this.responseText = "";
    this.l = new Headers();
    this.status = 0;
    this.c && this.c.cancel("Request was aborted.");
    1 <= this.readyState && this.a && 4 != this.readyState && (this.a = false, Zh(this));
    this.readyState = Xh;
  };
  k3.uc = function(a) {
    this.a && (this.g = a, this.b || (this.status = this.g.status, this.statusText = this.g.statusText, this.b = a.headers, this.readyState = 2, Yh(this)), this.a && (this.readyState = 3, Yh(this), this.a && ("arraybuffer" === this.responseType ? a.arrayBuffer().then(this.sc.bind(this), this.Ua.bind(this)) : "undefined" !== typeof l.ReadableStream && "body" in a ? (this.response = this.responseText = "", this.c = a.body.getReader(), this.m = new TextDecoder(), $h(this)) : a.text().then(this.tc.bind(this), this.Ua.bind(this)))));
  };
  function $h(a) {
    a.c.read().then(a.pc.bind(a)).catch(a.Ua.bind(a));
  }
  k3.pc = function(a) {
    if (this.a) {
      var b = this.m.decode(a.value ? a.value : new Uint8Array(0), { stream: !a.done });
      b && (this.response = this.responseText += b);
      a.done ? Zh(this) : Yh(this);
      3 == this.readyState && $h(this);
    }
  };
  k3.tc = function(a) {
    this.a && (this.response = this.responseText = a, Zh(this));
  };
  k3.sc = function(a) {
    this.a && (this.response = a, Zh(this));
  };
  k3.Ua = function(a) {
    var b = this.i;
    b && b.log(Nh, "Failed to fetch url " + this.f, a instanceof Error ? a : Error(a));
    this.a && Zh(this);
  };
  function Zh(a) {
    a.readyState = 4;
    a.g = null;
    a.c = null;
    a.m = null;
    Yh(a);
  }
  k3.setRequestHeader = function(a, b) {
    this.l.append(a, b);
  };
  k3.getResponseHeader = function(a) {
    return this.b ? this.b.get(a.toLowerCase()) || "" : ((a = this.i) && a.log(Nh, "Attempting to get response header but no headers have been received for url: " + this.f, void 0), "");
  };
  k3.getAllResponseHeaders = function() {
    if (!this.b) {
      var a = this.i;
      a && a.log(Nh, "Attempting to get all response headers but no headers have been received for url: " + this.f, void 0);
      return "";
    }
    a = [];
    for (var b = this.b.entries(), c = b.next(); !c.done; )
      c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
    return a.join("\r\n");
  };
  function Yh(a) {
    a.onreadystatechange && a.onreadystatechange.call(a);
  }
  Object.defineProperty(Wh.prototype, "withCredentials", { get: function() {
    return "include" === this.h;
  }, set: function(a) {
    this.h = a ? "include" : "same-origin";
  } });
  function ai2(a) {
    H3.call(this);
    this.headers = new Jd2();
    this.D = a || null;
    this.c = false;
    this.C = this.a = null;
    this.h = this.R = this.l = "";
    this.f = this.O = this.i = this.J = false;
    this.g = 0;
    this.s = null;
    this.m = bi2;
    this.u = this.S = false;
  }
  r2(ai2, H3);
  var bi2 = "";
  ai2.prototype.b = Th("goog.net.XhrIo");
  var ci2 = /^https?$/i, di2 = ["POST", "PUT"];
  function ei2(a, b, c, d, e) {
    if (a.a)
      throw Error("[goog.net.XhrIo] Object is active with another request=" + a.l + "; newUri=" + b);
    c = c ? c.toUpperCase() : "GET";
    a.l = b;
    a.h = "";
    a.R = c;
    a.J = false;
    a.c = true;
    a.a = a.D ? a.D.a() : Ch.a();
    a.C = a.D ? Bh(a.D) : Bh(Ch);
    a.a.onreadystatechange = q3(a.Vb, a);
    try {
      Uh(a.b, fi2(a, "Opening Xhr")), a.O = true, a.a.open(c, String(b), true), a.O = false;
    } catch (g) {
      Uh(a.b, fi2(a, "Error opening Xhr: " + g.message));
      gi2(a, g);
      return;
    }
    b = d || "";
    var f = new Jd2(a.headers);
    e && Id2(e, function(g, h2) {
      f.set(h2, g);
    });
    e = Ta3(f.Y());
    d = l.FormData && b instanceof l.FormData;
    !Va3(di2, c) || e || d || f.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    f.forEach(function(g, h2) {
      this.a.setRequestHeader(h2, g);
    }, a);
    a.m && (a.a.responseType = a.m);
    "withCredentials" in a.a && a.a.withCredentials !== a.S && (a.a.withCredentials = a.S);
    try {
      hi2(a), 0 < a.g && (a.u = ii2(a.a), Uh(a.b, fi2(a, "Will abort after " + a.g + "ms if incomplete, xhr2 " + a.u)), a.u ? (a.a.timeout = a.g, a.a.ontimeout = q3(a.Ma, a)) : a.s = Ed2(a.Ma, a.g, a)), Uh(a.b, fi2(a, "Sending request")), a.i = true, a.a.send(b), a.i = false;
    } catch (g) {
      Uh(
        a.b,
        fi2(a, "Send error: " + g.message)
      ), gi2(a, g);
    }
  }
  function ii2(a) {
    return Wb2 && fc3(9) && "number" === typeof a.timeout && void 0 !== a.ontimeout;
  }
  function Ua3(a) {
    return "content-type" == a.toLowerCase();
  }
  k3 = ai2.prototype;
  k3.Ma = function() {
    "undefined" != typeof ha3 && this.a && (this.h = "Timed out after " + this.g + "ms, aborting", Uh(this.b, fi2(this, this.h)), this.dispatchEvent("timeout"), this.abort(8));
  };
  function gi2(a, b) {
    a.c = false;
    a.a && (a.f = true, a.a.abort(), a.f = false);
    a.h = b;
    ji2(a);
    ki2(a);
  }
  function ji2(a) {
    a.J || (a.J = true, a.dispatchEvent("complete"), a.dispatchEvent("error"));
  }
  k3.abort = function() {
    this.a && this.c && (Uh(this.b, fi2(this, "Aborting")), this.c = false, this.f = true, this.a.abort(), this.f = false, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ki2(this));
  };
  k3.Da = function() {
    this.a && (this.c && (this.c = false, this.f = true, this.a.abort(), this.f = false), ki2(this, true));
    ai2.ab.Da.call(this);
  };
  k3.Vb = function() {
    this.xa || (this.O || this.i || this.f ? li2(this) : this.Jc());
  };
  k3.Jc = function() {
    li2(this);
  };
  function li2(a) {
    if (a.c && "undefined" != typeof ha3) {
      if (a.C[1] && 4 == mi2(a) && 2 == ni2(a))
        Uh(a.b, fi2(a, "Local request error detected and ignored"));
      else if (a.i && 4 == mi2(a))
        Ed2(a.Vb, 0, a);
      else if (a.dispatchEvent("readystatechange"), 4 == mi2(a)) {
        Uh(a.b, fi2(a, "Request complete"));
        a.c = false;
        try {
          var b = ni2(a);
          a:
            switch (b) {
              case 200:
              case 201:
              case 202:
              case 204:
              case 206:
              case 304:
              case 1223:
                var c = true;
                break a;
              default:
                c = false;
            }
          var d;
          if (!(d = c)) {
            var e;
            if (e = 0 === b) {
              var f = String(a.l).match(Md2)[1] || null;
              if (!f && l.self && l.self.location) {
                var g = l.self.location.protocol;
                f = g.substr(0, g.length - 1);
              }
              e = !ci2.test(f ? f.toLowerCase() : "");
            }
            d = e;
          }
          if (d)
            a.dispatchEvent("complete"), a.dispatchEvent("success");
          else {
            try {
              var h2 = 2 < mi2(a) ? a.a.statusText : "";
            } catch (m) {
              Uh(a.b, "Can not get status: " + m.message), h2 = "";
            }
            a.h = h2 + " [" + ni2(a) + "]";
            ji2(a);
          }
        } finally {
          ki2(a);
        }
      }
    }
  }
  function ki2(a, b) {
    if (a.a) {
      hi2(a);
      var c = a.a, d = a.C[0] ? la2 : null;
      a.a = null;
      a.C = null;
      b || a.dispatchEvent("ready");
      try {
        c.onreadystatechange = d;
      } catch (e) {
        (a = a.b) && a.log(Mh, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
      }
    }
  }
  function hi2(a) {
    a.a && a.u && (a.a.ontimeout = null);
    a.s && (l.clearTimeout(a.s), a.s = null);
  }
  function mi2(a) {
    return a.a ? a.a.readyState : 0;
  }
  function ni2(a) {
    try {
      return 2 < mi2(a) ? a.a.status : -1;
    } catch (b) {
      return -1;
    }
  }
  function oi2(a) {
    try {
      return a.a ? a.a.responseText : "";
    } catch (b) {
      return Uh(a.b, "Can not get responseText: " + b.message), "";
    }
  }
  k3.getResponse = function() {
    try {
      if (!this.a)
        return null;
      if ("response" in this.a)
        return this.a.response;
      switch (this.m) {
        case bi2:
        case "text":
          return this.a.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in this.a)
            return this.a.mozResponseArrayBuffer;
      }
      var a = this.b;
      a && a.log(Mh, "Response type " + this.m + " is not supported on this browser", void 0);
      return null;
    } catch (b) {
      return Uh(this.b, "Can not get response: " + b.message), null;
    }
  };
  function fi2(a, b) {
    return b + " [" + a.R + " " + a.l + " " + ni2(a) + "]";
  }
  ;
  function pi2(a) {
    var b = qi2;
    this.g = [];
    this.u = b;
    this.s = a || null;
    this.f = this.a = false;
    this.c = void 0;
    this.v = this.C = this.i = false;
    this.h = 0;
    this.b = null;
    this.l = 0;
  }
  pi2.prototype.cancel = function(a) {
    if (this.a)
      this.c instanceof pi2 && this.c.cancel();
    else {
      if (this.b) {
        var b = this.b;
        delete this.b;
        a ? b.cancel(a) : (b.l--, 0 >= b.l && b.cancel());
      }
      this.u ? this.u.call(this.s, this) : this.v = true;
      this.a || (a = new ri2(this), si2(this), ti2(this, false, a));
    }
  };
  pi2.prototype.m = function(a, b) {
    this.i = false;
    ti2(this, a, b);
  };
  function ti2(a, b, c) {
    a.a = true;
    a.c = c;
    a.f = !b;
    ui2(a);
  }
  function si2(a) {
    if (a.a) {
      if (!a.v)
        throw new vi2(a);
      a.v = false;
    }
  }
  function wi2(a, b) {
    xi2(a, null, b, void 0);
  }
  function xi2(a, b, c, d) {
    a.g.push([b, c, d]);
    a.a && ui2(a);
  }
  pi2.prototype.then = function(a, b, c) {
    var d, e, f = new D3(function(g, h2) {
      d = g;
      e = h2;
    });
    xi2(this, d, function(g) {
      g instanceof ri2 ? f.cancel() : e(g);
    });
    return f.then(a, b, c);
  };
  pi2.prototype.$goog_Thenable = true;
  function yi2(a) {
    return Sa2(a.g, function(b) {
      return oa3(b[1]);
    });
  }
  function ui2(a) {
    if (a.h && a.a && yi2(a)) {
      var b = a.h, c = zi2[b];
      c && (l.clearTimeout(c.a), delete zi2[b]);
      a.h = 0;
    }
    a.b && (a.b.l--, delete a.b);
    b = a.c;
    for (var d = c = false; a.g.length && !a.i; ) {
      var e = a.g.shift(), f = e[0], g = e[1];
      e = e[2];
      if (f = a.f ? g : f)
        try {
          var h2 = f.call(e || a.s, b);
          void 0 !== h2 && (a.f = a.f && (h2 == b || h2 instanceof Error), a.c = b = h2);
          if (Ea3(b) || "function" === typeof l.Promise && b instanceof l.Promise)
            d = true, a.i = true;
        } catch (m) {
          b = m, a.f = true, yi2(a) || (c = true);
        }
    }
    a.c = b;
    d && (h2 = q3(a.m, a, true), d = q3(a.m, a, false), b instanceof pi2 ? (xi2(b, h2, d), b.C = true) : b.then(h2, d));
    c && (b = new Ai2(b), zi2[b.a] = b, a.h = b.a);
  }
  function vi2() {
    u.call(this);
  }
  r2(vi2, u);
  vi2.prototype.message = "Deferred has already fired";
  vi2.prototype.name = "AlreadyCalledError";
  function ri2() {
    u.call(this);
  }
  r2(ri2, u);
  ri2.prototype.message = "Deferred was canceled";
  ri2.prototype.name = "CanceledError";
  function Ai2(a) {
    this.a = l.setTimeout(q3(this.c, this), 0);
    this.b = a;
  }
  Ai2.prototype.c = function() {
    delete zi2[this.a];
    throw this.b;
  };
  var zi2 = {};
  function Bi2(a) {
    var b = {}, c = b.document || document, d = yb2(a).toString(), e = oc3(document, "SCRIPT"), f = { Wb: e, Ma: void 0 }, g = new pi2(f), h2 = null, m = null != b.timeout ? b.timeout : 5e3;
    0 < m && (h2 = window.setTimeout(function() {
      Ci2(e, true);
      var p2 = new Di2(Ei2, "Timeout reached for loading script " + d);
      si2(g);
      ti2(g, false, p2);
    }, m), f.Ma = h2);
    e.onload = e.onreadystatechange = function() {
      e.readyState && "loaded" != e.readyState && "complete" != e.readyState || (Ci2(e, b.xd || false, h2), si2(g), ti2(g, true, null));
    };
    e.onerror = function() {
      Ci2(e, true, h2);
      var p2 = new Di2(Fi2, "Error while loading script " + d);
      si2(g);
      ti2(g, false, p2);
    };
    f = b.attributes || {};
    z3(f, { type: "text/javascript", charset: "UTF-8" });
    lc3(e, f);
    Ob2(e, a);
    Gi2(c).appendChild(e);
    return g;
  }
  function Gi2(a) {
    var b;
    return (b = (a || document).getElementsByTagName("HEAD")) && 0 != b.length ? b[0] : a.documentElement;
  }
  function qi2() {
    if (this && this.Wb) {
      var a = this.Wb;
      a && "SCRIPT" == a.tagName && Ci2(a, true, this.Ma);
    }
  }
  function Ci2(a, b, c) {
    null != c && l.clearTimeout(c);
    a.onload = la2;
    a.onerror = la2;
    a.onreadystatechange = la2;
    b && window.setTimeout(function() {
      a && a.parentNode && a.parentNode.removeChild(a);
    }, 0);
  }
  var Fi2 = 0, Ei2 = 1;
  function Di2(a, b) {
    var c = "Jsloader error (code #" + a + ")";
    b && (c += ": " + b);
    u.call(this, c);
    this.code = a;
  }
  r2(Di2, u);
  function Hi2(a) {
    this.f = a;
  }
  r2(Hi2, Ah);
  Hi2.prototype.a = function() {
    return new this.f();
  };
  Hi2.prototype.b = function() {
    return {};
  };
  function Ii2(a, b, c) {
    this.c = a;
    a = b || {};
    this.l = a.secureTokenEndpoint || "https://securetoken.googleapis.com/v1/token";
    this.m = a.secureTokenTimeout || Ji2;
    this.g = nb2(a.secureTokenHeaders || Ki2);
    this.h = a.firebaseEndpoint || "https://www.googleapis.com/identitytoolkit/v3/relyingparty/";
    this.i = a.identityPlatformEndpoint || "https://identitytoolkit.googleapis.com/v2/";
    this.v = a.firebaseTimeout || Li2;
    this.a = nb2(a.firebaseHeaders || Mi2);
    c && (this.a["X-Client-Version"] = c, this.g["X-Client-Version"] = c);
    c = "Node" == Ke2();
    c = l.XMLHttpRequest || c && index_esm_default.INTERNAL.node && index_esm_default.INTERNAL.node.XMLHttpRequest;
    if (!c && !Je2())
      throw new t3("internal-error", "The XMLHttpRequest compatibility library was not found.");
    this.f = void 0;
    Je2() ? this.f = new Vh(self) : Le2() ? this.f = new Hi2(c) : this.f = new Fh();
    this.b = null;
  }
  var Ni2, Dg = "idToken", Ji2 = new Ze2(3e4, 6e4), Ki2 = { "Content-Type": "application/x-www-form-urlencoded" }, Li2 = new Ze2(3e4, 6e4), Mi2 = { "Content-Type": "application/json" };
  function Oi2(a, b) {
    b ? a.a["X-Firebase-Locale"] = b : delete a.a["X-Firebase-Locale"];
  }
  function Pi2(a, b) {
    b && (a.l = Qi2("https://securetoken.googleapis.com/v1/token", b), a.h = Qi2("https://www.googleapis.com/identitytoolkit/v3/relyingparty/", b), a.i = Qi2("https://identitytoolkit.googleapis.com/v2/", b));
  }
  function Qi2(a, b) {
    a = J3(a);
    b = J3(b.url);
    a.f = a.a + a.f;
    Pd2(a, b.c);
    a.a = b.a;
    Qd2(a, b.g);
    return a.toString();
  }
  function Ri2(a, b) {
    b ? (a.a["X-Client-Version"] = b, a.g["X-Client-Version"] = b) : (delete a.a["X-Client-Version"], delete a.g["X-Client-Version"]);
  }
  Ii2.prototype.T = function() {
    return this.b;
  };
  function Si2(a, b, c, d, e, f, g) {
    ue2() || Je2() ? a = q3(a.u, a) : (Ni2 || (Ni2 = new D3(function(h2, m) {
      Ti2(h2, m);
    })), a = q3(a.s, a));
    a(b, c, d, e, f, g);
  }
  Ii2.prototype.u = function(a, b, c, d, e, f) {
    if (Je2() && ("undefined" === typeof l.fetch || "undefined" === typeof l.Headers || "undefined" === typeof l.Request))
      throw new t3("operation-not-supported-in-this-environment", "fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.");
    var g = new ai2(this.f);
    if (f) {
      g.g = Math.max(0, f);
      var h2 = setTimeout(function() {
        g.dispatchEvent("timeout");
      }, f);
    }
    qd2(g, "complete", function() {
      h2 && clearTimeout(h2);
      var m = null;
      try {
        m = JSON.parse(oi2(this)) || null;
      } catch (p2) {
        m = null;
      }
      b && b(m);
    });
    wd2(g, "ready", function() {
      h2 && clearTimeout(h2);
      Xc2(this);
    });
    wd2(g, "timeout", function() {
      h2 && clearTimeout(h2);
      Xc2(this);
      b && b(null);
    });
    ei2(g, a, c, d, e);
  };
  var Ui2 = new qb2(rb, "https://apis.google.com/js/client.js?onload=%{onload}"), Vi2 = "__fcb" + Math.floor(1e6 * Math.random()).toString();
  function Ti2(a, b) {
    if (((window.gapi || {}).client || {}).request)
      a();
    else {
      l[Vi2] = function() {
        ((window.gapi || {}).client || {}).request ? a() : b(Error("CORS_UNSUPPORTED"));
      };
      var c = zb2(Ui2, { onload: Vi2 });
      wi2(Bi2(c), function() {
        b(Error("CORS_UNSUPPORTED"));
      });
    }
  }
  Ii2.prototype.s = function(a, b, c, d, e) {
    var f = this;
    Ni2.then(function() {
      window.gapi.client.setApiKey(f.c);
      var g = window.gapi.auth.getToken();
      window.gapi.auth.setToken(null);
      window.gapi.client.request({ path: a, method: c, body: d, headers: e, authType: "none", callback: function(h2) {
        window.gapi.auth.setToken(g);
        b && b(h2);
      } });
    }).o(function(g) {
      b && b({ error: { message: g && g.message || "CORS_UNSUPPORTED" } });
    });
  };
  function Wi2(a, b) {
    return new D3(function(c, d) {
      "refresh_token" == b.grant_type && b.refresh_token || "authorization_code" == b.grant_type && b.code ? Si2(a, a.l + "?key=" + encodeURIComponent(a.c), function(e) {
        e ? e.error ? d(Xi2(e)) : e.access_token && e.refresh_token ? c(e) : d(new t3("internal-error")) : d(new t3("network-request-failed"));
      }, "POST", fe2(b).toString(), a.g, a.m.get()) : d(new t3("internal-error"));
    });
  }
  function Yi2(a, b, c, d, e, f, g) {
    var h2 = J3(b + c);
    I3(h2, "key", a.c);
    g && I3(h2, "cb", va2().toString());
    var m = "GET" == d;
    if (m)
      for (var p2 in e)
        e.hasOwnProperty(p2) && I3(h2, p2, e[p2]);
    return new D3(function(v2, B2) {
      Si2(a, h2.toString(), function(A3) {
        A3 ? A3.error ? B2(Xi2(A3, f || {})) : v2(A3) : B2(new t3("network-request-failed"));
      }, d, m ? void 0 : ke2(Ve2(e)), a.a, a.v.get());
    });
  }
  function Zi2(a) {
    a = a.email;
    if ("string" !== typeof a || !De2.test(a))
      throw new t3("invalid-email");
  }
  function $i2(a) {
    "email" in a && Zi2(a);
  }
  function aj(a, b) {
    return O3(a, bj, { identifier: b, continueUri: Se2() ? re2() : "http://localhost" }).then(function(c) {
      return c.signinMethods || [];
    });
  }
  function cj(a) {
    return O3(a, dj, {}).then(function(b) {
      return b.authorizedDomains || [];
    });
  }
  function P4(a) {
    if (!a[Dg]) {
      if (a.mfaPendingCredential)
        throw new t3("multi-factor-auth-required", null, nb2(a));
      throw new t3("internal-error");
    }
  }
  function ej(a) {
    if (a.phoneNumber || a.temporaryProof) {
      if (!a.phoneNumber || !a.temporaryProof)
        throw new t3("internal-error");
    } else {
      if (!a.sessionInfo)
        throw new t3("missing-verification-id");
      if (!a.code)
        throw new t3("missing-verification-code");
    }
  }
  Ii2.prototype.zb = function() {
    return O3(this, fj, {});
  };
  Ii2.prototype.Bb = function(a, b) {
    return O3(this, gj, { idToken: a, email: b });
  };
  Ii2.prototype.Cb = function(a, b) {
    return O3(this, ch, { idToken: a, password: b });
  };
  var hj = { displayName: "DISPLAY_NAME", photoUrl: "PHOTO_URL" };
  k3 = Ii2.prototype;
  k3.Db = function(a, b) {
    var c = { idToken: a }, d = [];
    lb2(hj, function(e, f) {
      var g = b[f];
      null === g ? d.push(e) : f in b && (c[f] = g);
    });
    d.length && (c.deleteAttribute = d);
    return O3(this, gj, c);
  };
  k3.vb = function(a, b) {
    a = { requestType: "PASSWORD_RESET", email: a };
    z3(a, b);
    return O3(this, ij, a);
  };
  k3.wb = function(a, b) {
    a = { requestType: "EMAIL_SIGNIN", email: a };
    z3(a, b);
    return O3(this, jj, a);
  };
  k3.ub = function(a, b) {
    a = { requestType: "VERIFY_EMAIL", idToken: a };
    z3(a, b);
    return O3(this, kj, a);
  };
  k3.Eb = function(a, b, c) {
    a = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: a, newEmail: b };
    z3(a, c);
    return O3(this, lj, a);
  };
  function oh(a, b) {
    return O3(a, mj, b);
  }
  k3.fb = function(a) {
    return O3(this, nj, a);
  };
  function mh(a, b) {
    return O3(a, oj, b).then(function(c) {
      return c.phoneSessionInfo.sessionInfo;
    });
  }
  function pj(a) {
    if (!a.phoneVerificationInfo)
      throw new t3("internal-error");
    if (!a.phoneVerificationInfo.sessionInfo)
      throw new t3("missing-verification-id");
    if (!a.phoneVerificationInfo.code)
      throw new t3("missing-verification-code");
  }
  function nh(a, b) {
    return O3(a, qj, b).then(function(c) {
      return c.phoneResponseInfo.sessionInfo;
    });
  }
  function rj(a, b, c) {
    return O3(a, sj, { idToken: b, deleteProvider: c });
  }
  function tj(a) {
    if (!a.requestUri || !a.sessionId && !a.postBody && !a.pendingToken)
      throw new t3("internal-error");
  }
  function uj(a, b) {
    b.oauthIdToken && b.providerId && 0 == b.providerId.indexOf("oidc.") && !b.pendingToken && (a.sessionId ? b.nonce = a.sessionId : a.postBody && (a = new Ud(a.postBody), je2(a, "nonce") && (b.nonce = a.get("nonce"))));
    return b;
  }
  function vj(a) {
    var b = null;
    a.needConfirmation ? (a.code = "account-exists-with-different-credential", b = zh(a)) : "FEDERATED_USER_ID_ALREADY_LINKED" == a.errorMessage ? (a.code = "credential-already-in-use", b = zh(a)) : "EMAIL_EXISTS" == a.errorMessage ? (a.code = "email-already-in-use", b = zh(a)) : a.errorMessage && (b = wj(a.errorMessage));
    if (b)
      throw b;
    P4(a);
  }
  function Fg(a, b) {
    b.returnIdpCredential = true;
    return O3(a, xj, b);
  }
  function Hg(a, b) {
    b.returnIdpCredential = true;
    return O3(a, yj, b);
  }
  function Ig(a, b) {
    b.returnIdpCredential = true;
    b.autoCreate = false;
    return O3(a, zj, b);
  }
  function Aj(a) {
    if (!a.oobCode)
      throw new t3("invalid-action-code");
  }
  k3.nb = function(a, b) {
    return O3(this, Bj, { oobCode: a, newPassword: b });
  };
  k3.Ra = function(a) {
    return O3(this, Cj, { oobCode: a });
  };
  k3.jb = function(a) {
    return O3(this, Dj, { oobCode: a });
  };
  var Dj = { endpoint: "setAccountInfo", A: Aj, Z: "email", B: true }, Cj = { endpoint: "resetPassword", A: Aj, G: function(a) {
    var b = a.requestType;
    if (!b || !a.email && "EMAIL_SIGNIN" != b && "VERIFY_AND_CHANGE_EMAIL" != b)
      throw new t3("internal-error");
  }, B: true }, Ej = { endpoint: "signupNewUser", A: function(a) {
    Zi2(a);
    if (!a.password)
      throw new t3("weak-password");
  }, G: P4, V: true, B: true }, bj = { endpoint: "createAuthUri", B: true }, Fj = { endpoint: "deleteAccount", N: ["idToken"] }, sj = { endpoint: "setAccountInfo", N: ["idToken", "deleteProvider"], A: function(a) {
    if (!Array.isArray(a.deleteProvider))
      throw new t3("internal-error");
  } }, $g = { endpoint: "emailLinkSignin", N: ["email", "oobCode"], A: Zi2, G: P4, V: true, B: true }, bh = { endpoint: "emailLinkSignin", N: ["idToken", "email", "oobCode"], A: Zi2, G: P4, V: true }, Gj = { endpoint: "accounts/mfaEnrollment:finalize", N: ["idToken", "phoneVerificationInfo"], A: pj, G: P4, B: true, Na: true }, Hj = { endpoint: "accounts/mfaSignIn:finalize", N: ["mfaPendingCredential", "phoneVerificationInfo"], A: pj, G: P4, B: true, Na: true }, Ij = { endpoint: "getAccountInfo" }, jj = { endpoint: "getOobConfirmationCode", N: ["requestType"], A: function(a) {
    if ("EMAIL_SIGNIN" != a.requestType)
      throw new t3("internal-error");
    Zi2(a);
  }, Z: "email", B: true }, kj = { endpoint: "getOobConfirmationCode", N: ["idToken", "requestType"], A: function(a) {
    if ("VERIFY_EMAIL" != a.requestType)
      throw new t3("internal-error");
  }, Z: "email", B: true }, lj = { endpoint: "getOobConfirmationCode", N: ["idToken", "newEmail", "requestType"], A: function(a) {
    if ("VERIFY_AND_CHANGE_EMAIL" != a.requestType)
      throw new t3("internal-error");
  }, Z: "email", B: true }, ij = { endpoint: "getOobConfirmationCode", N: ["requestType"], A: function(a) {
    if ("PASSWORD_RESET" != a.requestType)
      throw new t3("internal-error");
    Zi2(a);
  }, Z: "email", B: true }, dj = { lb: true, endpoint: "getProjectConfig", Ub: "GET" }, Jj = { lb: true, endpoint: "getRecaptchaParam", Ub: "GET", G: function(a) {
    if (!a.recaptchaSiteKey)
      throw new t3("internal-error");
  } }, Bj = { endpoint: "resetPassword", A: Aj, Z: "email", B: true }, mj = { endpoint: "sendVerificationCode", N: ["phoneNumber", "recaptchaToken"], Z: "sessionInfo", B: true }, gj = { endpoint: "setAccountInfo", N: ["idToken"], A: $i2, V: true }, ch = {
    endpoint: "setAccountInfo",
    N: ["idToken"],
    A: function(a) {
      $i2(a);
      if (!a.password)
        throw new t3("weak-password");
    },
    G: P4,
    V: true
  }, fj = { endpoint: "signupNewUser", G: P4, V: true, B: true }, oj = { endpoint: "accounts/mfaEnrollment:start", N: ["idToken", "phoneEnrollmentInfo"], A: function(a) {
    if (!a.phoneEnrollmentInfo)
      throw new t3("internal-error");
    if (!a.phoneEnrollmentInfo.phoneNumber)
      throw new t3("missing-phone-number");
    if (!a.phoneEnrollmentInfo.recaptchaToken)
      throw new t3("missing-app-credential");
  }, G: function(a) {
    if (!a.phoneSessionInfo || !a.phoneSessionInfo.sessionInfo)
      throw new t3("internal-error");
  }, B: true, Na: true }, qj = {
    endpoint: "accounts/mfaSignIn:start",
    N: ["mfaPendingCredential", "mfaEnrollmentId", "phoneSignInInfo"],
    A: function(a) {
      if (!a.phoneSignInInfo || !a.phoneSignInInfo.recaptchaToken)
        throw new t3("missing-app-credential");
    },
    G: function(a) {
      if (!a.phoneResponseInfo || !a.phoneResponseInfo.sessionInfo)
        throw new t3("internal-error");
    },
    B: true,
    Na: true
  }, xj = { endpoint: "verifyAssertion", A: tj, Ya: uj, G: vj, V: true, B: true }, zj = { endpoint: "verifyAssertion", A: tj, Ya: uj, G: function(a) {
    if (a.errorMessage && "USER_NOT_FOUND" == a.errorMessage)
      throw new t3("user-not-found");
    if (a.errorMessage)
      throw wj(a.errorMessage);
    P4(a);
  }, V: true, B: true }, yj = { endpoint: "verifyAssertion", A: function(a) {
    tj(a);
    if (!a.idToken)
      throw new t3("internal-error");
  }, Ya: uj, G: vj, V: true }, Kj = { endpoint: "verifyCustomToken", A: function(a) {
    if (!a.token)
      throw new t3("invalid-custom-token");
  }, G: P4, V: true, B: true }, ah = { endpoint: "verifyPassword", A: function(a) {
    Zi2(a);
    if (!a.password)
      throw new t3("wrong-password");
  }, G: P4, V: true, B: true }, nj = { endpoint: "verifyPhoneNumber", A: ej, G: P4, B: true }, ih = {
    endpoint: "verifyPhoneNumber",
    A: function(a) {
      if (!a.idToken)
        throw new t3("internal-error");
      ej(a);
    },
    G: function(a) {
      if (a.temporaryProof)
        throw a.code = "credential-already-in-use", zh(a);
      P4(a);
    }
  }, jh = { Hb: { USER_NOT_FOUND: "user-not-found" }, endpoint: "verifyPhoneNumber", A: ej, G: P4, B: true }, Lj = { endpoint: "accounts/mfaEnrollment:withdraw", N: ["idToken", "mfaEnrollmentId"], G: function(a) {
    if (!!a[Dg] ^ !!a.refreshToken)
      throw new t3("internal-error");
  }, B: true, Na: true };
  function O3(a, b, c) {
    if (!mf(c, b.N))
      return F3(new t3("internal-error"));
    var d = !!b.Na, e = b.Ub || "POST", f;
    return E3(c).then(b.A).then(function() {
      b.V && (c.returnSecureToken = true);
      b.B && a.b && "undefined" === typeof c.tenantId && (c.tenantId = a.b);
      return d ? Yi2(a, a.i, b.endpoint, e, c, b.Hb, b.lb || false) : Yi2(a, a.h, b.endpoint, e, c, b.Hb, b.lb || false);
    }).then(function(g) {
      f = g;
      return b.Ya ? b.Ya(c, f) : f;
    }).then(b.G).then(function() {
      if (!b.Z)
        return f;
      if (!(b.Z in f))
        throw new t3("internal-error");
      return f[b.Z];
    });
  }
  function wj(a) {
    return Xi2({ error: { errors: [{ message: a }], code: 400, message: a } });
  }
  function Xi2(a, b) {
    var c = (a.error && a.error.errors && a.error.errors[0] || {}).reason || "";
    var d = { keyInvalid: "invalid-api-key", ipRefererBlocked: "app-not-authorized" };
    if (c = d[c] ? new t3(d[c]) : null)
      return c;
    c = a.error && a.error.message || "";
    d = {
      INVALID_CUSTOM_TOKEN: "invalid-custom-token",
      CREDENTIAL_MISMATCH: "custom-token-mismatch",
      MISSING_CUSTOM_TOKEN: "internal-error",
      INVALID_IDENTIFIER: "invalid-email",
      MISSING_CONTINUE_URI: "internal-error",
      INVALID_EMAIL: "invalid-email",
      INVALID_PASSWORD: "wrong-password",
      USER_DISABLED: "user-disabled",
      MISSING_PASSWORD: "internal-error",
      EMAIL_EXISTS: "email-already-in-use",
      PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
      INVALID_IDP_RESPONSE: "invalid-credential",
      INVALID_PENDING_TOKEN: "invalid-credential",
      FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
      MISSING_OR_INVALID_NONCE: "missing-or-invalid-nonce",
      INVALID_MESSAGE_PAYLOAD: "invalid-message-payload",
      INVALID_RECIPIENT_EMAIL: "invalid-recipient-email",
      INVALID_SENDER: "invalid-sender",
      EMAIL_NOT_FOUND: "user-not-found",
      RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
      EXPIRED_OOB_CODE: "expired-action-code",
      INVALID_OOB_CODE: "invalid-action-code",
      MISSING_OOB_CODE: "internal-error",
      INVALID_PROVIDER_ID: "invalid-provider-id",
      CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
      INVALID_ID_TOKEN: "invalid-user-token",
      TOKEN_EXPIRED: "user-token-expired",
      USER_NOT_FOUND: "user-token-expired",
      CORS_UNSUPPORTED: "cors-unsupported",
      DYNAMIC_LINK_NOT_ACTIVATED: "dynamic-link-not-activated",
      INVALID_APP_ID: "invalid-app-id",
      TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
      WEAK_PASSWORD: "weak-password",
      OPERATION_NOT_ALLOWED: "operation-not-allowed",
      USER_CANCELLED: "user-cancelled",
      CAPTCHA_CHECK_FAILED: "captcha-check-failed",
      INVALID_APP_CREDENTIAL: "invalid-app-credential",
      INVALID_CODE: "invalid-verification-code",
      INVALID_PHONE_NUMBER: "invalid-phone-number",
      INVALID_SESSION_INFO: "invalid-verification-id",
      INVALID_TEMPORARY_PROOF: "invalid-credential",
      MISSING_APP_CREDENTIAL: "missing-app-credential",
      MISSING_CODE: "missing-verification-code",
      MISSING_PHONE_NUMBER: "missing-phone-number",
      MISSING_SESSION_INFO: "missing-verification-id",
      QUOTA_EXCEEDED: "quota-exceeded",
      SESSION_EXPIRED: "code-expired",
      REJECTED_CREDENTIAL: "rejected-credential",
      INVALID_CONTINUE_URI: "invalid-continue-uri",
      MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
      MISSING_IOS_BUNDLE_ID: "missing-ios-bundle-id",
      UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
      INVALID_DYNAMIC_LINK_DOMAIN: "invalid-dynamic-link-domain",
      INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
      INVALID_CERT_HASH: "invalid-cert-hash",
      UNSUPPORTED_TENANT_OPERATION: "unsupported-tenant-operation",
      INVALID_TENANT_ID: "invalid-tenant-id",
      TENANT_ID_MISMATCH: "tenant-id-mismatch",
      ADMIN_ONLY_OPERATION: "admin-restricted-operation",
      INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
      MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
      MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
      MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
      EMAIL_CHANGE_NEEDS_VERIFICATION: "email-change-needs-verification",
      SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
      SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
      UNSUPPORTED_FIRST_FACTOR: "unsupported-first-factor",
      UNVERIFIED_EMAIL: "unverified-email"
    };
    z3(d, b || {});
    b = (b = c.match(/^[^\s]+\s*:\s*([\s\S]*)$/)) && 1 < b.length ? b[1] : void 0;
    for (var e in d)
      if (0 === c.indexOf(e))
        return new t3(d[e], b);
    !b && a && (b = Ue2(a));
    return new t3("internal-error", b);
  }
  ;
  function Mj(a) {
    this.b = a;
    this.a = null;
    this.rb = Nj(this);
  }
  function Nj(a) {
    return Oj().then(function() {
      return new D3(function(b, c) {
        L4("gapi.iframes.getContext")().open({ where: document.body, url: a.b, messageHandlersFilter: L4("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"), attributes: { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" } }, dontclear: true }, function(d) {
          function e() {
            clearTimeout(f);
            b();
          }
          a.a = d;
          a.a.restyle({ setHideOnLeave: false });
          var f = setTimeout(function() {
            c(Error("Network Error"));
          }, Pj.get());
          d.ping(e).then(e, function() {
            c(Error("Network Error"));
          });
        });
      });
    });
  }
  function Qj(a, b) {
    return a.rb.then(function() {
      return new D3(function(c) {
        a.a.send(b.type, b, c, L4("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
      });
    });
  }
  function Rj(a, b) {
    a.rb.then(function() {
      a.a.register("authEvent", b, L4("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
    });
  }
  var Sj = new qb2(rb, "https://apis.google.com/js/api.js?onload=%{onload}"), Tj = new Ze2(3e4, 6e4), Pj = new Ze2(5e3, 15e3), Uj = null;
  function Oj() {
    return Uj ? Uj : Uj = new D3(function(a, b) {
      function c() {
        Ye2();
        L4("gapi.load")("gapi.iframes", { callback: a, ontimeout: function() {
          Ye2();
          b(Error("Network Error"));
        }, timeout: Tj.get() });
      }
      if (L4("gapi.iframes.Iframe"))
        a();
      else if (L4("gapi.load"))
        c();
      else {
        var d = "__iframefcb" + Math.floor(1e6 * Math.random()).toString();
        l[d] = function() {
          L4("gapi.load") ? c() : b(Error("Network Error"));
        };
        d = zb2(Sj, { onload: d });
        E3(Bi2(d)).o(function() {
          b(Error("Network Error"));
        });
      }
    }).o(function(a) {
      Uj = null;
      throw a;
    });
  }
  ;
  function Vj(a, b, c, d) {
    this.l = a;
    this.h = b;
    this.i = c;
    this.g = d;
    this.f = null;
    this.g ? (a = J3(this.g.url), a = ce2(a.c, a.a, a.g, "/emulator/auth/iframe")) : a = ce2("https", this.l, null, "/__/auth/iframe");
    this.a = a;
    I3(this.a, "apiKey", this.h);
    I3(this.a, "appName", this.i);
    this.b = null;
    this.c = [];
  }
  Vj.prototype.toString = function() {
    this.f ? I3(this.a, "v", this.f) : ie2(this.a.b, "v");
    this.b ? I3(this.a, "eid", this.b) : ie2(this.a.b, "eid");
    this.c.length ? I3(this.a, "fw", this.c.join(",")) : ie2(this.a.b, "fw");
    return this.a.toString();
  };
  function Wj(a, b, c, d, e, f) {
    this.u = a;
    this.s = b;
    this.c = c;
    this.m = d;
    this.v = f;
    this.i = this.g = this.l = null;
    this.a = e;
    this.h = this.f = null;
  }
  Wj.prototype.yb = function(a) {
    this.h = a;
    return this;
  };
  Wj.prototype.toString = function() {
    if (this.v) {
      var a = J3(this.v.url);
      a = ce2(a.c, a.a, a.g, "/emulator/auth/handler");
    } else
      a = ce2("https", this.u, null, "/__/auth/handler");
    I3(a, "apiKey", this.s);
    I3(a, "appName", this.c);
    I3(a, "authType", this.m);
    if (this.a.isOAuthProvider) {
      var b = this.a;
      try {
        var c = index_esm_default.app(this.c).auth().la();
      } catch (h2) {
        c = null;
      }
      b.ob = c;
      I3(a, "providerId", this.a.providerId);
      c = this.a;
      b = Ve2(c.Ib);
      for (var d in b)
        b[d] = b[d].toString();
      d = c.Qc;
      b = nb2(b);
      for (var e = 0; e < d.length; e++) {
        var f = d[e];
        f in b && delete b[f];
      }
      c.pb && c.ob && !b[c.pb] && (b[c.pb] = c.ob);
      mb2(b) || I3(a, "customParameters", Ue2(b));
    }
    "function" === typeof this.a.Qb && (c = this.a.Qb(), c.length && I3(a, "scopes", c.join(",")));
    this.l ? I3(a, "redirectUrl", this.l) : ie2(a.b, "redirectUrl");
    this.g ? I3(a, "eventId", this.g) : ie2(a.b, "eventId");
    this.i ? I3(a, "v", this.i) : ie2(a.b, "v");
    if (this.b)
      for (var g in this.b)
        this.b.hasOwnProperty(g) && !be2(a, g) && I3(a, g, this.b[g]);
    this.h ? I3(a, "tid", this.h) : ie2(a.b, "tid");
    this.f ? I3(a, "eid", this.f) : ie2(a.b, "eid");
    g = Xj(this.c);
    g.length && I3(a, "fw", g.join(","));
    return a.toString();
  };
  function Xj(a) {
    try {
      return index_esm_default.app(a).auth().Ga();
    } catch (b) {
      return [];
    }
  }
  function Yj(a, b, c, d, e, f) {
    this.s = a;
    this.g = b;
    this.b = c;
    this.f = f;
    this.c = d || null;
    this.i = e || null;
    this.l = this.u = this.C = null;
    this.h = [];
    this.m = this.a = null;
  }
  function Zj(a) {
    var b = re2();
    return cj(a).then(function(c) {
      a: {
        var d = J3(b), e = d.c;
        d = d.a;
        for (var f = 0; f < c.length; f++) {
          var g = c[f];
          var h2 = d;
          var m = e;
          0 == g.indexOf("chrome-extension://") ? h2 = J3(g).a == h2 && "chrome-extension" == m : "http" != m && "https" != m ? h2 = false : Ce2.test(g) ? h2 = h2 == g : (g = g.split(".").join("\\."), h2 = new RegExp("^(.+\\." + g + "|" + g + ")$", "i").test(h2));
          if (h2) {
            c = true;
            break a;
          }
        }
        c = false;
      }
      if (!c)
        throw new xh(re2());
    });
  }
  function ak(a) {
    if (a.m)
      return a.m;
    a.m = Ee2().then(function() {
      if (!a.u) {
        var b = a.c, c = a.i, d = Xj(a.b), e = new Vj(a.s, a.g, a.b, a.f);
        e.f = b;
        e.b = c;
        e.c = Za3(d || []);
        a.u = e.toString();
      }
      a.v = new Mj(a.u);
      bk(a);
    });
    return a.m;
  }
  k3 = Yj.prototype;
  k3.Ob = function(a, b, c) {
    var d = new t3("popup-closed-by-user"), e = new t3("web-storage-unsupported"), f = this, g = false;
    return this.ma().then(function() {
      ck(f).then(function(h2) {
        h2 || (a && ye2(a), b(e), g = true);
      });
    }).o(function() {
    }).then(function() {
      if (!g)
        return Be2(a);
    }).then(function() {
      if (!g)
        return Fd2(c).then(function() {
          b(d);
        });
    });
  };
  k3.Xb = function() {
    var a = K3();
    return !Te2(a) && !Xe2(a);
  };
  k3.Tb = function() {
    return false;
  };
  k3.Mb = function(a, b, c, d, e, f, g, h2) {
    if (!a)
      return F3(new t3("popup-blocked"));
    if (g && !Te2())
      return this.ma().o(function(p2) {
        ye2(a);
        e(p2);
      }), d(), E3();
    this.a || (this.a = Zj(dk(this)));
    var m = this;
    return this.a.then(function() {
      var p2 = m.ma().o(function(v2) {
        ye2(a);
        e(v2);
        throw v2;
      });
      d();
      return p2;
    }).then(function() {
      rh(c);
      if (!g) {
        var p2 = ek(m.s, m.g, m.b, b, c, null, f, m.c, void 0, m.i, h2, m.f);
        se2(p2, a);
      }
    }).o(function(p2) {
      "auth/network-request-failed" == p2.code && (m.a = null);
      throw p2;
    });
  };
  function dk(a) {
    a.l || (a.C = a.c ? Oe2(a.c, Xj(a.b)) : null, a.l = new Ii2(a.g, Ca3(a.i), a.C), a.f && Pi2(a.l, a.f));
    return a.l;
  }
  k3.Nb = function(a, b, c, d) {
    this.a || (this.a = Zj(dk(this)));
    var e = this;
    return this.a.then(function() {
      rh(b);
      var f = ek(e.s, e.g, e.b, a, b, re2(), c, e.c, void 0, e.i, d, e.f);
      se2(f);
    }).o(function(f) {
      "auth/network-request-failed" == f.code && (e.a = null);
      throw f;
    });
  };
  k3.ma = function() {
    var a = this;
    return ak(this).then(function() {
      return a.v.rb;
    }).o(function() {
      a.a = null;
      throw new t3("network-request-failed");
    });
  };
  k3.$b = function() {
    return true;
  };
  function ek(a, b, c, d, e, f, g, h2, m, p2, v2, B2) {
    a = new Wj(a, b, c, d, e, B2);
    a.l = f;
    a.g = g;
    a.i = h2;
    a.b = nb2(m || null);
    a.f = p2;
    return a.yb(v2).toString();
  }
  function bk(a) {
    if (!a.v)
      throw Error("IfcHandler must be initialized!");
    Rj(a.v, function(b) {
      var c = {};
      if (b && b.authEvent) {
        var d = false;
        b = th(b.authEvent);
        for (c = 0; c < a.h.length; c++)
          d = a.h[c](b) || d;
        c = {};
        c.status = d ? "ACK" : "ERROR";
        return E3(c);
      }
      c.status = "ERROR";
      return E3(c);
    });
  }
  function ck(a) {
    var b = { type: "webStorageSupport" };
    return ak(a).then(function() {
      return Qj(a.v, b);
    }).then(function(c) {
      if (c && c.length && "undefined" !== typeof c[0].webStorageSupport)
        return c[0].webStorageSupport;
      throw Error();
    });
  }
  k3.Ea = function(a) {
    this.h.push(a);
  };
  k3.Sa = function(a) {
    Xa3(this.h, function(b) {
      return b == a;
    });
  };
  function fk(a) {
    this.a = a || index_esm_default.INTERNAL.reactNative && index_esm_default.INTERNAL.reactNative.AsyncStorage;
    if (!this.a)
      throw new t3("internal-error", "The React Native compatibility library was not found.");
    this.type = "asyncStorage";
  }
  k3 = fk.prototype;
  k3.get = function(a) {
    return E3(this.a.getItem(a)).then(function(b) {
      return b && We2(b);
    });
  };
  k3.set = function(a, b) {
    return E3(this.a.setItem(a, Ue2(b)));
  };
  k3.U = function(a) {
    return E3(this.a.removeItem(a));
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function gk(a) {
    this.b = a;
    this.a = {};
    this.f = q3(this.c, this);
  }
  var hk = [];
  function ik() {
    var a = Je2() ? self : null;
    w2(hk, function(c) {
      c.b == a && (b = c);
    });
    if (!b) {
      var b = new gk(a);
      hk.push(b);
    }
    return b;
  }
  gk.prototype.c = function(a) {
    var b = a.data.eventType, c = a.data.eventId, d = this.a[b];
    if (d && 0 < d.length) {
      a.ports[0].postMessage({ status: "ack", eventId: c, eventType: b, response: null });
      var e = [];
      w2(d, function(f) {
        e.push(E3().then(function() {
          return f(a.origin, a.data.data);
        }));
      });
      Jc2(e).then(function(f) {
        var g = [];
        w2(f, function(h2) {
          g.push({ fulfilled: h2.Pb, value: h2.value, reason: h2.reason ? h2.reason.message : void 0 });
        });
        w2(g, function(h2) {
          for (var m in h2)
            "undefined" === typeof h2[m] && delete h2[m];
        });
        a.ports[0].postMessage({
          status: "done",
          eventId: c,
          eventType: b,
          response: g
        });
      });
    }
  };
  function jk(a, b, c) {
    mb2(a.a) && a.b.addEventListener("message", a.f);
    "undefined" === typeof a.a[b] && (a.a[b] = []);
    a.a[b].push(c);
  }
  ;
  function kk(a) {
    this.a = a;
  }
  kk.prototype.postMessage = function(a, b) {
    this.a.postMessage(a, b);
  };
  function lk(a) {
    this.c = a;
    this.b = false;
    this.a = [];
  }
  function mk(a, b, c, d) {
    var e, f = c || {}, g, h2, m, p2 = null;
    if (a.b)
      return F3(Error("connection_unavailable"));
    var v2 = d ? 800 : 50, B2 = "undefined" !== typeof MessageChannel ? new MessageChannel() : null;
    return new D3(function(A3, Q3) {
      B2 ? (e = Math.floor(Math.random() * Math.pow(10, 20)).toString(), B2.port1.start(), h2 = setTimeout(function() {
        Q3(Error("unsupported_event"));
      }, v2), g = function(ya2) {
        ya2.data.eventId === e && ("ack" === ya2.data.status ? (clearTimeout(h2), m = setTimeout(function() {
          Q3(Error("timeout"));
        }, 3e3)) : "done" === ya2.data.status ? (clearTimeout(m), "undefined" !== typeof ya2.data.response ? A3(ya2.data.response) : Q3(Error("unknown_error"))) : (clearTimeout(h2), clearTimeout(m), Q3(Error("invalid_response"))));
      }, p2 = { messageChannel: B2, onMessage: g }, a.a.push(p2), B2.port1.addEventListener("message", g), a.c.postMessage({ eventType: b, eventId: e, data: f }, [B2.port2])) : Q3(Error("connection_unavailable"));
    }).then(function(A3) {
      nk(a, p2);
      return A3;
    }).o(function(A3) {
      nk(a, p2);
      throw A3;
    });
  }
  function nk(a, b) {
    if (b) {
      var c = b.messageChannel, d = b.onMessage;
      c && (c.port1.removeEventListener("message", d), c.port1.close());
      Xa3(a.a, function(e) {
        return e == b;
      });
    }
  }
  lk.prototype.close = function() {
    for (; 0 < this.a.length; )
      nk(this, this.a[0]);
    this.b = true;
  };
  function ok() {
    if (!pk())
      throw new t3("web-storage-unsupported");
    this.c = {};
    this.a = [];
    this.b = 0;
    this.m = l.indexedDB;
    this.type = "indexedDB";
    this.g = this.v = this.f = this.l = null;
    this.s = false;
    this.h = null;
    var a = this;
    Je2() && self ? (this.v = ik(), jk(this.v, "keyChanged", function(b, c) {
      return qk(a).then(function(d) {
        0 < d.length && w2(a.a, function(e) {
          e(d);
        });
        return { keyProcessed: Va3(d, c.key) };
      });
    }), jk(this.v, "ping", function() {
      return E3(["keyChanged"]);
    })) : ef().then(function(b) {
      if (a.h = b)
        a.g = new lk(new kk(b)), mk(a.g, "ping", null, true).then(function(c) {
          c[0].fulfilled && Va3(c[0].value, "keyChanged") && (a.s = true);
        }).o(function() {
        });
    });
  }
  var rk;
  function sk(a) {
    return new D3(function(b, c) {
      var d = a.m.deleteDatabase("firebaseLocalStorageDb");
      d.onsuccess = function() {
        b();
      };
      d.onerror = function(e) {
        c(Error(e.target.error));
      };
    });
  }
  function tk(a) {
    return new D3(function(b, c) {
      var d = a.m.open("firebaseLocalStorageDb", 1);
      d.onerror = function(e) {
        try {
          e.preventDefault();
        } catch (f) {
        }
        c(Error(e.target.error));
      };
      d.onupgradeneeded = function(e) {
        e = e.target.result;
        try {
          e.createObjectStore("firebaseLocalStorage", { keyPath: "fbase_key" });
        } catch (f) {
          c(f);
        }
      };
      d.onsuccess = function(e) {
        e = e.target.result;
        e.objectStoreNames.contains("firebaseLocalStorage") ? b(e) : sk(a).then(function() {
          return tk(a);
        }).then(function(f) {
          b(f);
        }).o(function(f) {
          c(f);
        });
      };
    });
  }
  function uk(a) {
    a.i || (a.i = tk(a));
    return a.i;
  }
  function vk(a, b) {
    function c(e, f) {
      uk(a).then(b).then(e).o(function(g) {
        if (3 < ++d)
          f(g);
        else
          return uk(a).then(function(h2) {
            h2.close();
            a.i = void 0;
            return c(e, f);
          }).o(function(h2) {
            f(h2);
          });
      });
    }
    var d = 0;
    return new D3(c);
  }
  function pk() {
    try {
      return !!l.indexedDB;
    } catch (a) {
      return false;
    }
  }
  function wk(a) {
    return a.objectStore("firebaseLocalStorage");
  }
  function xk(a, b) {
    return a.transaction(["firebaseLocalStorage"], b ? "readwrite" : "readonly");
  }
  function yk(a) {
    return new D3(function(b, c) {
      a.onsuccess = function(d) {
        d && d.target ? b(d.target.result) : b();
      };
      a.onerror = function(d) {
        c(d.target.error);
      };
    });
  }
  k3 = ok.prototype;
  k3.set = function(a, b) {
    var c = this, d = false;
    return vk(this, function(e) {
      e = wk(xk(e, true));
      return yk(e.get(a));
    }).then(function(e) {
      return vk(c, function(f) {
        f = wk(xk(f, true));
        if (e)
          return e.value = b, yk(f.put(e));
        c.b++;
        d = true;
        var g = {};
        g.fbase_key = a;
        g.value = b;
        return yk(f.add(g));
      });
    }).then(function() {
      c.c[a] = b;
      return zk(c, a);
    }).oa(function() {
      d && c.b--;
    });
  };
  function zk(a, b) {
    return a.g && a.h && df() === a.h ? mk(a.g, "keyChanged", { key: b }, a.s).then(function() {
    }).o(function() {
    }) : E3();
  }
  k3.get = function(a) {
    return vk(this, function(b) {
      return yk(wk(xk(b, false)).get(a));
    }).then(function(b) {
      return b && b.value;
    });
  };
  k3.U = function(a) {
    var b = this, c = false;
    return vk(this, function(d) {
      c = true;
      b.b++;
      return yk(wk(xk(d, true))["delete"](a));
    }).then(function() {
      delete b.c[a];
      return zk(b, a);
    }).oa(function() {
      c && b.b--;
    });
  };
  function qk(a) {
    return uk(a).then(function(b) {
      var c = wk(xk(b, false));
      return c.getAll ? yk(c.getAll()) : new D3(function(d, e) {
        var f = [], g = c.openCursor();
        g.onsuccess = function(h2) {
          (h2 = h2.target.result) ? (f.push(h2.value), h2["continue"]()) : d(f);
        };
        g.onerror = function(h2) {
          e(h2.target.error);
        };
      });
    }).then(function(b) {
      var c = {}, d = [];
      if (0 == a.b) {
        for (d = 0; d < b.length; d++)
          c[b[d].fbase_key] = b[d].value;
        d = te2(a.c, c);
        a.c = c;
      }
      return d;
    });
  }
  k3.ca = function(a) {
    0 == this.a.length && Ak(this);
    this.a.push(a);
  };
  k3.ia = function(a) {
    Xa3(this.a, function(b) {
      return b == a;
    });
    0 == this.a.length && Bk(this);
  };
  function Ak(a) {
    function b() {
      a.f = setTimeout(function() {
        a.l = qk(a).then(function(c) {
          0 < c.length && w2(a.a, function(d) {
            d(c);
          });
        }).then(function() {
          b();
        }).o(function(c) {
          "STOP_EVENT" != c.message && b();
        });
      }, 800);
    }
    Bk(a);
    b();
  }
  function Bk(a) {
    a.l && a.l.cancel("STOP_EVENT");
    a.f && (clearTimeout(a.f), a.f = null);
  }
  ;
  function Ck(a) {
    var b = this, c = null;
    this.a = [];
    this.type = "indexedDB";
    this.c = a;
    this.b = E3().then(function() {
      if (pk()) {
        var d = Qe2(), e = "__sak" + d;
        rk || (rk = new ok());
        c = rk;
        return c.set(e, d).then(function() {
          return c.get(e);
        }).then(function(f) {
          if (f !== d)
            throw Error("indexedDB not supported!");
          return c.U(e);
        }).then(function() {
          return c;
        }).o(function() {
          return b.c;
        });
      }
      return b.c;
    }).then(function(d) {
      b.type = d.type;
      d.ca(function(e) {
        w2(b.a, function(f) {
          f(e);
        });
      });
      return d;
    });
  }
  k3 = Ck.prototype;
  k3.get = function(a) {
    return this.b.then(function(b) {
      return b.get(a);
    });
  };
  k3.set = function(a, b) {
    return this.b.then(function(c) {
      return c.set(a, b);
    });
  };
  k3.U = function(a) {
    return this.b.then(function(b) {
      return b.U(a);
    });
  };
  k3.ca = function(a) {
    this.a.push(a);
  };
  k3.ia = function(a) {
    Xa3(this.a, function(b) {
      return b == a;
    });
  };
  function Dk() {
    this.a = {};
    this.type = "inMemory";
  }
  k3 = Dk.prototype;
  k3.get = function(a) {
    return E3(this.a[a]);
  };
  k3.set = function(a, b) {
    this.a[a] = b;
    return E3();
  };
  k3.U = function(a) {
    delete this.a[a];
    return E3();
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function Ek() {
    if (!Fk()) {
      if ("Node" == Ke2())
        throw new t3("internal-error", "The LocalStorage compatibility library was not found.");
      throw new t3("web-storage-unsupported");
    }
    this.a = Gk() || index_esm_default.INTERNAL.node.localStorage;
    this.type = "localStorage";
  }
  function Gk() {
    try {
      var a = l.localStorage, b = Qe2();
      a && (a.setItem(b, "1"), a.removeItem(b));
      return a;
    } catch (c) {
      return null;
    }
  }
  function Fk() {
    var a = "Node" == Ke2();
    a = Gk() || a && index_esm_default.INTERNAL.node && index_esm_default.INTERNAL.node.localStorage;
    if (!a)
      return false;
    try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
    } catch (b) {
      return false;
    }
  }
  k3 = Ek.prototype;
  k3.get = function(a) {
    var b = this;
    return E3().then(function() {
      var c = b.a.getItem(a);
      return We2(c);
    });
  };
  k3.set = function(a, b) {
    var c = this;
    return E3().then(function() {
      var d = Ue2(b);
      null === d ? c.U(a) : c.a.setItem(a, d);
    });
  };
  k3.U = function(a) {
    var b = this;
    return E3().then(function() {
      b.a.removeItem(a);
    });
  };
  k3.ca = function(a) {
    l.window && nd2(l.window, "storage", a);
  };
  k3.ia = function(a) {
    l.window && xd2(l.window, "storage", a);
  };
  function Hk() {
    this.type = "nullStorage";
  }
  k3 = Hk.prototype;
  k3.get = function() {
    return E3(null);
  };
  k3.set = function() {
    return E3();
  };
  k3.U = function() {
    return E3();
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function Ik() {
    if (!Jk()) {
      if ("Node" == Ke2())
        throw new t3("internal-error", "The SessionStorage compatibility library was not found.");
      throw new t3("web-storage-unsupported");
    }
    this.a = Kk() || index_esm_default.INTERNAL.node.sessionStorage;
    this.type = "sessionStorage";
  }
  function Kk() {
    try {
      var a = l.sessionStorage, b = Qe2();
      a && (a.setItem(b, "1"), a.removeItem(b));
      return a;
    } catch (c) {
      return null;
    }
  }
  function Jk() {
    var a = "Node" == Ke2();
    a = Kk() || a && index_esm_default.INTERNAL.node && index_esm_default.INTERNAL.node.sessionStorage;
    if (!a)
      return false;
    try {
      return a.setItem("__sak", "1"), a.removeItem("__sak"), true;
    } catch (b) {
      return false;
    }
  }
  k3 = Ik.prototype;
  k3.get = function(a) {
    var b = this;
    return E3().then(function() {
      var c = b.a.getItem(a);
      return We2(c);
    });
  };
  k3.set = function(a, b) {
    var c = this;
    return E3().then(function() {
      var d = Ue2(b);
      null === d ? c.U(a) : c.a.setItem(a, d);
    });
  };
  k3.U = function(a) {
    var b = this;
    return E3().then(function() {
      b.a.removeItem(a);
    });
  };
  k3.ca = function() {
  };
  k3.ia = function() {
  };
  function Lk() {
    var a = {};
    a.Browser = Mk;
    a.Node = Nk;
    a.ReactNative = Ok;
    a.Worker = Pk;
    this.a = a[Ke2()];
  }
  var Qk, Mk = { F: Ek, bb: Ik }, Nk = { F: Ek, bb: Ik }, Ok = { F: fk, bb: Hk }, Pk = { F: Ek, bb: Hk };
  var Rk = { rd: "local", NONE: "none", td: "session" };
  function Sk(a) {
    var b = new t3("invalid-persistence-type"), c = new t3("unsupported-persistence-type");
    a: {
      for (d in Rk)
        if (Rk[d] == a) {
          var d = true;
          break a;
        }
      d = false;
    }
    if (!d || "string" !== typeof a)
      throw b;
    switch (Ke2()) {
      case "ReactNative":
        if ("session" === a)
          throw c;
        break;
      case "Node":
        if ("none" !== a)
          throw c;
        break;
      case "Worker":
        if ("session" === a || !pk() && "none" !== a)
          throw c;
        break;
      default:
        if (!Pe2() && "none" !== a)
          throw c;
    }
  }
  function Tk() {
    var a = !Xe2(K3()) && Ie2() ? true : false, b = Te2(), c = Pe2();
    this.m = a;
    this.h = b;
    this.l = c;
    this.a = {};
    Qk || (Qk = new Lk());
    a = Qk;
    try {
      this.g = !qe2() && cf() || !l.indexedDB ? new a.a.F() : new Ck(Je2() ? new Dk() : new a.a.F());
    } catch (d) {
      this.g = new Dk(), this.h = true;
    }
    try {
      this.i = new a.a.bb();
    } catch (d) {
      this.i = new Dk();
    }
    this.v = new Dk();
    this.f = q3(this.Yb, this);
    this.b = {};
  }
  var Uk;
  function Vk() {
    Uk || (Uk = new Tk());
    return Uk;
  }
  function Wk(a, b) {
    switch (b) {
      case "session":
        return a.i;
      case "none":
        return a.v;
      default:
        return a.g;
    }
  }
  function Xk(a, b) {
    return "firebase:" + a.name + (b ? ":" + b : "");
  }
  function Yk(a, b, c) {
    var d = Xk(b, c), e = Wk(a, b.F);
    return a.get(b, c).then(function(f) {
      var g = null;
      try {
        g = We2(l.localStorage.getItem(d));
      } catch (h2) {
      }
      if (g && !f)
        return l.localStorage.removeItem(d), a.set(b, g, c);
      g && f && "localStorage" != e.type && l.localStorage.removeItem(d);
    });
  }
  k3 = Tk.prototype;
  k3.get = function(a, b) {
    return Wk(this, a.F).get(Xk(a, b));
  };
  function Zk(a, b, c) {
    c = Xk(b, c);
    "local" == b.F && (a.b[c] = null);
    return Wk(a, b.F).U(c);
  }
  k3.set = function(a, b, c) {
    var d = Xk(a, c), e = this, f = Wk(this, a.F);
    return f.set(d, b).then(function() {
      return f.get(d);
    }).then(function(g) {
      "local" == a.F && (e.b[d] = g);
    });
  };
  k3.addListener = function(a, b, c) {
    a = Xk(a, b);
    this.l && (this.b[a] = l.localStorage.getItem(a));
    mb2(this.a) && (Wk(this, "local").ca(this.f), this.h || (qe2() || !cf()) && l.indexedDB || !this.l || $k(this));
    this.a[a] || (this.a[a] = []);
    this.a[a].push(c);
  };
  k3.removeListener = function(a, b, c) {
    a = Xk(a, b);
    this.a[a] && (Xa3(this.a[a], function(d) {
      return d == c;
    }), 0 == this.a[a].length && delete this.a[a]);
    mb2(this.a) && (Wk(this, "local").ia(this.f), al(this));
  };
  function $k(a) {
    al(a);
    a.c = setInterval(function() {
      for (var b in a.a) {
        var c = l.localStorage.getItem(b), d = a.b[b];
        c != d && (a.b[b] = c, c = new bd2({ type: "storage", key: b, target: window, oldValue: d, newValue: c, a: true }), a.Yb(c));
      }
    }, 1e3);
  }
  function al(a) {
    a.c && (clearInterval(a.c), a.c = null);
  }
  k3.Yb = function(a) {
    if (a && a.g) {
      var b = a.a.key;
      if (null == b)
        for (var c in this.a) {
          var d = this.b[c];
          "undefined" === typeof d && (d = null);
          var e = l.localStorage.getItem(c);
          e !== d && (this.b[c] = e, this.mb(c));
        }
      else if (0 == b.indexOf("firebase:") && this.a[b]) {
        "undefined" !== typeof a.a.a ? Wk(this, "local").ia(this.f) : al(this);
        if (this.m) {
          if (c = l.localStorage.getItem(b), d = a.a.newValue, d !== c)
            null !== d ? l.localStorage.setItem(b, d) : l.localStorage.removeItem(b);
          else if (this.b[b] === d && "undefined" === typeof a.a.a)
            return;
        }
        var f = this;
        c = function() {
          if ("undefined" !== typeof a.a.a || f.b[b] !== l.localStorage.getItem(b))
            f.b[b] = l.localStorage.getItem(b), f.mb(b);
        };
        Wb2 && ic3 && 10 == ic3 && l.localStorage.getItem(b) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
      }
    } else
      w2(a, q3(this.mb, this));
  };
  k3.mb = function(a) {
    this.a[a] && w2(this.a[a], function(b) {
      b();
    });
  };
  function bl(a) {
    this.a = a;
    this.b = Vk();
  }
  var cl = { name: "authEvent", F: "local" };
  function dl(a) {
    return a.b.get(cl, a.a).then(function(b) {
      return th(b);
    });
  }
  ;
  function el() {
    this.a = Vk();
  }
  ;
  function fl() {
    this.b = -1;
  }
  ;
  function gl(a, b) {
    this.b = hl;
    this.f = l.Uint8Array ? new Uint8Array(this.b) : Array(this.b);
    this.g = this.c = 0;
    this.a = [];
    this.i = a;
    this.h = b;
    this.l = l.Int32Array ? new Int32Array(64) : Array(64);
    void 0 === il && (l.Int32Array ? il = new Int32Array(jl) : il = jl);
    this.reset();
  }
  var il;
  r2(gl, fl);
  for (var hl = 64, kl = hl - 1, ll = [], ml = 0; ml < kl; ml++)
    ll[ml] = 0;
  var nl = Ya3(128, ll);
  gl.prototype.reset = function() {
    this.g = this.c = 0;
    this.a = l.Int32Array ? new Int32Array(this.h) : Za3(this.h);
  };
  function ol(a) {
    for (var b = a.f, c = a.l, d = 0, e = 0; e < b.length; )
      c[d++] = b[e] << 24 | b[e + 1] << 16 | b[e + 2] << 8 | b[e + 3], e = 4 * d;
    for (b = 16; 64 > b; b++) {
      e = c[b - 15] | 0;
      d = c[b - 2] | 0;
      var f = (c[b - 16] | 0) + ((e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3) | 0, g = (c[b - 7] | 0) + ((d >>> 17 | d << 15) ^ (d >>> 19 | d << 13) ^ d >>> 10) | 0;
      c[b] = f + g | 0;
    }
    d = a.a[0] | 0;
    e = a.a[1] | 0;
    var h2 = a.a[2] | 0, m = a.a[3] | 0, p2 = a.a[4] | 0, v2 = a.a[5] | 0, B2 = a.a[6] | 0;
    f = a.a[7] | 0;
    for (b = 0; 64 > b; b++) {
      var A3 = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & e ^ d & h2 ^ e & h2) | 0;
      g = p2 & v2 ^ ~p2 & B2;
      f = f + ((p2 >>> 6 | p2 << 26) ^ (p2 >>> 11 | p2 << 21) ^ (p2 >>> 25 | p2 << 7)) | 0;
      g = g + (il[b] | 0) | 0;
      g = f + (g + (c[b] | 0) | 0) | 0;
      f = B2;
      B2 = v2;
      v2 = p2;
      p2 = m + g | 0;
      m = h2;
      h2 = e;
      e = d;
      d = g + A3 | 0;
    }
    a.a[0] = a.a[0] + d | 0;
    a.a[1] = a.a[1] + e | 0;
    a.a[2] = a.a[2] + h2 | 0;
    a.a[3] = a.a[3] + m | 0;
    a.a[4] = a.a[4] + p2 | 0;
    a.a[5] = a.a[5] + v2 | 0;
    a.a[6] = a.a[6] + B2 | 0;
    a.a[7] = a.a[7] + f | 0;
  }
  function pl(a, b, c) {
    void 0 === c && (c = b.length);
    var d = 0, e = a.c;
    if ("string" === typeof b)
      for (; d < c; )
        a.f[e++] = b.charCodeAt(d++), e == a.b && (ol(a), e = 0);
    else if (na3(b))
      for (; d < c; ) {
        var f = b[d++];
        if (!("number" == typeof f && 0 <= f && 255 >= f && f == (f | 0)))
          throw Error("message must be a byte array");
        a.f[e++] = f;
        e == a.b && (ol(a), e = 0);
      }
    else
      throw Error("message must be string or array");
    a.c = e;
    a.g += c;
  }
  var jl = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ql() {
    gl.call(this, 8, rl);
  }
  r2(ql, gl);
  var rl = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
  function sl(a, b, c, d, e, f) {
    this.v = a;
    this.i = b;
    this.l = c;
    this.m = d || null;
    this.u = e || null;
    this.s = f;
    this.h = b + ":" + c;
    this.C = new el();
    this.g = new bl(this.h);
    this.f = null;
    this.b = [];
    this.a = this.c = null;
  }
  function tl(a) {
    return new t3("invalid-cordova-configuration", a);
  }
  k3 = sl.prototype;
  k3.ma = function() {
    return this.Ia ? this.Ia : this.Ia = Fe2().then(function() {
      if ("function" !== typeof L4("universalLinks.subscribe", l))
        throw tl("cordova-universal-links-plugin-fix is not installed");
      if ("undefined" === typeof L4("BuildInfo.packageName", l))
        throw tl("cordova-plugin-buildinfo is not installed");
      if ("function" !== typeof L4("cordova.plugins.browsertab.openUrl", l))
        throw tl("cordova-plugin-browsertab is not installed");
      if ("function" !== typeof L4("cordova.InAppBrowser.open", l))
        throw tl("cordova-plugin-inappbrowser is not installed");
    }, function() {
      throw new t3("cordova-not-ready");
    });
  };
  function ul() {
    for (var a = 20, b = []; 0 < a; )
      b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), a--;
    return b.join("");
  }
  function vl(a) {
    var b = new ql();
    pl(b, a);
    a = [];
    var c = 8 * b.g;
    56 > b.c ? pl(b, nl, 56 - b.c) : pl(b, nl, b.b - (b.c - 56));
    for (var d = 63; 56 <= d; d--)
      b.f[d] = c & 255, c /= 256;
    ol(b);
    for (d = c = 0; d < b.i; d++)
      for (var e = 24; 0 <= e; e -= 8)
        a[c++] = b.a[d] >> e & 255;
    return cg(a);
  }
  k3.Ob = function(a, b) {
    b(new t3("operation-not-supported-in-this-environment"));
    return E3();
  };
  k3.Mb = function() {
    return F3(new t3("operation-not-supported-in-this-environment"));
  };
  k3.$b = function() {
    return false;
  };
  k3.Xb = function() {
    return true;
  };
  k3.Tb = function() {
    return true;
  };
  k3.Nb = function(a, b, c, d) {
    if (this.c)
      return F3(new t3("redirect-operation-pending"));
    var e = this, f = l.document, g = null, h2 = null, m = null, p2 = null;
    return this.c = E3().then(function() {
      rh(b);
      return wl(e);
    }).then(function() {
      return xl(e, a, b, c, d);
    }).then(function() {
      return new D3(function(v2, B2) {
        h2 = function() {
          var A3 = L4("cordova.plugins.browsertab.close", l);
          v2();
          "function" === typeof A3 && A3();
          e.a && "function" === typeof e.a.close && (e.a.close(), e.a = null);
          return false;
        };
        e.Ea(h2);
        m = function() {
          g || (g = Fd2(2e3).then(function() {
            B2(new t3("redirect-cancelled-by-user"));
          }));
        };
        p2 = function() {
          $e2() && m();
        };
        f.addEventListener("resume", m, false);
        K3().toLowerCase().match(/android/) || f.addEventListener("visibilitychange", p2, false);
      }).o(function(v2) {
        return yl(e).then(function() {
          throw v2;
        });
      });
    }).oa(function() {
      m && f.removeEventListener("resume", m, false);
      p2 && f.removeEventListener("visibilitychange", p2, false);
      g && g.cancel();
      h2 && e.Sa(h2);
      e.c = null;
    });
  };
  function xl(a, b, c, d, e) {
    var f = ul(), g = new sh(b, d, null, f, new t3("no-auth-event"), null, e), h2 = L4("BuildInfo.packageName", l);
    if ("string" !== typeof h2)
      throw new t3("invalid-cordova-configuration");
    var m = L4("BuildInfo.displayName", l), p2 = {};
    if (K3().toLowerCase().match(/iphone|ipad|ipod/))
      p2.ibi = h2;
    else if (K3().toLowerCase().match(/android/))
      p2.apn = h2;
    else
      return F3(new t3("operation-not-supported-in-this-environment"));
    m && (p2.appDisplayName = m);
    f = vl(f);
    p2.sessionId = f;
    var v2 = ek(a.v, a.i, a.l, b, c, null, d, a.m, p2, a.u, e, a.s);
    return a.ma().then(function() {
      var B2 = a.h;
      return a.C.a.set(cl, g.w(), B2);
    }).then(function() {
      var B2 = L4("cordova.plugins.browsertab.isAvailable", l);
      if ("function" !== typeof B2)
        throw new t3("invalid-cordova-configuration");
      var A3 = null;
      B2(function(Q3) {
        if (Q3) {
          A3 = L4("cordova.plugins.browsertab.openUrl", l);
          if ("function" !== typeof A3)
            throw new t3("invalid-cordova-configuration");
          A3(v2);
        } else {
          A3 = L4("cordova.InAppBrowser.open", l);
          if ("function" !== typeof A3)
            throw new t3("invalid-cordova-configuration");
          Q3 = K3();
          a.a = A3(v2, Q3.match(/(iPad|iPhone|iPod).*OS 7_\d/i) || Q3.match(/(iPad|iPhone|iPod).*OS 8_\d/i) ? "_blank" : "_system", "location=yes");
        }
      });
    });
  }
  function zl(a, b) {
    for (var c = 0; c < a.b.length; c++)
      try {
        a.b[c](b);
      } catch (d) {
      }
  }
  function wl(a) {
    a.f || (a.f = a.ma().then(function() {
      return new D3(function(b) {
        function c(d) {
          b(d);
          a.Sa(c);
          return false;
        }
        a.Ea(c);
        Al(a);
      });
    }));
    return a.f;
  }
  function yl(a) {
    var b = null;
    return dl(a.g).then(function(c) {
      b = c;
      c = a.g;
      return Zk(c.b, cl, c.a);
    }).then(function() {
      return b;
    });
  }
  function Al(a) {
    function b(g) {
      d = true;
      e && e.cancel();
      yl(a).then(function(h2) {
        var m = c;
        if (h2 && g && g.url) {
          var p2 = null;
          m = xg(g.url);
          -1 != m.indexOf("/__/auth/callback") && (p2 = J3(m), p2 = We2(be2(p2, "firebaseError") || null), p2 = (p2 = "object" === typeof p2 ? Aa3(p2) : null) ? new sh(h2.c, h2.b, null, null, p2, null, h2.T()) : new sh(h2.c, h2.b, m, h2.f, null, null, h2.T()));
          m = p2 || c;
        }
        zl(a, m);
      });
    }
    var c = new sh("unknown", null, null, null, new t3("no-auth-event")), d = false, e = Fd2(500).then(function() {
      return yl(a).then(function() {
        d || zl(a, c);
      });
    }), f = l.handleOpenURL;
    l.handleOpenURL = function(g) {
      0 == g.toLowerCase().indexOf(L4("BuildInfo.packageName", l).toLowerCase() + "://") && b({ url: g });
      if ("function" === typeof f)
        try {
          f(g);
        } catch (h2) {
          console.error(h2);
        }
    };
    vh || (vh = new uh());
    wh(b);
  }
  k3.Ea = function(a) {
    this.b.push(a);
    wl(this).o(function(b) {
      "auth/invalid-cordova-configuration" === b.code && (b = new sh("unknown", null, null, null, new t3("no-auth-event")), a(b));
    });
  };
  k3.Sa = function(a) {
    Xa3(this.b, function(b) {
      return b == a;
    });
  };
  function Bl(a) {
    this.a = a;
    this.b = Vk();
  }
  var Cl = { name: "pendingRedirect", F: "session" };
  function Dl(a) {
    return a.b.set(Cl, "pending", a.a);
  }
  function El(a) {
    return Zk(a.b, Cl, a.a);
  }
  function Fl(a) {
    return a.b.get(Cl, a.a).then(function(b) {
      return "pending" == b;
    });
  }
  ;
  function Gl(a, b, c, d) {
    this.i = {};
    this.u = 0;
    this.D = a;
    this.v = b;
    this.m = c;
    this.J = d;
    this.h = [];
    this.f = false;
    this.l = q3(this.s, this);
    this.b = new Hl();
    this.C = new Il();
    this.g = new Bl(Jl(this.v, this.m));
    this.c = {};
    this.c.unknown = this.b;
    this.c.signInViaRedirect = this.b;
    this.c.linkViaRedirect = this.b;
    this.c.reauthViaRedirect = this.b;
    this.c.signInViaPopup = this.C;
    this.c.linkViaPopup = this.C;
    this.c.reauthViaPopup = this.C;
    this.a = Kl(this.D, this.v, this.m, Da3, this.J);
  }
  function Kl(a, b, c, d, e) {
    var f = index_esm_default.SDK_VERSION || null;
    return Ge2() ? new sl(a, b, c, f, d, e) : new Yj(a, b, c, f, d, e);
  }
  Gl.prototype.reset = function() {
    this.f = false;
    this.a.Sa(this.l);
    this.a = Kl(this.D, this.v, this.m, null, this.J);
    this.i = {};
  };
  function Ll(a) {
    a.f || (a.f = true, a.a.Ea(a.l));
    var b = a.a;
    return a.a.ma().o(function(c) {
      a.a == b && a.reset();
      throw c;
    });
  }
  function Ml(a) {
    a.a.Xb() && Ll(a).o(function(b) {
      var c = new sh("unknown", null, null, null, new t3("operation-not-supported-in-this-environment"));
      Nl(b) && a.s(c);
    });
    a.a.Tb() || Ol(a.b);
  }
  function Pl(a, b) {
    Va3(a.h, b) || a.h.push(b);
    a.f || Fl(a.g).then(function(c) {
      c ? El(a.g).then(function() {
        Ll(a).o(function(d) {
          var e = new sh("unknown", null, null, null, new t3("operation-not-supported-in-this-environment"));
          Nl(d) && a.s(e);
        });
      }) : Ml(a);
    }).o(function() {
      Ml(a);
    });
  }
  function Ql(a, b) {
    Xa3(a.h, function(c) {
      return c == b;
    });
  }
  Gl.prototype.s = function(a) {
    if (!a)
      throw new t3("invalid-auth-event");
    6e5 <= va2() - this.u && (this.i = {}, this.u = 0);
    if (a && a.getUid() && this.i.hasOwnProperty(a.getUid()))
      return false;
    for (var b = false, c = 0; c < this.h.length; c++) {
      var d = this.h[c];
      if (d.Fb(a.c, a.b)) {
        if (b = this.c[a.c])
          b.h(a, d), a && (a.f || a.b) && (this.i[a.getUid()] = true, this.u = va2());
        b = true;
        break;
      }
    }
    Ol(this.b);
    return b;
  };
  var Rl = new Ze2(2e3, 1e4), Sl = new Ze2(3e4, 6e4);
  Gl.prototype.qa = function() {
    return this.b.qa();
  };
  function Tl(a, b, c, d, e, f, g) {
    return a.a.Mb(b, c, d, function() {
      a.f || (a.f = true, a.a.Ea(a.l));
    }, function() {
      a.reset();
    }, e, f, g);
  }
  function Nl(a) {
    return a && "auth/cordova-not-ready" == a.code ? true : false;
  }
  function Ul(a, b, c, d, e) {
    var f;
    return Dl(a.g).then(function() {
      return a.a.Nb(b, c, d, e).o(function(g) {
        if (Nl(g))
          throw new t3("operation-not-supported-in-this-environment");
        f = g;
        return El(a.g).then(function() {
          throw f;
        });
      }).then(function() {
        return a.a.$b() ? new D3(function() {
        }) : El(a.g).then(function() {
          return a.qa();
        }).then(function() {
        }).o(function() {
        });
      });
    });
  }
  function Vl(a, b, c, d, e) {
    return a.a.Ob(d, function(f) {
      b.na(c, null, f, e);
    }, Rl.get());
  }
  var Wl = {};
  function Jl(a, b, c) {
    a = a + ":" + b;
    c && (a = a + ":" + c.url);
    return a;
  }
  function Xl(a, b, c, d) {
    var e = Jl(b, c, d);
    Wl[e] || (Wl[e] = new Gl(a, b, c, d));
    return Wl[e];
  }
  function Hl() {
    this.b = null;
    this.f = [];
    this.c = [];
    this.a = null;
    this.i = this.g = false;
  }
  Hl.prototype.reset = function() {
    this.b = null;
    this.a && (this.a.cancel(), this.a = null);
  };
  Hl.prototype.h = function(a, b) {
    if (a) {
      this.reset();
      this.g = true;
      var c = a.c, d = a.b, e = a.a && "auth/web-storage-unsupported" == a.a.code, f = a.a && "auth/operation-not-supported-in-this-environment" == a.a.code;
      this.i = !(!e && !f);
      "unknown" != c || e || f ? a.a ? (Yl(this, true, null, a.a), E3()) : b.Fa(c, d) ? Zl(this, a, b) : F3(new t3("invalid-auth-event")) : (Yl(this, false, null, null), E3());
    } else
      F3(new t3("invalid-auth-event"));
  };
  function Ol(a) {
    a.g || (a.g = true, Yl(a, false, null, null));
  }
  function $l(a) {
    a.g && !a.i && Yl(a, false, null, null);
  }
  function Zl(a, b, c) {
    c = c.Fa(b.c, b.b);
    var d = b.g, e = b.f, f = b.i, g = b.T(), h2 = !!b.c.match(/Redirect$/);
    c(d, e, g, f).then(function(m) {
      Yl(a, h2, m, null);
    }).o(function(m) {
      Yl(a, h2, null, m);
    });
  }
  function am(a, b) {
    a.b = function() {
      return F3(b);
    };
    if (a.c.length)
      for (var c = 0; c < a.c.length; c++)
        a.c[c](b);
  }
  function bm(a, b) {
    a.b = function() {
      return E3(b);
    };
    if (a.f.length)
      for (var c = 0; c < a.f.length; c++)
        a.f[c](b);
  }
  function Yl(a, b, c, d) {
    b ? d ? am(a, d) : bm(a, c) : bm(a, { user: null });
    a.f = [];
    a.c = [];
  }
  Hl.prototype.qa = function() {
    var a = this;
    return new D3(function(b, c) {
      a.b ? a.b().then(b, c) : (a.f.push(b), a.c.push(c), cm(a));
    });
  };
  function cm(a) {
    var b = new t3("timeout");
    a.a && a.a.cancel();
    a.a = Fd2(Sl.get()).then(function() {
      a.b || (a.g = true, Yl(a, true, null, b));
    });
  }
  function Il() {
  }
  Il.prototype.h = function(a, b) {
    if (a) {
      var c = a.c, d = a.b;
      a.a ? (b.na(a.c, null, a.a, a.b), E3()) : b.Fa(c, d) ? dm(a, b) : F3(new t3("invalid-auth-event"));
    } else
      F3(new t3("invalid-auth-event"));
  };
  function dm(a, b) {
    var c = a.b, d = a.c;
    b.Fa(d, c)(a.g, a.f, a.T(), a.i).then(function(e) {
      b.na(d, e, null, c);
    }).o(function(e) {
      b.na(d, null, e, c);
    });
  }
  ;
  function em() {
    this.ib = false;
    Object.defineProperty(this, "appVerificationDisabled", { get: function() {
      return this.ib;
    }, set: function(a) {
      this.ib = a;
    }, enumerable: false });
  }
  ;
  function fm(a, b) {
    this.a = b;
    M3(this, "verificationId", a);
  }
  fm.prototype.confirm = function(a) {
    a = ph(this.verificationId, a);
    return this.a(a);
  };
  function gm(a, b, c, d) {
    return new lh(a).fb(b, c).then(function(e) {
      return new fm(e, d);
    });
  }
  ;
  function hm(a) {
    var b = ig(a);
    if (!(b && b.exp && b.auth_time && b.iat))
      throw new t3("internal-error", "An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.");
    N3(this, { token: a, expirationTime: bf(1e3 * b.exp), authTime: bf(1e3 * b.auth_time), issuedAtTime: bf(1e3 * b.iat), signInProvider: b.firebase && b.firebase.sign_in_provider ? b.firebase.sign_in_provider : null, signInSecondFactor: b.firebase && b.firebase.sign_in_second_factor ? b.firebase.sign_in_second_factor : null, claims: b });
  }
  ;
  function im(a, b, c) {
    var d = b && b[jm];
    if (!d)
      throw new t3("argument-error", "Internal assert: Invalid MultiFactorResolver");
    this.a = a;
    this.f = nb2(b);
    this.g = c;
    this.c = new yg(null, d);
    this.b = [];
    var e = this;
    w2(b[km] || [], function(f) {
      (f = tf(f)) && e.b.push(f);
    });
    M3(this, "auth", this.a);
    M3(this, "session", this.c);
    M3(this, "hints", this.b);
  }
  var km = "mfaInfo", jm = "mfaPendingCredential";
  im.prototype.Rc = function(a) {
    var b = this;
    return a.sb(this.a.a, this.c).then(function(c) {
      var d = nb2(b.f);
      delete d[km];
      delete d[jm];
      z3(d, c);
      return b.g(d);
    });
  };
  function lm(a, b, c, d) {
    t3.call(this, "multi-factor-auth-required", d, b);
    this.b = new im(a, b, c);
    M3(this, "resolver", this.b);
  }
  r2(lm, t3);
  function mm(a, b, c) {
    if (a && n2(a.serverResponse) && "auth/multi-factor-auth-required" === a.code)
      try {
        return new lm(b, a.serverResponse, c, a.message);
      } catch (d) {
      }
    return null;
  }
  ;
  function nm() {
  }
  nm.prototype.sb = function(a, b, c) {
    return b.type == zg ? om(this, a, b, c) : pm(this, a, b);
  };
  function om(a, b, c, d) {
    return c.Ha().then(function(e) {
      e = { idToken: e };
      "undefined" !== typeof d && (e.displayName = d);
      z3(e, { phoneVerificationInfo: hh(a.a) });
      return O3(b, Gj, e);
    });
  }
  function pm(a, b, c) {
    return c.Ha().then(function(d) {
      d = { mfaPendingCredential: d };
      z3(d, { phoneVerificationInfo: hh(a.a) });
      return O3(b, Hj, d);
    });
  }
  function qm(a) {
    M3(this, "factorId", a.fa);
    this.a = a;
  }
  r2(qm, nm);
  function rm(a) {
    qm.call(this, a);
    if (this.a.fa != lh.PROVIDER_ID)
      throw new t3("argument-error", "firebase.auth.PhoneMultiFactorAssertion requires a valid firebase.auth.PhoneAuthCredential");
  }
  r2(rm, qm);
  function sm(a, b) {
    G3.call(this, a);
    for (var c in b)
      this[c] = b[c];
  }
  r2(sm, G3);
  function tm(a, b) {
    this.a = a;
    this.b = [];
    this.c = q3(this.yc, this);
    nd2(this.a, "userReloaded", this.c);
    var c = [];
    b && b.multiFactor && b.multiFactor.enrolledFactors && w2(b.multiFactor.enrolledFactors, function(d) {
      var e = null, f = {};
      if (d) {
        d.uid && (f[qf] = d.uid);
        d.displayName && (f[rf] = d.displayName);
        d.enrollmentTime && (f[sf] = new Date(d.enrollmentTime).toISOString());
        d.phoneNumber && (f[pf] = d.phoneNumber);
        try {
          e = new uf(f);
        } catch (g) {
        }
        d = e;
      } else
        d = null;
      d && c.push(d);
    });
    um(this, c);
  }
  function vm(a) {
    var b = [];
    w2(a.mfaInfo || [], function(c) {
      (c = tf(c)) && b.push(c);
    });
    return b;
  }
  k3 = tm.prototype;
  k3.yc = function(a) {
    um(this, vm(a.hd));
  };
  function um(a, b) {
    a.b = b;
    M3(a, "enrolledFactors", b);
  }
  k3.Rb = function() {
    return this.a.I().then(function(a) {
      return new yg(a, null);
    });
  };
  k3.fc = function(a, b) {
    var c = this, d = this.a.a;
    return this.Rb().then(function(e) {
      return a.sb(d, e, b);
    }).then(function(e) {
      wm(c.a, e);
      return c.a.reload();
    });
  };
  k3.bd = function(a) {
    var b = this, c = "string" === typeof a ? a : a.uid, d = this.a.a;
    return this.a.I().then(function(e) {
      return O3(d, Lj, { idToken: e, mfaEnrollmentId: c });
    }).then(function(e) {
      var f = Qa3(b.b, function(g) {
        return g.uid != c;
      });
      um(b, f);
      wm(b.a, e);
      return b.a.reload().o(function(g) {
        if ("auth/user-token-expired" != g.code)
          throw g;
      });
    });
  };
  k3.w = function() {
    return { multiFactor: { enrolledFactors: Ra3(this.b, function(a) {
      return a.w();
    }) } };
  };
  function xm(a, b, c) {
    this.h = a;
    this.i = b;
    this.g = c;
    this.c = 3e4;
    this.f = 96e4;
    this.b = null;
    this.a = this.c;
    if (this.f < this.c)
      throw Error("Proactive refresh lower bound greater than upper bound!");
  }
  xm.prototype.start = function() {
    this.a = this.c;
    ym(this, true);
  };
  function zm(a, b) {
    if (b)
      return a.a = a.c, a.g();
    b = a.a;
    a.a *= 2;
    a.a > a.f && (a.a = a.f);
    return b;
  }
  function ym(a, b) {
    a.stop();
    a.b = Fd2(zm(a, b)).then(function() {
      return af();
    }).then(function() {
      return a.h();
    }).then(function() {
      ym(a, true);
    }).o(function(c) {
      a.i(c) && ym(a, false);
    });
  }
  xm.prototype.stop = function() {
    this.b && (this.b.cancel(), this.b = null);
  };
  function Am(a) {
    this.f = a;
    this.b = this.a = null;
    this.c = Date.now();
  }
  Am.prototype.w = function() {
    return { apiKey: this.f.c, refreshToken: this.a, accessToken: this.b && this.b.toString(), expirationTime: this.c };
  };
  function Bm(a, b) {
    "undefined" === typeof b && (a.b ? (b = a.b, b = b.a - b.g) : b = 0);
    a.c = Date.now() + 1e3 * b;
  }
  function Cm(a, b) {
    a.b = jg(b[Dg] || "");
    a.a = b.refreshToken;
    b = b.expiresIn;
    Bm(a, "undefined" !== typeof b ? Number(b) : void 0);
  }
  function Dm(a, b) {
    a.b = b.b;
    a.a = b.a;
    a.c = b.c;
  }
  function Em(a, b) {
    return Wi2(a.f, b).then(function(c) {
      a.b = jg(c.access_token);
      a.a = c.refresh_token;
      Bm(a, c.expires_in);
      return { accessToken: a.b.toString(), refreshToken: a.a };
    }).o(function(c) {
      "auth/user-token-expired" == c.code && (a.a = null);
      throw c;
    });
  }
  Am.prototype.getToken = function(a) {
    a = !!a;
    return this.b && !this.a ? F3(new t3("user-token-expired")) : a || !this.b || Date.now() > this.c - 3e4 ? this.a ? Em(this, { grant_type: "refresh_token", refresh_token: this.a }) : E3(null) : E3({ accessToken: this.b.toString(), refreshToken: this.a });
  };
  function Fm(a, b) {
    this.a = a || null;
    this.b = b || null;
    N3(this, { lastSignInTime: bf(b || null), creationTime: bf(a || null) });
  }
  function Gm(a) {
    return new Fm(a.a, a.b);
  }
  Fm.prototype.w = function() {
    return { lastLoginAt: this.b, createdAt: this.a };
  };
  function Hm(a, b, c, d, e, f) {
    N3(this, { uid: a, displayName: d || null, photoURL: e || null, email: c || null, phoneNumber: f || null, providerId: b });
  }
  function Im(a, b, c) {
    this.J = [];
    this.l = a.apiKey;
    this.m = a.appName;
    this.s = a.authDomain || null;
    var d = index_esm_default.SDK_VERSION ? Oe2(index_esm_default.SDK_VERSION) : null;
    this.a = new Ii2(this.l, Ca3(Da3), d);
    a.emulatorConfig && Pi2(this.a, a.emulatorConfig);
    this.b = new Am(this.a);
    Jm(this, b[Dg]);
    Cm(this.b, b);
    M3(this, "refreshToken", this.b.a);
    Km(this, c || {});
    H3.call(this);
    this.R = false;
    this.s && Re2() && (this.i = Xl(this.s, this.l, this.m));
    this.S = [];
    this.h = null;
    this.u = Lm(this);
    this.aa = q3(this.hb, this);
    var e = this;
    this.ya = null;
    this.Oa = function(f) {
      e.wa(f.h);
    };
    this.ja = null;
    this.Aa = function(f) {
      Pi2(e.a, f.c);
    };
    this.X = null;
    this.$ = [];
    this.Ba = function(f) {
      Mm(e, f.f);
    };
    this.ba = null;
    this.O = new tm(this, c);
    M3(this, "multiFactor", this.O);
  }
  r2(Im, H3);
  Im.prototype.wa = function(a) {
    this.ya = a;
    Oi2(this.a, a);
  };
  Im.prototype.la = function() {
    return this.ya;
  };
  function Nm(a, b) {
    a.ja && xd2(a.ja, "languageCodeChanged", a.Oa);
    (a.ja = b) && nd2(b, "languageCodeChanged", a.Oa);
  }
  function Om(a, b) {
    a.X && xd2(a.X, "emulatorConfigChanged", a.Aa);
    (a.X = b) && nd2(b, "emulatorConfigChanged", a.Aa);
  }
  function Mm(a, b) {
    a.$ = b;
    Ri2(a.a, index_esm_default.SDK_VERSION ? Oe2(index_esm_default.SDK_VERSION, a.$) : null);
  }
  Im.prototype.Ga = function() {
    return Za3(this.$);
  };
  function Pm(a, b) {
    a.ba && xd2(a.ba, "frameworkChanged", a.Ba);
    (a.ba = b) && nd2(b, "frameworkChanged", a.Ba);
  }
  Im.prototype.hb = function() {
    this.u.b && (this.u.stop(), this.u.start());
  };
  function Qm(a) {
    try {
      return index_esm_default.app(a.m).auth();
    } catch (b) {
      throw new t3("internal-error", "No firebase.auth.Auth instance is available for the Firebase App '" + a.m + "'!");
    }
  }
  function Lm(a) {
    return new xm(function() {
      return a.I(true);
    }, function(b) {
      return b && "auth/network-request-failed" == b.code ? true : false;
    }, function() {
      var b = a.b.c - Date.now() - 3e5;
      return 0 < b ? b : 0;
    });
  }
  function Rm(a) {
    a.D || a.u.b || (a.u.start(), xd2(a, "tokenChanged", a.aa), nd2(a, "tokenChanged", a.aa));
  }
  function Sm(a) {
    xd2(a, "tokenChanged", a.aa);
    a.u.stop();
  }
  function Jm(a, b) {
    a.za = b;
    M3(a, "_lat", b);
  }
  function Tm(a, b) {
    Xa3(a.S, function(c) {
      return c == b;
    });
  }
  function Um(a) {
    for (var b = [], c = 0; c < a.S.length; c++)
      b.push(a.S[c](a));
    return Jc2(b).then(function() {
      return a;
    });
  }
  function Vm(a) {
    a.i && !a.R && (a.R = true, Pl(a.i, a));
  }
  function Km(a, b) {
    N3(a, { uid: b.uid, displayName: b.displayName || null, photoURL: b.photoURL || null, email: b.email || null, emailVerified: b.emailVerified || false, phoneNumber: b.phoneNumber || null, isAnonymous: b.isAnonymous || false, tenantId: b.tenantId || null, metadata: new Fm(b.createdAt, b.lastLoginAt), providerData: [] });
    a.a.b = a.tenantId;
  }
  M3(Im.prototype, "providerId", "firebase");
  function Wm() {
  }
  function Xm(a) {
    return E3().then(function() {
      if (a.D)
        throw new t3("app-deleted");
    });
  }
  function Ym(a) {
    return Ra3(a.providerData, function(b) {
      return b.providerId;
    });
  }
  function Zm(a, b) {
    b && ($m(a, b.providerId), a.providerData.push(b));
  }
  function $m(a, b) {
    Xa3(a.providerData, function(c) {
      return c.providerId == b;
    });
  }
  function an2(a, b, c) {
    ("uid" != b || c) && a.hasOwnProperty(b) && M3(a, b, c);
  }
  function bn2(a, b) {
    a != b && (N3(a, { uid: b.uid, displayName: b.displayName, photoURL: b.photoURL, email: b.email, emailVerified: b.emailVerified, phoneNumber: b.phoneNumber, isAnonymous: b.isAnonymous, tenantId: b.tenantId, providerData: [] }), b.metadata ? M3(a, "metadata", Gm(b.metadata)) : M3(a, "metadata", new Fm()), w2(b.providerData, function(c) {
      Zm(a, c);
    }), Dm(a.b, b.b), M3(a, "refreshToken", a.b.a), um(a.O, b.O.b));
  }
  k3 = Im.prototype;
  k3.reload = function() {
    var a = this;
    return R3(this, Xm(this).then(function() {
      return cn2(a).then(function() {
        return Um(a);
      }).then(Wm);
    }));
  };
  function cn2(a) {
    return a.I().then(function(b) {
      var c = a.isAnonymous;
      return dn2(a, b).then(function() {
        c || an2(a, "isAnonymous", false);
        return b;
      });
    });
  }
  k3.oc = function(a) {
    return this.I(a).then(function(b) {
      return new hm(b);
    });
  };
  k3.I = function(a) {
    var b = this;
    return R3(this, Xm(this).then(function() {
      return b.b.getToken(a);
    }).then(function(c) {
      if (!c)
        throw new t3("internal-error");
      c.accessToken != b.za && (Jm(b, c.accessToken), b.dispatchEvent(new sm("tokenChanged")));
      an2(b, "refreshToken", c.refreshToken);
      return c.accessToken;
    }));
  };
  function wm(a, b) {
    b[Dg] && a.za != b[Dg] && (Cm(a.b, b), a.dispatchEvent(new sm("tokenChanged")), Jm(a, b[Dg]), an2(a, "refreshToken", a.b.a));
  }
  function dn2(a, b) {
    return O3(a.a, Ij, { idToken: b }).then(q3(a.Kc, a));
  }
  k3.Kc = function(a) {
    a = a.users;
    if (!a || !a.length)
      throw new t3("internal-error");
    a = a[0];
    Km(this, { uid: a.localId, displayName: a.displayName, photoURL: a.photoUrl, email: a.email, emailVerified: !!a.emailVerified, phoneNumber: a.phoneNumber, lastLoginAt: a.lastLoginAt, createdAt: a.createdAt, tenantId: a.tenantId });
    for (var b = en2(a), c = 0; c < b.length; c++)
      Zm(this, b[c]);
    an2(this, "isAnonymous", !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
    this.dispatchEvent(new sm("userReloaded", { hd: a }));
  };
  function en2(a) {
    return (a = a.providerUserInfo) && a.length ? Ra3(a, function(b) {
      return new Hm(b.rawId, b.providerId, b.email, b.displayName, b.photoUrl, b.phoneNumber);
    }) : [];
  }
  k3.Lc = function(a) {
    gf("firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateWithCredential instead.");
    return this.tb(a);
  };
  k3.tb = function(a) {
    var b = this, c = null;
    return R3(this, a.c(this.a, this.uid).then(function(d) {
      wm(b, d);
      c = fn2(b, d, "reauthenticate");
      b.h = null;
      return b.reload();
    }).then(function() {
      return c;
    }), true);
  };
  function gn2(a, b) {
    return cn2(a).then(function() {
      if (Va3(Ym(a), b))
        return Um(a).then(function() {
          throw new t3("provider-already-linked");
        });
    });
  }
  k3.Cc = function(a) {
    gf("firebase.User.prototype.linkAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.linkWithCredential instead.");
    return this.qb(a);
  };
  k3.qb = function(a) {
    var b = this, c = null;
    return R3(this, gn2(this, a.providerId).then(function() {
      return b.I();
    }).then(function(d) {
      return a.b(b.a, d);
    }).then(function(d) {
      c = fn2(b, d, "link");
      return hn2(b, d);
    }).then(function() {
      return c;
    }));
  };
  k3.Dc = function(a, b) {
    var c = this;
    return R3(this, gn2(this, "phone").then(function() {
      return gm(Qm(c), a, b, q3(c.qb, c));
    }));
  };
  k3.Mc = function(a, b) {
    var c = this;
    return R3(this, E3().then(function() {
      return gm(Qm(c), a, b, q3(c.tb, c));
    }), true);
  };
  function fn2(a, b, c) {
    var d = qh(b);
    b = og(b);
    return kf({ user: a, credential: d, additionalUserInfo: b, operationType: c });
  }
  function hn2(a, b) {
    wm(a, b);
    return a.reload().then(function() {
      return a;
    });
  }
  k3.Bb = function(a) {
    var b = this;
    return R3(this, this.I().then(function(c) {
      return b.a.Bb(c, a);
    }).then(function(c) {
      wm(b, c);
      return b.reload();
    }));
  };
  k3.ed = function(a) {
    var b = this;
    return R3(this, this.I().then(function(c) {
      return a.b(b.a, c);
    }).then(function(c) {
      wm(b, c);
      return b.reload();
    }));
  };
  k3.Cb = function(a) {
    var b = this;
    return R3(this, this.I().then(function(c) {
      return b.a.Cb(c, a);
    }).then(function(c) {
      wm(b, c);
      return b.reload();
    }));
  };
  k3.Db = function(a) {
    if (void 0 === a.displayName && void 0 === a.photoURL)
      return Xm(this);
    var b = this;
    return R3(this, this.I().then(function(c) {
      return b.a.Db(c, { displayName: a.displayName, photoUrl: a.photoURL });
    }).then(function(c) {
      wm(b, c);
      an2(b, "displayName", c.displayName || null);
      an2(b, "photoURL", c.photoUrl || null);
      w2(b.providerData, function(d) {
        "password" === d.providerId && (M3(d, "displayName", b.displayName), M3(d, "photoURL", b.photoURL));
      });
      return Um(b);
    }).then(Wm));
  };
  k3.cd = function(a) {
    var b = this;
    return R3(this, cn2(this).then(function(c) {
      return Va3(Ym(b), a) ? rj(b.a, c, [a]).then(function(d) {
        var e = {};
        w2(d.providerUserInfo || [], function(f) {
          e[f.providerId] = true;
        });
        w2(Ym(b), function(f) {
          e[f] || $m(b, f);
        });
        e[lh.PROVIDER_ID] || M3(b, "phoneNumber", null);
        return Um(b);
      }) : Um(b).then(function() {
        throw new t3("no-such-provider");
      });
    }));
  };
  k3.delete = function() {
    var a = this;
    return R3(this, this.I().then(function(b) {
      return O3(a.a, Fj, { idToken: b });
    }).then(function() {
      a.dispatchEvent(new sm("userDeleted"));
    })).then(function() {
      for (var b = 0; b < a.J.length; b++)
        a.J[b].cancel("app-deleted");
      Nm(a, null);
      Om(a, null);
      Pm(a, null);
      a.J = [];
      a.D = true;
      Sm(a);
      M3(a, "refreshToken", null);
      a.i && Ql(a.i, a);
    });
  };
  k3.Fb = function(a, b) {
    return "linkViaPopup" == a && (this.g || null) == b && this.f || "reauthViaPopup" == a && (this.g || null) == b && this.f || "linkViaRedirect" == a && (this.ga || null) == b || "reauthViaRedirect" == a && (this.ga || null) == b ? true : false;
  };
  k3.na = function(a, b, c, d) {
    "linkViaPopup" != a && "reauthViaPopup" != a || d != (this.g || null) || (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.C);
  };
  k3.Fa = function(a, b) {
    return "linkViaPopup" == a && b == (this.g || null) ? q3(this.Kb, this) : "reauthViaPopup" == a && b == (this.g || null) ? q3(this.Lb, this) : "linkViaRedirect" == a && (this.ga || null) == b ? q3(this.Kb, this) : "reauthViaRedirect" == a && (this.ga || null) == b ? q3(this.Lb, this) : null;
  };
  k3.Ec = function(a) {
    var b = this;
    return jn2(this, "linkViaPopup", a, function() {
      return gn2(b, a.providerId).then(function() {
        return Um(b);
      });
    }, false);
  };
  k3.Nc = function(a) {
    return jn2(this, "reauthViaPopup", a, function() {
      return E3();
    }, true);
  };
  function jn2(a, b, c, d, e) {
    if (!Re2())
      return F3(new t3("operation-not-supported-in-this-environment"));
    if (a.h && !e)
      return F3(a.h);
    var f = ng(c.providerId), g = Qe2(a.uid + ":::"), h2 = null;
    (!Te2() || Ie2()) && a.s && c.isOAuthProvider && (h2 = ek(a.s, a.l, a.m, b, c, null, g, index_esm_default.SDK_VERSION || null, null, null, a.tenantId));
    var m = ze2(h2, f && f.ua, f && f.ta);
    d = d().then(function() {
      kn2(a);
      if (!e)
        return a.I().then(function() {
        });
    }).then(function() {
      return Tl(a.i, m, b, c, g, !!h2, a.tenantId);
    }).then(function() {
      return new D3(function(p2, v2) {
        a.na(
          b,
          null,
          new t3("cancelled-popup-request"),
          a.g || null
        );
        a.f = p2;
        a.C = v2;
        a.g = g;
        a.c = Vl(a.i, a, b, m, g);
      });
    }).then(function(p2) {
      m && ye2(m);
      return p2 ? kf(p2) : null;
    }).o(function(p2) {
      m && ye2(m);
      throw p2;
    });
    return R3(a, d, e);
  }
  k3.Fc = function(a) {
    var b = this;
    return ln2(this, "linkViaRedirect", a, function() {
      return gn2(b, a.providerId);
    }, false);
  };
  k3.Oc = function(a) {
    return ln2(this, "reauthViaRedirect", a, function() {
      return E3();
    }, true);
  };
  function ln2(a, b, c, d, e) {
    if (!Re2())
      return F3(new t3("operation-not-supported-in-this-environment"));
    if (a.h && !e)
      return F3(a.h);
    var f = null, g = Qe2(a.uid + ":::");
    d = d().then(function() {
      kn2(a);
      if (!e)
        return a.I().then(function() {
        });
    }).then(function() {
      a.ga = g;
      return Um(a);
    }).then(function(h2) {
      a.ha && (h2 = a.ha, h2 = h2.b.set(mn2, a.w(), h2.a));
      return h2;
    }).then(function() {
      return Ul(a.i, b, c, g, a.tenantId);
    }).o(function(h2) {
      f = h2;
      if (a.ha)
        return nn2(a.ha);
      throw f;
    }).then(function() {
      if (f)
        throw f;
    });
    return R3(a, d, e);
  }
  function kn2(a) {
    if (!a.i || !a.R) {
      if (a.i && !a.R)
        throw new t3("internal-error");
      throw new t3("auth-domain-config-required");
    }
  }
  k3.Kb = function(a, b, c, d) {
    var e = this;
    this.c && (this.c.cancel(), this.c = null);
    var f = null;
    c = this.I().then(function(g) {
      return Hg(e.a, { requestUri: a, postBody: d, sessionId: b, idToken: g });
    }).then(function(g) {
      f = fn2(e, g, "link");
      return hn2(e, g);
    }).then(function() {
      return f;
    });
    return R3(this, c);
  };
  k3.Lb = function(a, b, c, d) {
    var e = this;
    this.c && (this.c.cancel(), this.c = null);
    var f = null, g = E3().then(function() {
      return Cg(Ig(e.a, { requestUri: a, sessionId: b, postBody: d, tenantId: c }), e.uid);
    }).then(function(h2) {
      f = fn2(e, h2, "reauthenticate");
      wm(e, h2);
      e.h = null;
      return e.reload();
    }).then(function() {
      return f;
    });
    return R3(this, g, true);
  };
  k3.ub = function(a) {
    var b = this, c = null;
    return R3(this, this.I().then(function(d) {
      c = d;
      return "undefined" === typeof a || mb2(a) ? {} : bg(new Sf(a));
    }).then(function(d) {
      return b.a.ub(c, d);
    }).then(function(d) {
      if (b.email != d)
        return b.reload();
    }).then(function() {
    }));
  };
  k3.Eb = function(a, b) {
    var c = this, d = null;
    return R3(this, this.I().then(function(e) {
      d = e;
      return "undefined" === typeof b || mb2(b) ? {} : bg(new Sf(b));
    }).then(function(e) {
      return c.a.Eb(d, a, e);
    }).then(function(e) {
      if (c.email != e)
        return c.reload();
    }).then(function() {
    }));
  };
  function R3(a, b, c) {
    var d = on2(a, b, c);
    a.J.push(d);
    d.oa(function() {
      Wa3(a.J, d);
    });
    return d.o(function(e) {
      var f = null;
      e && "auth/multi-factor-auth-required" === e.code && (f = mm(e.w(), Qm(a), q3(a.jc, a)));
      throw f || e;
    });
  }
  k3.jc = function(a) {
    var b = null, c = this;
    a = Cg(E3(a), c.uid).then(function(d) {
      b = fn2(c, d, "reauthenticate");
      wm(c, d);
      c.h = null;
      return c.reload();
    }).then(function() {
      return b;
    });
    return R3(this, a, true);
  };
  function on2(a, b, c) {
    return a.h && !c ? (b.cancel(), F3(a.h)) : b.o(function(d) {
      !d || "auth/user-disabled" != d.code && "auth/user-token-expired" != d.code || (a.h || a.dispatchEvent(new sm("userInvalidated")), a.h = d);
      throw d;
    });
  }
  k3.toJSON = function() {
    return this.w();
  };
  k3.w = function() {
    var a = { uid: this.uid, displayName: this.displayName, photoURL: this.photoURL, email: this.email, emailVerified: this.emailVerified, phoneNumber: this.phoneNumber, isAnonymous: this.isAnonymous, tenantId: this.tenantId, providerData: [], apiKey: this.l, appName: this.m, authDomain: this.s, stsTokenManager: this.b.w(), redirectEventId: this.ga || null };
    this.metadata && z3(a, this.metadata.w());
    w2(this.providerData, function(b) {
      a.providerData.push(lf(b));
    });
    z3(a, this.O.w());
    return a;
  };
  function pn2(a) {
    if (!a.apiKey)
      return null;
    var b = { apiKey: a.apiKey, authDomain: a.authDomain, appName: a.appName, emulatorConfig: a.emulatorConfig }, c = {};
    if (a.stsTokenManager && a.stsTokenManager.accessToken) {
      c[Dg] = a.stsTokenManager.accessToken;
      c.refreshToken = a.stsTokenManager.refreshToken || null;
      var d = a.stsTokenManager.expirationTime;
      d && (c.expiresIn = (d - Date.now()) / 1e3);
    } else
      return null;
    var e = new Im(b, c, a);
    a.providerData && w2(a.providerData, function(f) {
      f && Zm(e, kf(f));
    });
    a.redirectEventId && (e.ga = a.redirectEventId);
    return e;
  }
  function qn2(a, b, c, d) {
    var e = new Im(a, b);
    c && (e.ha = c);
    d && Mm(e, d);
    return e.reload().then(function() {
      return e;
    });
  }
  function rn2(a, b, c, d) {
    var e = a.b, f = {};
    f[Dg] = e.b && e.b.toString();
    f.refreshToken = e.a;
    b = new Im(b || { apiKey: a.l, authDomain: a.s, appName: a.m }, f);
    c && (b.ha = c);
    d && Mm(b, d);
    bn2(b, a);
    return b;
  }
  ;
  function sn2(a) {
    this.a = a;
    this.b = Vk();
  }
  var mn2 = { name: "redirectUser", F: "session" };
  function nn2(a) {
    return Zk(a.b, mn2, a.a);
  }
  function tn2(a, b) {
    return a.b.get(mn2, a.a).then(function(c) {
      c && b && (c.authDomain = b);
      return pn2(c || {});
    });
  }
  ;
  function un2(a) {
    this.a = a;
    this.b = Vk();
    this.c = null;
    this.f = vn2(this);
    this.b.addListener(wn2("local"), this.a, q3(this.g, this));
  }
  un2.prototype.g = function() {
    var a = this, b = wn2("local");
    xn2(this, function() {
      return E3().then(function() {
        return a.c && "local" != a.c.F ? a.b.get(b, a.a) : null;
      }).then(function(c) {
        if (c)
          return yn2(a, "local").then(function() {
            a.c = b;
          });
      });
    });
  };
  function yn2(a, b) {
    var c = [], d;
    for (d in Rk)
      Rk[d] !== b && c.push(Zk(a.b, wn2(Rk[d]), a.a));
    c.push(Zk(a.b, zn2, a.a));
    return Ic3(c);
  }
  function vn2(a) {
    var b = wn2("local"), c = wn2("session"), d = wn2("none");
    return Yk(a.b, b, a.a).then(function() {
      return a.b.get(c, a.a);
    }).then(function(e) {
      return e ? c : a.b.get(d, a.a).then(function(f) {
        return f ? d : a.b.get(b, a.a).then(function(g) {
          return g ? b : a.b.get(zn2, a.a).then(function(h2) {
            return h2 ? wn2(h2) : b;
          });
        });
      });
    }).then(function(e) {
      a.c = e;
      return yn2(a, e.F);
    }).o(function() {
      a.c || (a.c = b);
    });
  }
  var zn2 = { name: "persistence", F: "session" };
  function wn2(a) {
    return { name: "authUser", F: a };
  }
  un2.prototype.xb = function(a) {
    var b = null, c = this;
    Sk(a);
    return xn2(this, function() {
      return a != c.c.F ? c.b.get(c.c, c.a).then(function(d) {
        b = d;
        return yn2(c, a);
      }).then(function() {
        c.c = wn2(a);
        if (b)
          return c.b.set(c.c, b, c.a);
      }) : E3();
    });
  };
  function An2(a) {
    return xn2(a, function() {
      return a.b.set(zn2, a.c.F, a.a);
    });
  }
  function Bn2(a, b) {
    return xn2(a, function() {
      return a.b.set(a.c, b.w(), a.a);
    });
  }
  function Cn2(a) {
    return xn2(a, function() {
      return Zk(a.b, a.c, a.a);
    });
  }
  function Dn2(a, b, c) {
    return xn2(a, function() {
      return a.b.get(a.c, a.a).then(function(d) {
        d && b && (d.authDomain = b);
        d && c && (d.emulatorConfig = c);
        return pn2(d || {});
      });
    });
  }
  function xn2(a, b) {
    a.f = a.f.then(b, b);
    return a.f;
  }
  ;
  function En2(a) {
    this.l = false;
    M3(this, "settings", new em());
    M3(this, "app", a);
    if (S3(this).options && S3(this).options.apiKey)
      a = index_esm_default.SDK_VERSION ? Oe2(index_esm_default.SDK_VERSION) : null, this.a = new Ii2(S3(this).options && S3(this).options.apiKey, Ca3(Da3), a);
    else
      throw new t3("invalid-api-key");
    this.R = [];
    this.s = [];
    this.O = [];
    this.hb = index_esm_default.INTERNAL.createSubscribe(q3(this.zc, this));
    this.X = void 0;
    this.bc = index_esm_default.INTERNAL.createSubscribe(q3(this.Ac, this));
    Fn2(this, null);
    this.i = new un2(S3(this).options.apiKey + ":" + S3(this).name);
    this.D = new sn2(S3(this).options.apiKey + ":" + S3(this).name);
    this.$ = T3(this, Gn2(this));
    this.h = T3(this, Hn2(this));
    this.ba = false;
    this.ja = q3(this.Zc, this);
    this.Ba = q3(this.da, this);
    this.ya = q3(this.mc, this);
    this.za = q3(this.wc, this);
    this.Aa = q3(this.xc, this);
    this.b = null;
    In2(this);
    this.INTERNAL = {};
    this.INTERNAL["delete"] = q3(this.delete, this);
    this.INTERNAL.logFramework = q3(this.Gc, this);
    this.u = 0;
    H3.call(this);
    Jn2(this);
    this.J = [];
    this.P = null;
  }
  r2(En2, H3);
  function Kn2(a) {
    G3.call(this, "languageCodeChanged");
    this.h = a;
  }
  r2(Kn2, G3);
  function Ln2(a) {
    G3.call(this, "emulatorConfigChanged");
    this.c = a;
  }
  r2(Ln2, G3);
  function Mn2(a) {
    G3.call(this, "frameworkChanged");
    this.f = a;
  }
  r2(Mn2, G3);
  k3 = En2.prototype;
  k3.xb = function(a) {
    a = this.i.xb(a);
    return T3(this, a);
  };
  k3.wa = function(a) {
    this.aa === a || this.l || (this.aa = a, Oi2(this.a, this.aa), this.dispatchEvent(new Kn2(this.la())));
  };
  k3.la = function() {
    return this.aa;
  };
  k3.fd = function() {
    var a = l.navigator;
    this.wa(a ? a.languages && a.languages[0] || a.language || a.userLanguage || null : null);
  };
  k3.gd = function(a, b) {
    if (!this.P) {
      if (!/^https?:\/\//.test(a))
        throw new t3("argument-error", "Emulator URL must start with a valid scheme (http:// or https://).");
      b = b ? !!b.disableWarnings : false;
      Nn2(b);
      this.P = { url: a, ec: b };
      this.settings.ib = true;
      Pi2(this.a, this.P);
      this.dispatchEvent(new Ln2(this.P));
    }
  };
  function Nn2(a) {
    "undefined" !== typeof console && "function" === typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
    l.document && !a && Ee2().then(function() {
      var b = l.document.createElement("div");
      b.innerText = "Running in emulator mode. Do not use with production credentials.";
      b.style.position = "fixed";
      b.style.width = "100%";
      b.style.backgroundColor = "#ffffff";
      b.style.border = ".1em solid #000000";
      b.style.color = "#ff0000";
      b.style.bottom = "0px";
      b.style.left = "0px";
      b.style.margin = "0px";
      b.style.zIndex = 1e4;
      b.style.textAlign = "center";
      b.classList.add("firebase-emulator-warning");
      l.document.body.appendChild(b);
    });
  }
  k3.Gc = function(a) {
    this.J.push(a);
    Ri2(this.a, index_esm_default.SDK_VERSION ? Oe2(index_esm_default.SDK_VERSION, this.J) : null);
    this.dispatchEvent(new Mn2(this.J));
  };
  k3.Ga = function() {
    return Za3(this.J);
  };
  k3.yb = function(a) {
    this.S === a || this.l || (this.S = a, this.a.b = this.S);
  };
  k3.T = function() {
    return this.S;
  };
  function Jn2(a) {
    Object.defineProperty(a, "lc", { get: function() {
      return this.la();
    }, set: function(b) {
      this.wa(b);
    }, enumerable: false });
    a.aa = null;
    Object.defineProperty(a, "ti", { get: function() {
      return this.T();
    }, set: function(b) {
      this.yb(b);
    }, enumerable: false });
    a.S = null;
    Object.defineProperty(a, "emulatorConfig", { get: function() {
      if (this.P) {
        var b = J3(this.P.url);
        b = kf({ protocol: b.c, host: b.a, port: b.g, options: kf({ disableWarnings: this.P.ec }) });
      } else
        b = null;
      return b;
    }, enumerable: false });
  }
  k3.toJSON = function() {
    return { apiKey: S3(this).options.apiKey, authDomain: S3(this).options.authDomain, appName: S3(this).name, currentUser: U3(this) && U3(this).w() };
  };
  function On2(a) {
    return a.Oa || F3(new t3("auth-domain-config-required"));
  }
  function In2(a) {
    var b = S3(a).options.authDomain, c = S3(a).options.apiKey;
    b && Re2() && (a.Oa = a.$.then(function() {
      if (!a.l) {
        a.b = Xl(b, c, S3(a).name, a.P);
        Pl(a.b, a);
        U3(a) && Vm(U3(a));
        if (a.m) {
          Vm(a.m);
          var d = a.m;
          d.wa(a.la());
          Nm(d, a);
          d = a.m;
          Mm(d, a.J);
          Pm(d, a);
          d = a.m;
          Pi2(d.a, a.P);
          Om(d, a);
          a.m = null;
        }
        return a.b;
      }
    }));
  }
  k3.Fb = function(a, b) {
    switch (a) {
      case "unknown":
      case "signInViaRedirect":
        return true;
      case "signInViaPopup":
        return this.g == b && !!this.f;
      default:
        return false;
    }
  };
  k3.na = function(a, b, c, d) {
    "signInViaPopup" == a && this.g == d && (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.C);
  };
  k3.Fa = function(a, b) {
    return "signInViaRedirect" == a || "signInViaPopup" == a && this.g == b && this.f ? q3(this.ic, this) : null;
  };
  k3.ic = function(a, b, c, d) {
    var e = this, f = { requestUri: a, postBody: d, sessionId: b, tenantId: c };
    this.c && (this.c.cancel(), this.c = null);
    return e.$.then(function() {
      return Pn2(e, Fg(e.a, f));
    });
  };
  k3.Xc = function(a) {
    if (!Re2())
      return F3(new t3("operation-not-supported-in-this-environment"));
    var b = this, c = ng(a.providerId), d = Qe2(), e = null;
    (!Te2() || Ie2()) && S3(this).options.authDomain && a.isOAuthProvider && (e = ek(S3(this).options.authDomain, S3(this).options.apiKey, S3(this).name, "signInViaPopup", a, null, d, index_esm_default.SDK_VERSION || null, null, null, this.T(), this.P));
    var f = ze2(e, c && c.ua, c && c.ta);
    c = On2(this).then(function(g) {
      return Tl(g, f, "signInViaPopup", a, d, !!e, b.T());
    }).then(function() {
      return new D3(function(g, h2) {
        b.na(
          "signInViaPopup",
          null,
          new t3("cancelled-popup-request"),
          b.g
        );
        b.f = g;
        b.C = h2;
        b.g = d;
        b.c = Vl(b.b, b, "signInViaPopup", f, d);
      });
    }).then(function(g) {
      f && ye2(f);
      return g ? kf(g) : null;
    }).o(function(g) {
      f && ye2(f);
      throw g;
    });
    return T3(this, c);
  };
  k3.Yc = function(a) {
    if (!Re2())
      return F3(new t3("operation-not-supported-in-this-environment"));
    var b = this, c = On2(this).then(function() {
      return An2(b.i);
    }).then(function() {
      return Ul(b.b, "signInViaRedirect", a, void 0, b.T());
    });
    return T3(this, c);
  };
  function Qn2(a) {
    if (!Re2())
      return F3(new t3("operation-not-supported-in-this-environment"));
    var b = On2(a).then(function() {
      return a.b.qa();
    }).then(function(c) {
      return c ? kf(c) : null;
    });
    return T3(a, b);
  }
  k3.qa = function() {
    var a = this;
    return Qn2(this).then(function(b) {
      a.b && $l(a.b.b);
      return b;
    }).o(function(b) {
      a.b && $l(a.b.b);
      throw b;
    });
  };
  k3.dd = function(a) {
    if (!a)
      return F3(new t3("null-user"));
    if (this.S != a.tenantId)
      return F3(new t3("tenant-id-mismatch"));
    var b = this, c = {};
    c.apiKey = S3(this).options.apiKey;
    c.authDomain = S3(this).options.authDomain;
    c.appName = S3(this).name;
    var d = rn2(a, c, b.D, b.Ga());
    return T3(this, this.h.then(function() {
      if (S3(b).options.apiKey != a.l)
        return d.reload();
    }).then(function() {
      if (U3(b) && a.uid == U3(b).uid)
        return bn2(U3(b), a), b.da(a);
      Fn2(b, d);
      Vm(d);
      return b.da(d);
    }).then(function() {
      Rn2(b);
    }));
  };
  function Sn2(a, b) {
    var c = {};
    c.apiKey = S3(a).options.apiKey;
    c.authDomain = S3(a).options.authDomain;
    c.appName = S3(a).name;
    a.P && (c.emulatorConfig = a.P);
    return a.$.then(function() {
      return qn2(c, b, a.D, a.Ga());
    }).then(function(d) {
      if (U3(a) && d.uid == U3(a).uid)
        return bn2(U3(a), d), a.da(d);
      Fn2(a, d);
      Vm(d);
      return a.da(d);
    }).then(function() {
      Rn2(a);
    });
  }
  function Fn2(a, b) {
    U3(a) && (Tm(U3(a), a.Ba), xd2(U3(a), "tokenChanged", a.ya), xd2(U3(a), "userDeleted", a.za), xd2(U3(a), "userInvalidated", a.Aa), Sm(U3(a)));
    b && (b.S.push(a.Ba), nd2(b, "tokenChanged", a.ya), nd2(b, "userDeleted", a.za), nd2(b, "userInvalidated", a.Aa), 0 < a.u && Rm(b));
    M3(a, "currentUser", b);
    b && (b.wa(a.la()), Nm(b, a), Mm(b, a.J), Pm(b, a), Pi2(b.a, a.P), Om(b, a));
  }
  k3.Ab = function() {
    var a = this, b = this.h.then(function() {
      a.b && $l(a.b.b);
      if (!U3(a))
        return E3();
      Fn2(a, null);
      return Cn2(a.i).then(function() {
        Rn2(a);
      });
    });
    return T3(this, b);
  };
  function Tn2(a) {
    var b = tn2(a.D, S3(a).options.authDomain).then(function(c) {
      if (a.m = c)
        c.ha = a.D;
      return nn2(a.D);
    });
    return T3(a, b);
  }
  function Gn2(a) {
    var b = S3(a).options.authDomain, c = Tn2(a).then(function() {
      return Dn2(a.i, b, a.P);
    }).then(function(d) {
      return d ? (d.ha = a.D, a.m && (a.m.ga || null) == (d.ga || null) ? d : d.reload().then(function() {
        return Bn2(a.i, d).then(function() {
          return d;
        });
      }).o(function(e) {
        return "auth/network-request-failed" == e.code ? d : Cn2(a.i);
      })) : null;
    }).then(function(d) {
      Fn2(a, d || null);
    });
    return T3(a, c);
  }
  function Hn2(a) {
    return a.$.then(function() {
      return Qn2(a);
    }).o(function() {
    }).then(function() {
      if (!a.l)
        return a.ja();
    }).o(function() {
    }).then(function() {
      if (!a.l) {
        a.ba = true;
        var b = a.i;
        b.b.addListener(wn2("local"), b.a, a.ja);
      }
    });
  }
  k3.Zc = function() {
    var a = this;
    return Dn2(this.i, S3(this).options.authDomain).then(function(b) {
      if (!a.l) {
        var c;
        if (c = U3(a) && b) {
          c = U3(a).uid;
          var d = b.uid;
          c = void 0 === c || null === c || "" === c || void 0 === d || null === d || "" === d ? false : c == d;
        }
        if (c)
          return bn2(U3(a), b), U3(a).I();
        if (U3(a) || b)
          Fn2(a, b), b && (Vm(b), b.ha = a.D), a.b && Pl(a.b, a), Rn2(a);
      }
    });
  };
  k3.da = function(a) {
    return Bn2(this.i, a);
  };
  k3.mc = function() {
    Rn2(this);
    this.da(U3(this));
  };
  k3.wc = function() {
    this.Ab();
  };
  k3.xc = function() {
    this.Ab();
  };
  function Pn2(a, b) {
    var c = null, d = null;
    return T3(a, b.then(function(e) {
      c = qh(e);
      d = og(e);
      return Sn2(a, e);
    }, function(e) {
      var f = null;
      e && "auth/multi-factor-auth-required" === e.code && (f = mm(e.w(), a, q3(a.kc, a)));
      throw f || e;
    }).then(function() {
      return kf({ user: U3(a), credential: c, additionalUserInfo: d, operationType: "signIn" });
    }));
  }
  k3.kc = function(a) {
    var b = this;
    return this.h.then(function() {
      return Pn2(b, E3(a));
    });
  };
  k3.zc = function(a) {
    var b = this;
    this.addAuthTokenListener(function() {
      a.next(U3(b));
    });
  };
  k3.Ac = function(a) {
    var b = this;
    Un2(this, function() {
      a.next(U3(b));
    });
  };
  k3.Ic = function(a, b, c) {
    var d = this;
    this.ba && Promise.resolve().then(function() {
      "function" === typeof a ? a(U3(d)) : "function" === typeof a.next && a.next(U3(d));
    });
    return this.hb(a, b, c);
  };
  k3.Hc = function(a, b, c) {
    var d = this;
    this.ba && Promise.resolve().then(function() {
      d.X = d.getUid();
      "function" === typeof a ? a(U3(d)) : "function" === typeof a.next && a.next(U3(d));
    });
    return this.bc(a, b, c);
  };
  k3.nc = function(a) {
    var b = this, c = this.h.then(function() {
      return U3(b) ? U3(b).I(a).then(function(d) {
        return { accessToken: d };
      }) : null;
    });
    return T3(this, c);
  };
  k3.Tc = function(a) {
    var b = this;
    return this.h.then(function() {
      return Pn2(b, O3(b.a, Kj, { token: a }));
    }).then(function(c) {
      var d = c.user;
      an2(d, "isAnonymous", false);
      b.da(d);
      return c;
    });
  };
  k3.Uc = function(a, b) {
    var c = this;
    return this.h.then(function() {
      return Pn2(c, O3(c.a, ah, { email: a, password: b }));
    });
  };
  k3.dc = function(a, b) {
    var c = this;
    return this.h.then(function() {
      return Pn2(c, O3(c.a, Ej, { email: a, password: b }));
    });
  };
  k3.$a = function(a) {
    var b = this;
    return this.h.then(function() {
      return Pn2(b, a.ka(b.a));
    });
  };
  k3.Sc = function(a) {
    gf("firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInWithCredential instead.");
    return this.$a(a);
  };
  k3.zb = function() {
    var a = this;
    return this.h.then(function() {
      var b = U3(a);
      if (b && b.isAnonymous) {
        var c = kf({ providerId: null, isNewUser: false });
        return kf({ user: b, credential: null, additionalUserInfo: c, operationType: "signIn" });
      }
      return Pn2(a, a.a.zb()).then(function(d) {
        var e = d.user;
        an2(e, "isAnonymous", true);
        a.da(e);
        return d;
      });
    });
  };
  function S3(a) {
    return a.app;
  }
  function U3(a) {
    return a.currentUser;
  }
  k3.getUid = function() {
    return U3(this) && U3(this).uid || null;
  };
  function Vn2(a) {
    return U3(a) && U3(a)._lat || null;
  }
  function Rn2(a) {
    if (a.ba) {
      for (var b = 0; b < a.s.length; b++)
        if (a.s[b])
          a.s[b](Vn2(a));
      if (a.X !== a.getUid() && a.O.length) {
        for (a.X = a.getUid(), b = 0; b < a.O.length; b++)
          if (a.O[b])
            a.O[b](Vn2(a));
      }
    }
  }
  k3.cc = function(a) {
    this.addAuthTokenListener(a);
    this.u++;
    0 < this.u && U3(this) && Rm(U3(this));
  };
  k3.Pc = function(a) {
    var b = this;
    w2(this.s, function(c) {
      c == a && b.u--;
    });
    0 > this.u && (this.u = 0);
    0 == this.u && U3(this) && Sm(U3(this));
    this.removeAuthTokenListener(a);
  };
  k3.addAuthTokenListener = function(a) {
    var b = this;
    this.s.push(a);
    T3(this, this.h.then(function() {
      b.l || Va3(b.s, a) && a(Vn2(b));
    }));
  };
  k3.removeAuthTokenListener = function(a) {
    Xa3(this.s, function(b) {
      return b == a;
    });
  };
  function Un2(a, b) {
    a.O.push(b);
    T3(a, a.h.then(function() {
      !a.l && Va3(a.O, b) && a.X !== a.getUid() && (a.X = a.getUid(), b(Vn2(a)));
    }));
  }
  k3.delete = function() {
    this.l = true;
    for (var a = 0; a < this.R.length; a++)
      this.R[a].cancel("app-deleted");
    this.R = [];
    this.i && (a = this.i, a.b.removeListener(wn2("local"), a.a, this.ja));
    this.b && (Ql(this.b, this), $l(this.b.b));
    return Promise.resolve();
  };
  function T3(a, b) {
    a.R.push(b);
    b.oa(function() {
      Wa3(a.R, b);
    });
    return b;
  }
  k3.hc = function(a) {
    return T3(this, aj(this.a, a));
  };
  k3.Bc = function(a) {
    return !!fh(a);
  };
  k3.wb = function(a, b) {
    var c = this;
    return T3(this, E3().then(function() {
      var d = new Sf(b);
      if (!d.c)
        throw new t3("argument-error", $f + " must be true when sending sign in link to email");
      return bg(d);
    }).then(function(d) {
      return c.a.wb(a, d);
    }).then(function() {
    }));
  };
  k3.jd = function(a) {
    return this.Ra(a).then(function(b) {
      return b.data.email;
    });
  };
  k3.nb = function(a, b) {
    return T3(this, this.a.nb(a, b).then(function() {
    }));
  };
  k3.Ra = function(a) {
    return T3(this, this.a.Ra(a).then(function(b) {
      return new vf(b);
    }));
  };
  k3.jb = function(a) {
    return T3(this, this.a.jb(a).then(function() {
    }));
  };
  k3.vb = function(a, b) {
    var c = this;
    return T3(this, E3().then(function() {
      return "undefined" === typeof b || mb2(b) ? {} : bg(new Sf(b));
    }).then(function(d) {
      return c.a.vb(a, d);
    }).then(function() {
    }));
  };
  k3.Wc = function(a, b) {
    return T3(this, gm(this, a, b, q3(this.$a, this)));
  };
  k3.Vc = function(a, b) {
    var c = this;
    return T3(this, E3().then(function() {
      var d = b || re2(), e = eh(a, d);
      d = fh(d);
      if (!d)
        throw new t3("argument-error", "Invalid email link!");
      if (d.tenantId !== c.T())
        throw new t3("tenant-id-mismatch");
      return c.$a(e);
    }));
  };
  function Wn2() {
  }
  Wn2.prototype.render = function() {
  };
  Wn2.prototype.reset = function() {
  };
  Wn2.prototype.getResponse = function() {
  };
  Wn2.prototype.execute = function() {
  };
  function Xn2() {
    this.a = {};
    this.b = 1e12;
  }
  var Yn2 = null;
  Xn2.prototype.render = function(a, b) {
    this.a[this.b.toString()] = new Zn2(a, b);
    return this.b++;
  };
  Xn2.prototype.reset = function(a) {
    var b = $n2(this, a);
    a = ao2(a);
    b && a && (b.delete(), delete this.a[a]);
  };
  Xn2.prototype.getResponse = function(a) {
    return (a = $n2(this, a)) ? a.getResponse() : null;
  };
  Xn2.prototype.execute = function(a) {
    (a = $n2(this, a)) && a.execute();
  };
  function $n2(a, b) {
    return (b = ao2(b)) ? a.a[b] || null : null;
  }
  function ao2(a) {
    return (a = "undefined" === typeof a ? 1e12 : a) ? a.toString() : null;
  }
  function Zn2(a, b) {
    this.g = false;
    this.c = b;
    this.a = this.b = null;
    this.h = "invisible" !== this.c.size;
    this.f = kc3(a);
    var c = this;
    this.i = function() {
      c.execute();
    };
    this.h ? this.execute() : nd2(this.f, "click", this.i);
  }
  Zn2.prototype.getResponse = function() {
    bo2(this);
    return this.b;
  };
  Zn2.prototype.execute = function() {
    bo2(this);
    var a = this;
    this.a || (this.a = setTimeout(function() {
      a.b = Me2();
      var b = a.c.callback, c = a.c["expired-callback"];
      if (b)
        try {
          b(a.b);
        } catch (d) {
        }
      a.a = setTimeout(function() {
        a.a = null;
        a.b = null;
        if (c)
          try {
            c();
          } catch (d) {
          }
        a.h && a.execute();
      }, 6e4);
    }, 500));
  };
  Zn2.prototype.delete = function() {
    bo2(this);
    this.g = true;
    clearTimeout(this.a);
    this.a = null;
    xd2(this.f, "click", this.i);
  };
  function bo2(a) {
    if (a.g)
      throw Error("reCAPTCHA mock was already deleted!");
  }
  ;
  function co2() {
  }
  M3(co2, "FACTOR_ID", "phone");
  function eo2() {
  }
  eo2.prototype.g = function() {
    Yn2 || (Yn2 = new Xn2());
    return E3(Yn2);
  };
  eo2.prototype.c = function() {
  };
  var fo2 = null;
  function go2() {
    this.b = l.grecaptcha ? Infinity : 0;
    this.f = null;
    this.a = "__rcb" + Math.floor(1e6 * Math.random()).toString();
  }
  var ho2 = new qb2(rb, "https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"), io2 = new Ze2(3e4, 6e4);
  go2.prototype.g = function(a) {
    var b = this;
    return new D3(function(c, d) {
      var e = setTimeout(function() {
        d(new t3("network-request-failed"));
      }, io2.get());
      if (!l.grecaptcha || a !== b.f && !b.b) {
        l[b.a] = function() {
          if (l.grecaptcha) {
            b.f = a;
            var g = l.grecaptcha.render;
            l.grecaptcha.render = function(h2, m) {
              h2 = g(h2, m);
              b.b++;
              return h2;
            };
            clearTimeout(e);
            c(l.grecaptcha);
          } else
            clearTimeout(e), d(new t3("internal-error"));
          delete l[b.a];
        };
        var f = zb2(ho2, { onload: b.a, hl: a || "" });
        E3(Bi2(f)).o(function() {
          clearTimeout(e);
          d(new t3("internal-error", "Unable to load external reCAPTCHA dependencies!"));
        });
      } else
        clearTimeout(e), c(l.grecaptcha);
    });
  };
  go2.prototype.c = function() {
    this.b--;
  };
  var jo2 = null;
  function ko2(a, b, c, d, e, f, g) {
    M3(this, "type", "recaptcha");
    this.c = this.f = null;
    this.D = false;
    this.v = b;
    this.g = null;
    g ? (fo2 || (fo2 = new eo2()), g = fo2) : (jo2 || (jo2 = new go2()), g = jo2);
    this.m = g;
    this.a = c || { theme: "light", type: "image" };
    this.h = [];
    if (this.a[lo2])
      throw new t3("argument-error", "sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");
    this.i = "invisible" === this.a[mo2];
    if (!l.document)
      throw new t3("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.");
    if (!kc3(b) || !this.i && kc3(b).hasChildNodes())
      throw new t3("argument-error", "reCAPTCHA container is either not found or already contains inner elements!");
    this.s = new Ii2(a, f || null, e || null);
    this.u = d || function() {
      return null;
    };
    var h2 = this;
    this.l = [];
    var m = this.a[no2];
    this.a[no2] = function(v2) {
      oo2(h2, v2);
      if ("function" === typeof m)
        m(v2);
      else if ("string" === typeof m) {
        var B2 = L4(m, l);
        "function" === typeof B2 && B2(v2);
      }
    };
    var p2 = this.a[po2];
    this.a[po2] = function() {
      oo2(h2, null);
      if ("function" === typeof p2)
        p2();
      else if ("string" === typeof p2) {
        var v2 = L4(p2, l);
        "function" === typeof v2 && v2();
      }
    };
  }
  var no2 = "callback", po2 = "expired-callback", lo2 = "sitekey", mo2 = "size";
  function oo2(a, b) {
    for (var c = 0; c < a.l.length; c++)
      try {
        a.l[c](b);
      } catch (d) {
      }
  }
  function qo2(a, b) {
    Xa3(a.l, function(c) {
      return c == b;
    });
  }
  function ro2(a, b) {
    a.h.push(b);
    b.oa(function() {
      Wa3(a.h, b);
    });
    return b;
  }
  k3 = ko2.prototype;
  k3.Ia = function() {
    var a = this;
    return this.f ? this.f : this.f = ro2(this, E3().then(function() {
      if (Se2() && !Je2())
        return Ee2();
      throw new t3("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");
    }).then(function() {
      return a.m.g(a.u());
    }).then(function(b) {
      a.g = b;
      return O3(a.s, Jj, {});
    }).then(function(b) {
      a.a[lo2] = b.recaptchaSiteKey;
    }).o(function(b) {
      a.f = null;
      throw b;
    }));
  };
  k3.render = function() {
    so2(this);
    var a = this;
    return ro2(this, this.Ia().then(function() {
      if (null === a.c) {
        var b = a.v;
        if (!a.i) {
          var c = kc3(b);
          b = nc3("DIV");
          c.appendChild(b);
        }
        a.c = a.g.render(b, a.a);
      }
      return a.c;
    }));
  };
  k3.verify = function() {
    so2(this);
    var a = this;
    return ro2(this, this.render().then(function(b) {
      return new D3(function(c) {
        var d = a.g.getResponse(b);
        if (d)
          c(d);
        else {
          var e = function(f) {
            f && (qo2(a, e), c(f));
          };
          a.l.push(e);
          a.i && a.g.execute(a.c);
        }
      });
    }));
  };
  k3.reset = function() {
    so2(this);
    null !== this.c && this.g.reset(this.c);
  };
  function so2(a) {
    if (a.D)
      throw new t3("internal-error", "RecaptchaVerifier instance has been destroyed.");
  }
  k3.clear = function() {
    so2(this);
    this.D = true;
    this.m.c();
    for (var a = 0; a < this.h.length; a++)
      this.h[a].cancel("RecaptchaVerifier instance has been destroyed.");
    if (!this.i) {
      a = kc3(this.v);
      for (var b; b = a.firstChild; )
        a.removeChild(b);
    }
  };
  function to2(a, b, c) {
    var d = false;
    try {
      this.b = c || index_esm_default.app();
    } catch (g) {
      throw new t3("argument-error", "No firebase.app.App instance is currently initialized.");
    }
    if (this.b.options && this.b.options.apiKey)
      c = this.b.options.apiKey;
    else
      throw new t3("invalid-api-key");
    var e = this, f = null;
    try {
      f = this.b.auth().Ga();
    } catch (g) {
    }
    try {
      d = this.b.auth().settings.appVerificationDisabledForTesting;
    } catch (g) {
    }
    f = index_esm_default.SDK_VERSION ? Oe2(index_esm_default.SDK_VERSION, f) : null;
    ko2.call(this, c, a, b, function() {
      try {
        var g = e.b.auth().la();
      } catch (h2) {
        g = null;
      }
      return g;
    }, f, Ca3(Da3), d);
  }
  r2(to2, ko2);
  function uo2(a, b, c, d) {
    a: {
      c = Array.prototype.slice.call(c);
      var e = 0;
      for (var f = false, g = 0; g < b.length; g++)
        if (b[g].optional)
          f = true;
        else {
          if (f)
            throw new t3("internal-error", "Argument validator encountered a required argument after an optional argument.");
          e++;
        }
      f = b.length;
      if (c.length < e || f < c.length)
        d = "Expected " + (e == f ? 1 == e ? "1 argument" : e + " arguments" : e + "-" + f + " arguments") + " but got " + c.length + ".";
      else {
        for (e = 0; e < c.length; e++)
          if (f = b[e].optional && void 0 === c[e], !b[e].M(c[e]) && !f) {
            b = b[e];
            if (0 > e || e >= vo2.length)
              throw new t3(
                "internal-error",
                "Argument validator received an unsupported number of arguments."
              );
            c = vo2[e];
            d = (d ? "" : c + " argument ") + (b.name ? '"' + b.name + '" ' : "") + "must be " + b.K + ".";
            break a;
          }
        d = null;
      }
    }
    if (d)
      throw new t3("argument-error", a + " failed: " + d);
  }
  var vo2 = "First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");
  function V3(a, b) {
    return { name: a || "", K: "a valid string", optional: !!b, M: function(c) {
      return "string" === typeof c;
    } };
  }
  function wo2(a, b) {
    return { name: a || "", K: "a boolean", optional: !!b, M: function(c) {
      return "boolean" === typeof c;
    } };
  }
  function W3(a, b) {
    return { name: a || "", K: "a valid object", optional: !!b, M: n2 };
  }
  function xo2(a, b) {
    return { name: a || "", K: "a function", optional: !!b, M: function(c) {
      return "function" === typeof c;
    } };
  }
  function yo2(a, b) {
    return { name: a || "", K: "null", optional: !!b, M: function(c) {
      return null === c;
    } };
  }
  function zo2() {
    return { name: "", K: "an HTML element", optional: false, M: function(a) {
      return !!(a && a instanceof Element);
    } };
  }
  function Ao2() {
    return { name: "auth", K: "an instance of Firebase Auth", optional: true, M: function(a) {
      return !!(a && a instanceof En2);
    } };
  }
  function Bo2() {
    return { name: "app", K: "an instance of Firebase App", optional: true, M: function(a) {
      return !!(a && a instanceof index_esm_default.app.App);
    } };
  }
  function Co2(a) {
    return { name: a ? a + "Credential" : "credential", K: a ? "a valid " + a + " credential" : "a valid credential", optional: false, M: function(b) {
      if (!b)
        return false;
      var c = !a || b.providerId === a;
      return !(!b.ka || !c);
    } };
  }
  function Do2() {
    return { name: "multiFactorAssertion", K: "a valid multiFactorAssertion", optional: false, M: function(a) {
      return a ? !!a.sb : false;
    } };
  }
  function Eo2() {
    return { name: "authProvider", K: "a valid Auth provider", optional: false, M: function(a) {
      return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty("isOAuthProvider"));
    } };
  }
  function Fo2(a, b) {
    return n2(a) && "string" === typeof a.type && a.type === b && "function" === typeof a.Ha;
  }
  function Go2(a) {
    return n2(a) && "string" === typeof a.uid;
  }
  function Ho2() {
    return { name: "applicationVerifier", K: "an implementation of firebase.auth.ApplicationVerifier", optional: false, M: function(a) {
      return !(!a || "string" !== typeof a.type || "function" !== typeof a.verify);
    } };
  }
  function X3(a, b, c, d) {
    return { name: c || "", K: a.K + " or " + b.K, optional: !!d, M: function(e) {
      return a.M(e) || b.M(e);
    } };
  }
  ;
  function Y3(a, b) {
    for (var c in b) {
      var d = b[c].name;
      a[d] = Io2(d, a[c], b[c].j);
    }
  }
  function Jo2(a, b) {
    for (var c in b) {
      var d = b[c].name;
      d !== c && Object.defineProperty(a, d, { get: ua3(function(e) {
        return this[e];
      }, c), set: ua3(function(e, f, g, h2) {
        uo2(e, [g], [h2], true);
        this[f] = h2;
      }, d, c, b[c].kb), enumerable: true });
    }
  }
  function Z3(a, b, c, d) {
    a[b] = Io2(b, c, d);
  }
  function Io2(a, b, c) {
    function d() {
      var g = Array.prototype.slice.call(arguments);
      uo2(e, c, g);
      return b.apply(this, g);
    }
    if (!c)
      return b;
    var e = Ko2(a), f;
    for (f in b)
      d[f] = b[f];
    for (f in b.prototype)
      d.prototype[f] = b.prototype[f];
    return d;
  }
  function Ko2(a) {
    a = a.split(".");
    return a[a.length - 1];
  }
  ;
  Y3(En2.prototype, {
    jb: { name: "applyActionCode", j: [V3("code")] },
    Ra: { name: "checkActionCode", j: [V3("code")] },
    nb: { name: "confirmPasswordReset", j: [V3("code"), V3("newPassword")] },
    dc: { name: "createUserWithEmailAndPassword", j: [V3("email"), V3("password")] },
    hc: { name: "fetchSignInMethodsForEmail", j: [V3("email")] },
    qa: { name: "getRedirectResult", j: [] },
    Bc: { name: "isSignInWithEmailLink", j: [V3("emailLink")] },
    Hc: { name: "onAuthStateChanged", j: [X3(W3(), xo2(), "nextOrObserver"), xo2("opt_error", true), xo2("opt_completed", true)] },
    Ic: {
      name: "onIdTokenChanged",
      j: [X3(W3(), xo2(), "nextOrObserver"), xo2("opt_error", true), xo2("opt_completed", true)]
    },
    vb: { name: "sendPasswordResetEmail", j: [V3("email"), X3(W3("opt_actionCodeSettings", true), yo2(null, true), "opt_actionCodeSettings", true)] },
    wb: { name: "sendSignInLinkToEmail", j: [V3("email"), W3("actionCodeSettings")] },
    xb: { name: "setPersistence", j: [V3("persistence")] },
    Sc: { name: "signInAndRetrieveDataWithCredential", j: [Co2()] },
    zb: { name: "signInAnonymously", j: [] },
    $a: { name: "signInWithCredential", j: [Co2()] },
    Tc: { name: "signInWithCustomToken", j: [V3("token")] },
    Uc: { name: "signInWithEmailAndPassword", j: [V3("email"), V3("password")] },
    Vc: { name: "signInWithEmailLink", j: [V3("email"), V3("emailLink", true)] },
    Wc: { name: "signInWithPhoneNumber", j: [V3("phoneNumber"), Ho2()] },
    Xc: { name: "signInWithPopup", j: [Eo2()] },
    Yc: { name: "signInWithRedirect", j: [Eo2()] },
    dd: { name: "updateCurrentUser", j: [X3(/* @__PURE__ */ function(a) {
      return { name: "user", K: "an instance of Firebase User", optional: !!a, M: function(b) {
        return !!(b && b instanceof Im);
      } };
    }(), yo2(), "user")] },
    Ab: { name: "signOut", j: [] },
    toJSON: { name: "toJSON", j: [V3(
      null,
      true
    )] },
    fd: { name: "useDeviceLanguage", j: [] },
    gd: { name: "useEmulator", j: [V3("url"), W3("options", true)] },
    jd: { name: "verifyPasswordResetCode", j: [V3("code")] }
  });
  Jo2(En2.prototype, { lc: { name: "languageCode", kb: X3(V3(), yo2(), "languageCode") }, ti: { name: "tenantId", kb: X3(V3(), yo2(), "tenantId") } });
  En2.Persistence = Rk;
  En2.Persistence.LOCAL = "local";
  En2.Persistence.SESSION = "session";
  En2.Persistence.NONE = "none";
  Y3(Im.prototype, {
    "delete": { name: "delete", j: [] },
    oc: { name: "getIdTokenResult", j: [wo2("opt_forceRefresh", true)] },
    I: { name: "getIdToken", j: [wo2("opt_forceRefresh", true)] },
    Cc: { name: "linkAndRetrieveDataWithCredential", j: [Co2()] },
    qb: { name: "linkWithCredential", j: [Co2()] },
    Dc: { name: "linkWithPhoneNumber", j: [V3("phoneNumber"), Ho2()] },
    Ec: { name: "linkWithPopup", j: [Eo2()] },
    Fc: { name: "linkWithRedirect", j: [Eo2()] },
    Lc: { name: "reauthenticateAndRetrieveDataWithCredential", j: [Co2()] },
    tb: { name: "reauthenticateWithCredential", j: [Co2()] },
    Mc: {
      name: "reauthenticateWithPhoneNumber",
      j: [V3("phoneNumber"), Ho2()]
    },
    Nc: { name: "reauthenticateWithPopup", j: [Eo2()] },
    Oc: { name: "reauthenticateWithRedirect", j: [Eo2()] },
    reload: { name: "reload", j: [] },
    ub: { name: "sendEmailVerification", j: [X3(W3("opt_actionCodeSettings", true), yo2(null, true), "opt_actionCodeSettings", true)] },
    toJSON: { name: "toJSON", j: [V3(null, true)] },
    cd: { name: "unlink", j: [V3("provider")] },
    Bb: { name: "updateEmail", j: [V3("email")] },
    Cb: { name: "updatePassword", j: [V3("password")] },
    ed: { name: "updatePhoneNumber", j: [Co2("phone")] },
    Db: { name: "updateProfile", j: [W3("profile")] },
    Eb: { name: "verifyBeforeUpdateEmail", j: [V3("email"), X3(W3("opt_actionCodeSettings", true), yo2(null, true), "opt_actionCodeSettings", true)] }
  });
  Y3(Xn2.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
  Y3(Wn2.prototype, { execute: { name: "execute" }, render: { name: "render" }, reset: { name: "reset" }, getResponse: { name: "getResponse" } });
  Y3(D3.prototype, { oa: { name: "finally" }, o: { name: "catch" }, then: { name: "then" } });
  Jo2(em.prototype, { appVerificationDisabled: { name: "appVerificationDisabledForTesting", kb: wo2("appVerificationDisabledForTesting") } });
  Y3(fm.prototype, { confirm: { name: "confirm", j: [V3("verificationCode")] } });
  Z3(Bg, "fromJSON", function(a) {
    a = "string" === typeof a ? JSON.parse(a) : a;
    for (var b, c = [Mg, dh, kh, Jg], d = 0; d < c.length; d++)
      if (b = c[d](a))
        return b;
    return null;
  }, [X3(V3(), W3(), "json")]);
  Z3(Zg, "credential", function(a, b) {
    return new Yg(a, b);
  }, [V3("email"), V3("password")]);
  Y3(Yg.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(Qg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Qg, "credential", Rg, [X3(V3(), W3(), "token")]);
  Z3(Zg, "credentialWithLink", eh, [V3("email"), V3("emailLink")]);
  Y3(Sg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Sg, "credential", Tg, [X3(V3(), W3(), "token")]);
  Y3(Ug.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Ug, "credential", Vg, [X3(V3(), X3(W3(), yo2()), "idToken"), X3(V3(), yo2(), "accessToken", true)]);
  Y3(Wg.prototype, { Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Z3(Wg, "credential", Xg, [X3(V3(), W3(), "token"), V3("secret", true)]);
  Y3(Pg.prototype, { Ca: { name: "addScope", j: [V3("scope")] }, credential: { name: "credential", j: [X3(V3(), X3(W3(), yo2()), "optionsOrIdToken"), X3(V3(), yo2(), "accessToken", true)] }, Ka: { name: "setCustomParameters", j: [W3("customOAuthParameters")] } });
  Y3(Kg.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(Eg.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Z3(lh, "credential", ph, [V3("verificationId"), V3("verificationCode")]);
  Y3(lh.prototype, { fb: { name: "verifyPhoneNumber", j: [X3(V3(), /* @__PURE__ */ function(a, b) {
    return { name: a || "phoneInfoOptions", K: "valid phone info options", optional: !!b, M: function(c) {
      return c ? c.session && c.phoneNumber ? Fo2(c.session, zg) && "string" === typeof c.phoneNumber : c.session && c.multiFactorHint ? Fo2(c.session, Ag) && Go2(c.multiFactorHint) : c.session && c.multiFactorUid ? Fo2(c.session, Ag) && "string" === typeof c.multiFactorUid : c.phoneNumber ? "string" === typeof c.phoneNumber : false : false;
    } };
  }(), "phoneInfoOptions"), Ho2()] } });
  Y3(gh.prototype, { w: { name: "toJSON", j: [V3(null, true)] } });
  Y3(t3.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(yh.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(xh.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(lm.prototype, { toJSON: { name: "toJSON", j: [V3(null, true)] } });
  Y3(im.prototype, { Rc: { name: "resolveSignIn", j: [Do2()] } });
  Y3(tm.prototype, { Rb: { name: "getSession", j: [] }, fc: { name: "enroll", j: [Do2(), V3("displayName", true)] }, bd: { name: "unenroll", j: [X3({ name: "multiFactorInfo", K: "a valid multiFactorInfo", optional: false, M: Go2 }, V3(), "multiFactorInfoIdentifier")] } });
  Y3(to2.prototype, { clear: { name: "clear", j: [] }, render: { name: "render", j: [] }, verify: { name: "verify", j: [] } });
  Z3(Jf, "parseLink", Rf, [V3("link")]);
  Z3(co2, "assertion", function(a) {
    return new rm(a);
  }, [Co2("phone")]);
  (function() {
    if ("undefined" !== typeof index_esm_default && index_esm_default.INTERNAL && index_esm_default.INTERNAL.registerComponent) {
      var a = { ActionCodeInfo: { Operation: { EMAIL_SIGNIN: Af, PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: Cf, VERIFY_AND_CHANGE_EMAIL: Bf, VERIFY_EMAIL: "VERIFY_EMAIL" } }, Auth: En2, AuthCredential: Bg, Error: t3 };
      Z3(a, "EmailAuthProvider", Zg, []);
      Z3(a, "FacebookAuthProvider", Qg, []);
      Z3(a, "GithubAuthProvider", Sg, []);
      Z3(a, "GoogleAuthProvider", Ug, []);
      Z3(a, "TwitterAuthProvider", Wg, []);
      Z3(a, "OAuthProvider", Pg, [V3("providerId")]);
      Z3(a, "SAMLAuthProvider", Og, [V3("providerId")]);
      Z3(a, "PhoneAuthProvider", lh, [Ao2()]);
      Z3(a, "RecaptchaVerifier", to2, [X3(V3(), zo2(), "recaptchaContainer"), W3("recaptchaParameters", true), Bo2()]);
      Z3(a, "ActionCodeURL", Jf, []);
      Z3(a, "PhoneMultiFactorGenerator", co2, []);
      index_esm_default.INTERNAL.registerComponent({ name: "auth", instanceFactory: function(b) {
        b = b.getProvider("app").getImmediate();
        return new En2(b);
      }, multipleInstances: false, serviceProps: a, instantiationMode: "LAZY", type: "PUBLIC" });
      index_esm_default.INTERNAL.registerComponent({
        name: "auth-internal",
        instanceFactory: function(b) {
          b = b.getProvider("auth").getImmediate();
          return { getUid: q3(b.getUid, b), getToken: q3(b.nc, b), addAuthTokenListener: q3(b.cc, b), removeAuthTokenListener: q3(b.Pc, b) };
        },
        multipleInstances: false,
        instantiationMode: "LAZY",
        type: "PRIVATE"
      });
      index_esm_default.registerVersion("@firebase/auth", "0.16.4");
      index_esm_default.INTERNAL.extendNamespace({ User: Im });
    } else
      throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");
  })();
}).apply(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});

// node_modules/@firebase/database/dist/index.esm.js
var DOMStorageWrapper = (
  /** @class */
  function() {
    function DOMStorageWrapper2(domStorage_) {
      this.domStorage_ = domStorage_;
      this.prefix_ = "firebase:";
    }
    DOMStorageWrapper2.prototype.set = function(key, value) {
      if (value == null) {
        this.domStorage_.removeItem(this.prefixedName_(key));
      } else {
        this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
      }
    };
    DOMStorageWrapper2.prototype.get = function(key) {
      var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
      if (storedVal == null) {
        return null;
      } else {
        return jsonEval(storedVal);
      }
    };
    DOMStorageWrapper2.prototype.remove = function(key) {
      this.domStorage_.removeItem(this.prefixedName_(key));
    };
    DOMStorageWrapper2.prototype.prefixedName_ = function(name10) {
      return this.prefix_ + name10;
    };
    DOMStorageWrapper2.prototype.toString = function() {
      return this.domStorage_.toString();
    };
    return DOMStorageWrapper2;
  }()
);
var MemoryStorage = (
  /** @class */
  function() {
    function MemoryStorage2() {
      this.cache_ = {};
      this.isInMemoryStorage = true;
    }
    MemoryStorage2.prototype.set = function(key, value) {
      if (value == null) {
        delete this.cache_[key];
      } else {
        this.cache_[key] = value;
      }
    };
    MemoryStorage2.prototype.get = function(key) {
      if (contains(this.cache_, key)) {
        return this.cache_[key];
      }
      return null;
    };
    MemoryStorage2.prototype.remove = function(key) {
      delete this.cache_[key];
    };
    return MemoryStorage2;
  }()
);
var createStoragefor = function(domStorageName) {
  try {
    if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
      var domStorage = window[domStorageName];
      domStorage.setItem("firebase:sentinel", "cache");
      domStorage.removeItem("firebase:sentinel");
      return new DOMStorageWrapper(domStorage);
    }
  } catch (e) {
  }
  return new MemoryStorage();
};
var PersistentStorage = createStoragefor("localStorage");
var SessionStorage = createStoragefor("sessionStorage");
var logClient = new Logger("@firebase/database");
var LUIDGenerator = /* @__PURE__ */ function() {
  var id2 = 1;
  return function() {
    return id2++;
  };
}();
var sha1 = function(str) {
  var utf8Bytes = stringToByteArray$1(str);
  var sha12 = new Sha1();
  sha12.update(utf8Bytes);
  var sha1Bytes = sha12.digest();
  return base64.encodeByteArray(sha1Bytes);
};
var buildLogMessage_ = function() {
  var varArgs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    varArgs[_i2] = arguments[_i2];
  }
  var message = "";
  for (var i = 0; i < varArgs.length; i++) {
    var arg = varArgs[i];
    if (Array.isArray(arg) || arg && typeof arg === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof arg.length === "number") {
      message += buildLogMessage_.apply(null, arg);
    } else if (typeof arg === "object") {
      message += stringify(arg);
    } else {
      message += arg;
    }
    message += " ";
  }
  return message;
};
var logger2 = null;
var firstLog_ = true;
var enableLogging = function(logger_, persistent) {
  assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
  if (logger_ === true) {
    logClient.logLevel = LogLevel.VERBOSE;
    logger2 = logClient.log.bind(logClient);
    if (persistent) {
      SessionStorage.set("logging_enabled", true);
    }
  } else if (typeof logger_ === "function") {
    logger2 = logger_;
  } else {
    logger2 = null;
    SessionStorage.remove("logging_enabled");
  }
};
var log = function() {
  var varArgs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    varArgs[_i2] = arguments[_i2];
  }
  if (firstLog_ === true) {
    firstLog_ = false;
    if (logger2 === null && SessionStorage.get("logging_enabled") === true) {
      enableLogging(true);
    }
  }
  if (logger2) {
    var message = buildLogMessage_.apply(null, varArgs);
    logger2(message);
  }
};
var logWrapper = function(prefix) {
  return function() {
    var varArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      varArgs[_i2] = arguments[_i2];
    }
    log.apply(void 0, __spreadArray([prefix], __read(varArgs)));
  };
};
var error = function() {
  var varArgs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    varArgs[_i2] = arguments[_i2];
  }
  var message = "FIREBASE INTERNAL ERROR: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.error(message);
};
var fatal = function() {
  var varArgs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    varArgs[_i2] = arguments[_i2];
  }
  var message = "FIREBASE FATAL ERROR: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.error(message);
  throw new Error(message);
};
var warn = function() {
  var varArgs = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    varArgs[_i2] = arguments[_i2];
  }
  var message = "FIREBASE WARNING: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.warn(message);
};
var warnIfPageIsSecure = function() {
  if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
    warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
  }
};
var isInvalidJSONNumber = function(data) {
  return typeof data === "number" && (data !== data || // NaN
  data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
};
var executeWhenDOMReady = function(fn2) {
  if (isNodeSdk() || document.readyState === "complete") {
    fn2();
  } else {
    var called_1 = false;
    var wrappedFn_1 = function() {
      if (!document.body) {
        setTimeout(wrappedFn_1, Math.floor(10));
        return;
      }
      if (!called_1) {
        called_1 = true;
        fn2();
      }
    };
    if (document.addEventListener) {
      document.addEventListener("DOMContentLoaded", wrappedFn_1, false);
      window.addEventListener("load", wrappedFn_1, false);
    } else if (document.attachEvent) {
      document.attachEvent("onreadystatechange", function() {
        if (document.readyState === "complete") {
          wrappedFn_1();
        }
      });
      window.attachEvent("onload", wrappedFn_1);
    }
  }
};
var MIN_NAME = "[MIN_NAME]";
var MAX_NAME = "[MAX_NAME]";
var nameCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a === MIN_NAME || b === MAX_NAME) {
    return -1;
  } else if (b === MIN_NAME || a === MAX_NAME) {
    return 1;
  } else {
    var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
    if (aAsInt !== null) {
      if (bAsInt !== null) {
        return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
      } else {
        return -1;
      }
    } else if (bAsInt !== null) {
      return 1;
    } else {
      return a < b ? -1 : 1;
    }
  }
};
var stringCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a < b) {
    return -1;
  } else {
    return 1;
  }
};
var requireKey = function(key, obj) {
  if (obj && key in obj) {
    return obj[key];
  } else {
    throw new Error("Missing required key (" + key + ") in object: " + stringify(obj));
  }
};
var ObjectToUniqueKey = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return stringify(obj);
  }
  var keys = [];
  for (var k3 in obj) {
    keys.push(k3);
  }
  keys.sort();
  var key = "{";
  for (var i = 0; i < keys.length; i++) {
    if (i !== 0) {
      key += ",";
    }
    key += stringify(keys[i]);
    key += ":";
    key += ObjectToUniqueKey(obj[keys[i]]);
  }
  key += "}";
  return key;
};
var splitStringBySize = function(str, segsize) {
  var len = str.length;
  if (len <= segsize) {
    return [str];
  }
  var dataSegs = [];
  for (var c = 0; c < len; c += segsize) {
    if (c + segsize > len) {
      dataSegs.push(str.substring(c, len));
    } else {
      dataSegs.push(str.substring(c, c + segsize));
    }
  }
  return dataSegs;
};
function each(obj, fn2) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn2(key, obj[key]);
    }
  }
}
var doubleToIEEE754String = function(v2) {
  assert(!isInvalidJSONNumber(v2), "Invalid JSON number");
  var ebits = 11, fbits = 52;
  var bias = (1 << ebits - 1) - 1;
  var s, e, f, ln2, i;
  if (v2 === 0) {
    e = 0;
    f = 0;
    s = 1 / v2 === -Infinity ? 1 : 0;
  } else {
    s = v2 < 0;
    v2 = Math.abs(v2);
    if (v2 >= Math.pow(2, 1 - bias)) {
      ln2 = Math.min(Math.floor(Math.log(v2) / Math.LN2), bias);
      e = ln2 + bias;
      f = Math.round(v2 * Math.pow(2, fbits - ln2) - Math.pow(2, fbits));
    } else {
      e = 0;
      f = Math.round(v2 / Math.pow(2, 1 - bias - fbits));
    }
  }
  var bits = [];
  for (i = fbits; i; i -= 1) {
    bits.push(f % 2 ? 1 : 0);
    f = Math.floor(f / 2);
  }
  for (i = ebits; i; i -= 1) {
    bits.push(e % 2 ? 1 : 0);
    e = Math.floor(e / 2);
  }
  bits.push(s ? 1 : 0);
  bits.reverse();
  var str = bits.join("");
  var hexByteString = "";
  for (i = 0; i < 64; i += 8) {
    var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
    if (hexByte.length === 1) {
      hexByte = "0" + hexByte;
    }
    hexByteString = hexByteString + hexByte;
  }
  return hexByteString.toLowerCase();
};
var isChromeExtensionContentScript = function() {
  return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
};
var isWindowsStoreApp = function() {
  return typeof Windows === "object" && typeof Windows.UI === "object";
};
var errorForServerCode = function(code, query) {
  var reason = "Unknown Error";
  if (code === "too_big") {
    reason = "The data requested exceeds the maximum size that can be accessed with a single request.";
  } else if (code === "permission_denied") {
    reason = "Client doesn't have permission to access the desired data.";
  } else if (code === "unavailable") {
    reason = "The service is unavailable";
  }
  var error2 = new Error(code + " at " + query.path.toString() + ": " + reason);
  error2.code = code.toUpperCase();
  return error2;
};
var INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
var INTEGER_32_MIN = -2147483648;
var INTEGER_32_MAX = 2147483647;
var tryParseInt = function(str) {
  if (INTEGER_REGEXP_.test(str)) {
    var intVal = Number(str);
    if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
      return intVal;
    }
  }
  return null;
};
var exceptionGuard = function(fn2) {
  try {
    fn2();
  } catch (e) {
    setTimeout(function() {
      var stack = e.stack || "";
      warn("Exception was thrown by user callback.", stack);
      throw e;
    }, Math.floor(0));
  }
};
var beingCrawled = function() {
  var userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
  return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
};
var setTimeoutNonBlocking = function(fn2, time) {
  var timeout = setTimeout(fn2, time);
  if (typeof timeout === "object" && timeout["unref"]) {
    timeout["unref"]();
  }
  return timeout;
};
var MAX_PATH_DEPTH = 32;
var MAX_PATH_LENGTH_BYTES = 768;
var Path = (
  /** @class */
  function() {
    function Path2(pathOrString, pieceNum) {
      if (pieceNum === void 0) {
        this.pieces_ = pathOrString.split("/");
        var copyTo = 0;
        for (var i = 0; i < this.pieces_.length; i++) {
          if (this.pieces_[i].length > 0) {
            this.pieces_[copyTo] = this.pieces_[i];
            copyTo++;
          }
        }
        this.pieces_.length = copyTo;
        this.pieceNum_ = 0;
      } else {
        this.pieces_ = pathOrString;
        this.pieceNum_ = pieceNum;
      }
    }
    Path2.prototype.toString = function() {
      var pathString = "";
      for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
        if (this.pieces_[i] !== "") {
          pathString += "/" + this.pieces_[i];
        }
      }
      return pathString || "/";
    };
    return Path2;
  }()
);
function newEmptyPath() {
  return new Path("");
}
function pathGetFront(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  return path.pieces_[path.pieceNum_];
}
function pathGetLength(path) {
  return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) {
  var pieceNum = path.pieceNum_;
  if (pieceNum < path.pieces_.length) {
    pieceNum++;
  }
  return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) {
  if (path.pieceNum_ < path.pieces_.length) {
    return path.pieces_[path.pieces_.length - 1];
  }
  return null;
}
function pathToUrlEncodedString(path) {
  var pathString = "";
  for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
    if (path.pieces_[i] !== "") {
      pathString += "/" + encodeURIComponent(String(path.pieces_[i]));
    }
  }
  return pathString || "/";
}
function pathSlice(path, begin) {
  if (begin === void 0) {
    begin = 0;
  }
  return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  var pieces = [];
  for (var i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
    pieces.push(path.pieces_[i]);
  }
  return new Path(pieces, 0);
}
function pathChild(path, childPathObj) {
  var pieces = [];
  for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
    pieces.push(path.pieces_[i]);
  }
  if (childPathObj instanceof Path) {
    for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
      pieces.push(childPathObj.pieces_[i]);
    }
  } else {
    var childPieces = childPathObj.split("/");
    for (var i = 0; i < childPieces.length; i++) {
      if (childPieces[i].length > 0) {
        pieces.push(childPieces[i]);
      }
    }
  }
  return new Path(pieces, 0);
}
function pathIsEmpty(path) {
  return path.pieceNum_ >= path.pieces_.length;
}
function newRelativePath(outerPath, innerPath) {
  var outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
  if (outer === null) {
    return innerPath;
  } else if (outer === inner) {
    return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
  } else {
    throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
  }
}
function pathCompare(left, right) {
  var leftKeys = pathSlice(left, 0);
  var rightKeys = pathSlice(right, 0);
  for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
    var cmp = nameCompare(leftKeys[i], rightKeys[i]);
    if (cmp !== 0) {
      return cmp;
    }
  }
  if (leftKeys.length === rightKeys.length) {
    return 0;
  }
  return leftKeys.length < rightKeys.length ? -1 : 1;
}
function pathEquals(path, other) {
  if (pathGetLength(path) !== pathGetLength(other)) {
    return false;
  }
  for (var i = path.pieceNum_, j2 = other.pieceNum_; i <= path.pieces_.length; i++, j2++) {
    if (path.pieces_[i] !== other.pieces_[j2]) {
      return false;
    }
  }
  return true;
}
function pathContains(path, other) {
  var i = path.pieceNum_;
  var j2 = other.pieceNum_;
  if (pathGetLength(path) > pathGetLength(other)) {
    return false;
  }
  while (i < path.pieces_.length) {
    if (path.pieces_[i] !== other.pieces_[j2]) {
      return false;
    }
    ++i;
    ++j2;
  }
  return true;
}
var ValidationPath = (
  /** @class */
  /* @__PURE__ */ function() {
    function ValidationPath2(path, errorPrefix_) {
      this.errorPrefix_ = errorPrefix_;
      this.parts_ = pathSlice(path, 0);
      this.byteLength_ = Math.max(1, this.parts_.length);
      for (var i = 0; i < this.parts_.length; i++) {
        this.byteLength_ += stringLength(this.parts_[i]);
      }
      validationPathCheckValid(this);
    }
    return ValidationPath2;
  }()
);
function validationPathPush(validationPath, child2) {
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ += 1;
  }
  validationPath.parts_.push(child2);
  validationPath.byteLength_ += stringLength(child2);
  validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) {
  var last = validationPath.parts_.pop();
  validationPath.byteLength_ -= stringLength(last);
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ -= 1;
  }
}
function validationPathCheckValid(validationPath) {
  if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
    throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
  }
  if (validationPath.parts_.length > MAX_PATH_DEPTH) {
    throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
  }
}
function validationPathToErrorString(validationPath) {
  if (validationPath.parts_.length === 0) {
    return "";
  }
  return "in property '" + validationPath.parts_.join(".") + "'";
}
var PROTOCOL_VERSION = "5";
var VERSION_PARAM = "v";
var TRANSPORT_SESSION_PARAM = "s";
var REFERER_PARAM = "r";
var FORGE_REF = "f";
var FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
var LAST_SESSION_PARAM = "ls";
var APPLICATION_ID_PARAM = "p";
var WEBSOCKET = "websocket";
var LONG_POLLING = "long_polling";
var RepoInfo = (
  /** @class */
  function() {
    function RepoInfo2(host, secure, namespace, webSocketOnly, nodeAdmin, persistenceKey, includeNamespaceInQueryParams) {
      if (nodeAdmin === void 0) {
        nodeAdmin = false;
      }
      if (persistenceKey === void 0) {
        persistenceKey = "";
      }
      if (includeNamespaceInQueryParams === void 0) {
        includeNamespaceInQueryParams = false;
      }
      this.secure = secure;
      this.namespace = namespace;
      this.webSocketOnly = webSocketOnly;
      this.nodeAdmin = nodeAdmin;
      this.persistenceKey = persistenceKey;
      this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
      this._host = host.toLowerCase();
      this._domain = this._host.substr(this._host.indexOf(".") + 1);
      this.internalHost = PersistentStorage.get("host:" + host) || this._host;
    }
    RepoInfo2.prototype.isCacheableHost = function() {
      return this.internalHost.substr(0, 2) === "s-";
    };
    RepoInfo2.prototype.isCustomHost = function() {
      return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
    };
    Object.defineProperty(RepoInfo2.prototype, "host", {
      get: function() {
        return this._host;
      },
      set: function(newHost) {
        if (newHost !== this.internalHost) {
          this.internalHost = newHost;
          if (this.isCacheableHost()) {
            PersistentStorage.set("host:" + this._host, this.internalHost);
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    RepoInfo2.prototype.toString = function() {
      var str = this.toURLString();
      if (this.persistenceKey) {
        str += "<" + this.persistenceKey + ">";
      }
      return str;
    };
    RepoInfo2.prototype.toURLString = function() {
      var protocol = this.secure ? "https://" : "http://";
      var query = this.includeNamespaceInQueryParams ? "?ns=" + this.namespace : "";
      return "" + protocol + this.host + "/" + query;
    };
    return RepoInfo2;
  }()
);
function repoInfoNeedsQueryParam(repoInfo) {
  return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
}
function repoInfoConnectionURL(repoInfo, type, params) {
  assert(typeof type === "string", "typeof type must == string");
  assert(typeof params === "object", "typeof params must == object");
  var connURL;
  if (type === WEBSOCKET) {
    connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
  } else if (type === LONG_POLLING) {
    connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
  } else {
    throw new Error("Unknown connection type: " + type);
  }
  if (repoInfoNeedsQueryParam(repoInfo)) {
    params["ns"] = repoInfo.namespace;
  }
  var pairs = [];
  each(params, function(key, value) {
    pairs.push(key + "=" + value);
  });
  return connURL + pairs.join("&");
}
function decodePath(pathString) {
  var pathStringDecoded = "";
  var pieces = pathString.split("/");
  for (var i = 0; i < pieces.length; i++) {
    if (pieces[i].length > 0) {
      var piece = pieces[i];
      try {
        piece = decodeURIComponent(piece.replace(/\+/g, " "));
      } catch (e) {
      }
      pathStringDecoded += "/" + piece;
    }
  }
  return pathStringDecoded;
}
function decodeQuery(queryString) {
  var e_1, _a9;
  var results = {};
  if (queryString.charAt(0) === "?") {
    queryString = queryString.substring(1);
  }
  try {
    for (var _b = __values(queryString.split("&")), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
      var segment = _c2.value;
      if (segment.length === 0) {
        continue;
      }
      var kv = segment.split("=");
      if (kv.length === 2) {
        results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
      } else {
        warn("Invalid query segment '" + segment + "' in query '" + queryString + "'");
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c2 && !_c2.done && (_a9 = _b.return))
        _a9.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return results;
}
var parseRepoInfo = function(dataURL, nodeAdmin) {
  var parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
  if (parsedUrl.domain === "firebase.com") {
    fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
  }
  if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
    fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
  }
  if (!parsedUrl.secure) {
    warnIfPageIsSecure();
  }
  var webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
  return {
    repoInfo: new RepoInfo(
      parsedUrl.host,
      parsedUrl.secure,
      namespace,
      nodeAdmin,
      webSocketOnly,
      /*persistenceKey=*/
      "",
      /*includeNamespaceInQueryParams=*/
      namespace !== parsedUrl.subdomain
    ),
    path: new Path(parsedUrl.pathString)
  };
};
var parseDatabaseURL = function(dataURL) {
  var host = "", domain = "", subdomain = "", pathString = "", namespace = "";
  var secure = true, scheme = "https", port = 443;
  if (typeof dataURL === "string") {
    var colonInd = dataURL.indexOf("//");
    if (colonInd >= 0) {
      scheme = dataURL.substring(0, colonInd - 1);
      dataURL = dataURL.substring(colonInd + 2);
    }
    var slashInd = dataURL.indexOf("/");
    if (slashInd === -1) {
      slashInd = dataURL.length;
    }
    var questionMarkInd = dataURL.indexOf("?");
    if (questionMarkInd === -1) {
      questionMarkInd = dataURL.length;
    }
    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
    if (slashInd < questionMarkInd) {
      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
    }
    var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
    colonInd = host.indexOf(":");
    if (colonInd >= 0) {
      secure = scheme === "https" || scheme === "wss";
      port = parseInt(host.substring(colonInd + 1), 10);
    } else {
      colonInd = host.length;
    }
    var hostWithoutPort = host.slice(0, colonInd);
    if (hostWithoutPort.toLowerCase() === "localhost") {
      domain = "localhost";
    } else if (hostWithoutPort.split(".").length <= 2) {
      domain = hostWithoutPort;
    } else {
      var dotInd = host.indexOf(".");
      subdomain = host.substring(0, dotInd).toLowerCase();
      domain = host.substring(dotInd + 1);
      namespace = subdomain;
    }
    if ("ns" in queryParams) {
      namespace = queryParams["ns"];
    }
  }
  return {
    host,
    port,
    domain,
    subdomain,
    secure,
    scheme,
    pathString,
    namespace
  };
};
var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
var isValidKey2 = function(key) {
  return typeof key === "string" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);
};
var isValidPathString = function(pathString) {
  return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
};
var isValidRootPathString = function(pathString) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  return isValidPathString(pathString);
};
var isValidPriority = function(priority) {
  return priority === null || typeof priority === "string" || typeof priority === "number" && !isInvalidJSONNumber(priority) || priority && typeof priority === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  contains(priority, ".sv");
};
var validateFirebaseDataArg = function(fnName, argumentNumber, data, path, optional) {
  if (optional && data === void 0) {
    return;
  }
  validateFirebaseData(errorPrefix(fnName, argumentNumber, optional), data, path);
};
var validateFirebaseData = function(errorPrefix2, data, path_) {
  var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix2) : path_;
  if (data === void 0) {
    throw new Error(errorPrefix2 + "contains undefined " + validationPathToErrorString(path));
  }
  if (typeof data === "function") {
    throw new Error(errorPrefix2 + "contains a function " + validationPathToErrorString(path) + " with contents = " + data.toString());
  }
  if (isInvalidJSONNumber(data)) {
    throw new Error(errorPrefix2 + "contains " + data.toString() + " " + validationPathToErrorString(path));
  }
  if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && stringLength(data) > MAX_LEAF_SIZE_) {
    throw new Error(errorPrefix2 + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path) + " ('" + data.substring(0, 50) + "...')");
  }
  if (data && typeof data === "object") {
    var hasDotValue_1 = false;
    var hasActualChild_1 = false;
    each(data, function(key, value) {
      if (key === ".value") {
        hasDotValue_1 = true;
      } else if (key !== ".priority" && key !== ".sv") {
        hasActualChild_1 = true;
        if (!isValidKey2(key)) {
          throw new Error(errorPrefix2 + " contains an invalid key (" + key + ") " + validationPathToErrorString(path) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
        }
      }
      validationPathPush(path, key);
      validateFirebaseData(errorPrefix2, value, path);
      validationPathPop(path);
    });
    if (hasDotValue_1 && hasActualChild_1) {
      throw new Error(errorPrefix2 + ' contains ".value" child ' + validationPathToErrorString(path) + " in addition to actual children.");
    }
  }
};
var validateFirebaseMergePaths = function(errorPrefix2, mergePaths) {
  var i, curPath;
  for (i = 0; i < mergePaths.length; i++) {
    curPath = mergePaths[i];
    var keys = pathSlice(curPath);
    for (var j2 = 0; j2 < keys.length; j2++) {
      if (keys[j2] === ".priority" && j2 === keys.length - 1)
        ;
      else if (!isValidKey2(keys[j2])) {
        throw new Error(errorPrefix2 + "contains an invalid key (" + keys[j2] + ") in path " + curPath.toString() + `. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
      }
    }
  }
  mergePaths.sort(pathCompare);
  var prevPath = null;
  for (i = 0; i < mergePaths.length; i++) {
    curPath = mergePaths[i];
    if (prevPath !== null && pathContains(prevPath, curPath)) {
      throw new Error(errorPrefix2 + "contains a path " + prevPath.toString() + " that is ancestor of another path " + curPath.toString());
    }
    prevPath = curPath;
  }
};
var validateFirebaseMergeDataArg = function(fnName, argumentNumber, data, path, optional) {
  if (optional && data === void 0) {
    return;
  }
  var errorPrefix$1 = errorPrefix(fnName, argumentNumber, optional);
  if (!(data && typeof data === "object") || Array.isArray(data)) {
    throw new Error(errorPrefix$1 + " must be an object containing the children to replace.");
  }
  var mergePaths = [];
  each(data, function(key, value) {
    var curPath = new Path(key);
    validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));
    if (pathGetBack(curPath) === ".priority") {
      if (!isValidPriority(value)) {
        throw new Error(errorPrefix$1 + "contains an invalid value for '" + curPath.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
    }
    mergePaths.push(curPath);
  });
  validateFirebaseMergePaths(errorPrefix$1, mergePaths);
};
var validatePriority = function(fnName, argumentNumber, priority, optional) {
  if (optional && priority === void 0) {
    return;
  }
  if (isInvalidJSONNumber(priority)) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + "is " + priority.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
  }
  if (!isValidPriority(priority)) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid Firebase priority (a string, finite number, server value, or null).");
  }
};
var validateEventType = function(fnName, argumentNumber, eventType, optional) {
  if (optional && eventType === void 0) {
    return;
  }
  switch (eventType) {
    case "value":
    case "child_added":
    case "child_removed":
    case "child_changed":
    case "child_moved":
      break;
    default:
      throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
  }
};
var validateKey = function(fnName, argumentNumber, key, optional) {
  if (optional && key === void 0) {
    return;
  }
  if (!isValidKey2(key)) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'was an invalid key = "' + key + `".  Firebase keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]").`);
  }
};
var validatePathString = function(fnName, argumentNumber, pathString, optional) {
  if (optional && pathString === void 0) {
    return;
  }
  if (!isValidPathString(pathString)) {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'was an invalid path = "' + pathString + `". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`);
  }
};
var validateRootPathString = function(fnName, argumentNumber, pathString, optional) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  validatePathString(fnName, argumentNumber, pathString, optional);
};
var validateWritablePath = function(fnName, path) {
  if (pathGetFront(path) === ".info") {
    throw new Error(fnName + " failed = Can't modify data under /.info/");
  }
};
var validateUrl = function(fnName, argumentNumber, parsedUrl) {
  var pathString = parsedUrl.path.toString();
  if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey2(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
    throw new Error(errorPrefix(fnName, argumentNumber, false) + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`);
  }
};
var validateBoolean = function(fnName, argumentNumber, bool, optional) {
  if (optional && bool === void 0) {
    return;
  }
  if (typeof bool !== "boolean") {
    throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a boolean.");
  }
};
var MAX_NODE;
function setMaxNode(val) {
  MAX_NODE = val;
}
var priorityHashText = function(priority) {
  if (typeof priority === "number") {
    return "number:" + doubleToIEEE754String(priority);
  } else {
    return "string:" + priority;
  }
};
var validatePriorityNode = function(priorityNode) {
  if (priorityNode.isLeafNode()) {
    var val = priorityNode.val();
    assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && contains(val, ".sv"), "Priority must be a string or number.");
  } else {
    assert(priorityNode === MAX_NODE || priorityNode.isEmpty(), "priority of unexpected type.");
  }
  assert(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};
var __childrenNodeConstructor;
var LeafNode = (
  /** @class */
  function() {
    function LeafNode2(value_, priorityNode_) {
      if (priorityNode_ === void 0) {
        priorityNode_ = LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
      this.value_ = value_;
      this.priorityNode_ = priorityNode_;
      this.lazyHash_ = null;
      assert(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
      validatePriorityNode(this.priorityNode_);
    }
    Object.defineProperty(LeafNode2, "__childrenNodeConstructor", {
      get: function() {
        return __childrenNodeConstructor;
      },
      set: function(val) {
        __childrenNodeConstructor = val;
      },
      enumerable: false,
      configurable: true
    });
    LeafNode2.prototype.isLeafNode = function() {
      return true;
    };
    LeafNode2.prototype.getPriority = function() {
      return this.priorityNode_;
    };
    LeafNode2.prototype.updatePriority = function(newPriorityNode) {
      return new LeafNode2(this.value_, newPriorityNode);
    };
    LeafNode2.prototype.getImmediateChild = function(childName) {
      if (childName === ".priority") {
        return this.priorityNode_;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
    };
    LeafNode2.prototype.getChild = function(path) {
      if (pathIsEmpty(path)) {
        return this;
      } else if (pathGetFront(path) === ".priority") {
        return this.priorityNode_;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
    };
    LeafNode2.prototype.hasChild = function() {
      return false;
    };
    LeafNode2.prototype.getPredecessorChildName = function(childName, childNode) {
      return null;
    };
    LeafNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
      if (childName === ".priority") {
        return this.updatePriority(newChildNode);
      } else if (newChildNode.isEmpty() && childName !== ".priority") {
        return this;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
      }
    };
    LeafNode2.prototype.updateChild = function(path, newChildNode) {
      var front = pathGetFront(path);
      if (front === null) {
        return newChildNode;
      } else if (newChildNode.isEmpty() && front !== ".priority") {
        return this;
      } else {
        assert(front !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
        return this.updateImmediateChild(front, LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
      }
    };
    LeafNode2.prototype.isEmpty = function() {
      return false;
    };
    LeafNode2.prototype.numChildren = function() {
      return 0;
    };
    LeafNode2.prototype.forEachChild = function(index, action) {
      return false;
    };
    LeafNode2.prototype.val = function(exportFormat) {
      if (exportFormat && !this.getPriority().isEmpty()) {
        return {
          ".value": this.getValue(),
          ".priority": this.getPriority().val()
        };
      } else {
        return this.getValue();
      }
    };
    LeafNode2.prototype.hash = function() {
      if (this.lazyHash_ === null) {
        var toHash = "";
        if (!this.priorityNode_.isEmpty()) {
          toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
        }
        var type = typeof this.value_;
        toHash += type + ":";
        if (type === "number") {
          toHash += doubleToIEEE754String(this.value_);
        } else {
          toHash += this.value_;
        }
        this.lazyHash_ = sha1(toHash);
      }
      return this.lazyHash_;
    };
    LeafNode2.prototype.getValue = function() {
      return this.value_;
    };
    LeafNode2.prototype.compareTo = function(other) {
      if (other === LeafNode2.__childrenNodeConstructor.EMPTY_NODE) {
        return 1;
      } else if (other instanceof LeafNode2.__childrenNodeConstructor) {
        return -1;
      } else {
        assert(other.isLeafNode(), "Unknown node type");
        return this.compareToLeafNode_(other);
      }
    };
    LeafNode2.prototype.compareToLeafNode_ = function(otherLeaf) {
      var otherLeafType = typeof otherLeaf.value_;
      var thisLeafType = typeof this.value_;
      var otherIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(otherLeafType);
      var thisIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(thisLeafType);
      assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
      assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
      if (otherIndex === thisIndex) {
        if (thisLeafType === "object") {
          return 0;
        } else {
          if (this.value_ < otherLeaf.value_) {
            return -1;
          } else if (this.value_ === otherLeaf.value_) {
            return 0;
          } else {
            return 1;
          }
        }
      } else {
        return thisIndex - otherIndex;
      }
    };
    LeafNode2.prototype.withIndex = function() {
      return this;
    };
    LeafNode2.prototype.isIndexed = function() {
      return true;
    };
    LeafNode2.prototype.equals = function(other) {
      if (other === this) {
        return true;
      } else if (other.isLeafNode()) {
        var otherLeaf = other;
        return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
      } else {
        return false;
      }
    };
    LeafNode2.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
    return LeafNode2;
  }()
);
var SortedMapIterator = (
  /** @class */
  function() {
    function SortedMapIterator2(node, startKey, comparator, isReverse_, resultGenerator_) {
      if (resultGenerator_ === void 0) {
        resultGenerator_ = null;
      }
      this.isReverse_ = isReverse_;
      this.resultGenerator_ = resultGenerator_;
      this.nodeStack_ = [];
      var cmp = 1;
      while (!node.isEmpty()) {
        node = node;
        cmp = startKey ? comparator(node.key, startKey) : 1;
        if (isReverse_) {
          cmp *= -1;
        }
        if (cmp < 0) {
          if (this.isReverse_) {
            node = node.left;
          } else {
            node = node.right;
          }
        } else if (cmp === 0) {
          this.nodeStack_.push(node);
          break;
        } else {
          this.nodeStack_.push(node);
          if (this.isReverse_) {
            node = node.right;
          } else {
            node = node.left;
          }
        }
      }
    }
    SortedMapIterator2.prototype.getNext = function() {
      if (this.nodeStack_.length === 0) {
        return null;
      }
      var node = this.nodeStack_.pop();
      var result;
      if (this.resultGenerator_) {
        result = this.resultGenerator_(node.key, node.value);
      } else {
        result = { key: node.key, value: node.value };
      }
      if (this.isReverse_) {
        node = node.left;
        while (!node.isEmpty()) {
          this.nodeStack_.push(node);
          node = node.right;
        }
      } else {
        node = node.right;
        while (!node.isEmpty()) {
          this.nodeStack_.push(node);
          node = node.left;
        }
      }
      return result;
    };
    SortedMapIterator2.prototype.hasNext = function() {
      return this.nodeStack_.length > 0;
    };
    SortedMapIterator2.prototype.peek = function() {
      if (this.nodeStack_.length === 0) {
        return null;
      }
      var node = this.nodeStack_[this.nodeStack_.length - 1];
      if (this.resultGenerator_) {
        return this.resultGenerator_(node.key, node.value);
      } else {
        return { key: node.key, value: node.value };
      }
    };
    return SortedMapIterator2;
  }()
);
var LLRBNode = (
  /** @class */
  function() {
    function LLRBNode2(key, value, color, left, right) {
      this.key = key;
      this.value = value;
      this.color = color != null ? color : LLRBNode2.RED;
      this.left = left != null ? left : SortedMap.EMPTY_NODE;
      this.right = right != null ? right : SortedMap.EMPTY_NODE;
    }
    LLRBNode2.prototype.copy = function(key, value, color, left, right) {
      return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    LLRBNode2.prototype.count = function() {
      return this.left.count() + 1 + this.right.count();
    };
    LLRBNode2.prototype.isEmpty = function() {
      return false;
    };
    LLRBNode2.prototype.inorderTraversal = function(action) {
      return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
    };
    LLRBNode2.prototype.reverseTraversal = function(action) {
      return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
    };
    LLRBNode2.prototype.min_ = function() {
      if (this.left.isEmpty()) {
        return this;
      } else {
        return this.left.min_();
      }
    };
    LLRBNode2.prototype.minKey = function() {
      return this.min_().key;
    };
    LLRBNode2.prototype.maxKey = function() {
      if (this.right.isEmpty()) {
        return this.key;
      } else {
        return this.right.maxKey();
      }
    };
    LLRBNode2.prototype.insert = function(key, value, comparator) {
      var n2 = this;
      var cmp = comparator(key, n2.key);
      if (cmp < 0) {
        n2 = n2.copy(null, null, null, n2.left.insert(key, value, comparator), null);
      } else if (cmp === 0) {
        n2 = n2.copy(null, value, null, null, null);
      } else {
        n2 = n2.copy(null, null, null, null, n2.right.insert(key, value, comparator));
      }
      return n2.fixUp_();
    };
    LLRBNode2.prototype.removeMin_ = function() {
      if (this.left.isEmpty()) {
        return SortedMap.EMPTY_NODE;
      }
      var n2 = this;
      if (!n2.left.isRed_() && !n2.left.left.isRed_()) {
        n2 = n2.moveRedLeft_();
      }
      n2 = n2.copy(null, null, null, n2.left.removeMin_(), null);
      return n2.fixUp_();
    };
    LLRBNode2.prototype.remove = function(key, comparator) {
      var n2, smallest;
      n2 = this;
      if (comparator(key, n2.key) < 0) {
        if (!n2.left.isEmpty() && !n2.left.isRed_() && !n2.left.left.isRed_()) {
          n2 = n2.moveRedLeft_();
        }
        n2 = n2.copy(null, null, null, n2.left.remove(key, comparator), null);
      } else {
        if (n2.left.isRed_()) {
          n2 = n2.rotateRight_();
        }
        if (!n2.right.isEmpty() && !n2.right.isRed_() && !n2.right.left.isRed_()) {
          n2 = n2.moveRedRight_();
        }
        if (comparator(key, n2.key) === 0) {
          if (n2.right.isEmpty()) {
            return SortedMap.EMPTY_NODE;
          } else {
            smallest = n2.right.min_();
            n2 = n2.copy(smallest.key, smallest.value, null, null, n2.right.removeMin_());
          }
        }
        n2 = n2.copy(null, null, null, null, n2.right.remove(key, comparator));
      }
      return n2.fixUp_();
    };
    LLRBNode2.prototype.isRed_ = function() {
      return this.color;
    };
    LLRBNode2.prototype.fixUp_ = function() {
      var n2 = this;
      if (n2.right.isRed_() && !n2.left.isRed_()) {
        n2 = n2.rotateLeft_();
      }
      if (n2.left.isRed_() && n2.left.left.isRed_()) {
        n2 = n2.rotateRight_();
      }
      if (n2.left.isRed_() && n2.right.isRed_()) {
        n2 = n2.colorFlip_();
      }
      return n2;
    };
    LLRBNode2.prototype.moveRedLeft_ = function() {
      var n2 = this.colorFlip_();
      if (n2.right.left.isRed_()) {
        n2 = n2.copy(null, null, null, null, n2.right.rotateRight_());
        n2 = n2.rotateLeft_();
        n2 = n2.colorFlip_();
      }
      return n2;
    };
    LLRBNode2.prototype.moveRedRight_ = function() {
      var n2 = this.colorFlip_();
      if (n2.left.left.isRed_()) {
        n2 = n2.rotateRight_();
        n2 = n2.colorFlip_();
      }
      return n2;
    };
    LLRBNode2.prototype.rotateLeft_ = function() {
      var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, nl, null);
    };
    LLRBNode2.prototype.rotateRight_ = function() {
      var nr2 = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, nr2);
    };
    LLRBNode2.prototype.colorFlip_ = function() {
      var left = this.left.copy(null, null, !this.left.color, null, null);
      var right = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, left, right);
    };
    LLRBNode2.prototype.checkMaxDepth_ = function() {
      var blackDepth = this.check_();
      return Math.pow(2, blackDepth) <= this.count() + 1;
    };
    LLRBNode2.prototype.check_ = function() {
      if (this.isRed_() && this.left.isRed_()) {
        throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
      }
      if (this.right.isRed_()) {
        throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
      }
      var blackDepth = this.left.check_();
      if (blackDepth !== this.right.check_()) {
        throw new Error("Black depths differ");
      } else {
        return blackDepth + (this.isRed_() ? 0 : 1);
      }
    };
    LLRBNode2.RED = true;
    LLRBNode2.BLACK = false;
    return LLRBNode2;
  }()
);
var LLRBEmptyNode = (
  /** @class */
  function() {
    function LLRBEmptyNode2() {
    }
    LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
      return this;
    };
    LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
      return new LLRBNode(key, value, null);
    };
    LLRBEmptyNode2.prototype.remove = function(key, comparator) {
      return this;
    };
    LLRBEmptyNode2.prototype.count = function() {
      return 0;
    };
    LLRBEmptyNode2.prototype.isEmpty = function() {
      return true;
    };
    LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.minKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.maxKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.check_ = function() {
      return 0;
    };
    LLRBEmptyNode2.prototype.isRed_ = function() {
      return false;
    };
    return LLRBEmptyNode2;
  }()
);
var SortedMap = (
  /** @class */
  function() {
    function SortedMap2(comparator_, root_) {
      if (root_ === void 0) {
        root_ = SortedMap2.EMPTY_NODE;
      }
      this.comparator_ = comparator_;
      this.root_ = root_;
    }
    SortedMap2.prototype.insert = function(key, value) {
      return new SortedMap2(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.remove = function(key) {
      return new SortedMap2(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.get = function(key) {
      var cmp;
      var node = this.root_;
      while (!node.isEmpty()) {
        cmp = this.comparator_(key, node.key);
        if (cmp === 0) {
          return node.value;
        } else if (cmp < 0) {
          node = node.left;
        } else if (cmp > 0) {
          node = node.right;
        }
      }
      return null;
    };
    SortedMap2.prototype.getPredecessorKey = function(key) {
      var cmp, node = this.root_, rightParent = null;
      while (!node.isEmpty()) {
        cmp = this.comparator_(key, node.key);
        if (cmp === 0) {
          if (!node.left.isEmpty()) {
            node = node.left;
            while (!node.right.isEmpty()) {
              node = node.right;
            }
            return node.key;
          } else if (rightParent) {
            return rightParent.key;
          } else {
            return null;
          }
        } else if (cmp < 0) {
          node = node.left;
        } else if (cmp > 0) {
          rightParent = node;
          node = node.right;
        }
      }
      throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
    };
    SortedMap2.prototype.isEmpty = function() {
      return this.root_.isEmpty();
    };
    SortedMap2.prototype.count = function() {
      return this.root_.count();
    };
    SortedMap2.prototype.minKey = function() {
      return this.root_.minKey();
    };
    SortedMap2.prototype.maxKey = function() {
      return this.root_.maxKey();
    };
    SortedMap2.prototype.inorderTraversal = function(action) {
      return this.root_.inorderTraversal(action);
    };
    SortedMap2.prototype.reverseTraversal = function(action) {
      return this.root_.reverseTraversal(action);
    };
    SortedMap2.prototype.getIterator = function(resultGenerator) {
      return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap2.prototype.getIteratorFrom = function(key, resultGenerator) {
      return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap2.prototype.getReverseIteratorFrom = function(key, resultGenerator) {
      return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap2.prototype.getReverseIterator = function(resultGenerator) {
      return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    SortedMap2.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap2;
  }()
);
var NamedNode = (
  /** @class */
  function() {
    function NamedNode2(name10, node) {
      this.name = name10;
      this.node = node;
    }
    NamedNode2.Wrap = function(name10, node) {
      return new NamedNode2(name10, node);
    };
    return NamedNode2;
  }()
);
var Index = (
  /** @class */
  function() {
    function Index3() {
    }
    Index3.prototype.getCompare = function() {
      return this.compare.bind(this);
    };
    Index3.prototype.indexedValueChanged = function(oldNode, newNode) {
      var oldWrapped = new NamedNode(MIN_NAME, oldNode);
      var newWrapped = new NamedNode(MIN_NAME, newNode);
      return this.compare(oldWrapped, newWrapped) !== 0;
    };
    Index3.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    return Index3;
  }()
);
var nodeFromJSON;
var MAX_NODE$1;
function setNodeFromJSON(val) {
  nodeFromJSON = val;
}
function setMaxNode$1(val) {
  MAX_NODE$1 = val;
}
var PriorityIndex = (
  /** @class */
  function(_super) {
    __extends(PriorityIndex2, _super);
    function PriorityIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PriorityIndex2.prototype.compare = function(a, b) {
      var aPriority = a.node.getPriority();
      var bPriority = b.node.getPriority();
      var indexCmp = aPriority.compareTo(bPriority);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    PriorityIndex2.prototype.isDefinedOn = function(node) {
      return !node.getPriority().isEmpty();
    };
    PriorityIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return !oldNode.getPriority().equals(newNode.getPriority());
    };
    PriorityIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    PriorityIndex2.prototype.maxPost = function() {
      return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
    };
    PriorityIndex2.prototype.makePost = function(indexValue, name10) {
      var priorityNode = nodeFromJSON(indexValue);
      return new NamedNode(name10, new LeafNode("[PRIORITY-POST]", priorityNode));
    };
    PriorityIndex2.prototype.toString = function() {
      return ".priority";
    };
    return PriorityIndex2;
  }(Index)
);
var PRIORITY_INDEX = new PriorityIndex();
var __EMPTY_NODE;
var KeyIndex = (
  /** @class */
  function(_super) {
    __extends(KeyIndex2, _super);
    function KeyIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex2, "__EMPTY_NODE", {
      get: function() {
        return __EMPTY_NODE;
      },
      set: function(val) {
        __EMPTY_NODE = val;
      },
      enumerable: false,
      configurable: true
    });
    KeyIndex2.prototype.compare = function(a, b) {
      return nameCompare(a.name, b.name);
    };
    KeyIndex2.prototype.isDefinedOn = function(node) {
      throw assertionError("KeyIndex.isDefinedOn not expected to be called.");
    };
    KeyIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return false;
    };
    KeyIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    KeyIndex2.prototype.maxPost = function() {
      return new NamedNode(MAX_NAME, __EMPTY_NODE);
    };
    KeyIndex2.prototype.makePost = function(indexValue, name10) {
      assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
      return new NamedNode(indexValue, __EMPTY_NODE);
    };
    KeyIndex2.prototype.toString = function() {
      return ".key";
    };
    return KeyIndex2;
  }(Index)
);
var KEY_INDEX = new KeyIndex();
var LOG_2 = Math.log(2);
var Base12Num = (
  /** @class */
  function() {
    function Base12Num2(length) {
      var logBase2 = function(num) {
        return parseInt(Math.log(num) / LOG_2, 10);
      };
      var bitMask = function(bits) {
        return parseInt(Array(bits + 1).join("1"), 2);
      };
      this.count = logBase2(length + 1);
      this.current_ = this.count - 1;
      var mask = bitMask(this.count);
      this.bits_ = length + 1 & mask;
    }
    Base12Num2.prototype.nextBitIsOne = function() {
      var result = !(this.bits_ & 1 << this.current_);
      this.current_--;
      return result;
    };
    return Base12Num2;
  }()
);
var buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
  childList.sort(cmp);
  var buildBalancedTree = function(low, high) {
    var length = high - low;
    var namedNode;
    var key;
    if (length === 0) {
      return null;
    } else if (length === 1) {
      namedNode = childList[low];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
    } else {
      var middle = parseInt(length / 2, 10) + low;
      var left = buildBalancedTree(low, middle);
      var right = buildBalancedTree(middle + 1, high);
      namedNode = childList[middle];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
    }
  };
  var buildFrom12Array = function(base122) {
    var node = null;
    var root2 = null;
    var index = childList.length;
    var buildPennant = function(chunkSize2, color) {
      var low = index - chunkSize2;
      var high = index;
      index -= chunkSize2;
      var childTree = buildBalancedTree(low + 1, high);
      var namedNode = childList[low];
      var key = keyFn ? keyFn(namedNode) : namedNode;
      attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
    };
    var attachPennant = function(pennant) {
      if (node) {
        node.left = pennant;
        node = pennant;
      } else {
        root2 = pennant;
        node = pennant;
      }
    };
    for (var i = 0; i < base122.count; ++i) {
      var isOne = base122.nextBitIsOne();
      var chunkSize = Math.pow(2, base122.count - (i + 1));
      if (isOne) {
        buildPennant(chunkSize, LLRBNode.BLACK);
      } else {
        buildPennant(chunkSize, LLRBNode.BLACK);
        buildPennant(chunkSize, LLRBNode.RED);
      }
    }
    return root2;
  };
  var base12 = new Base12Num(childList.length);
  var root = buildFrom12Array(base12);
  return new SortedMap(mapSortFn || cmp, root);
};
var _defaultIndexMap;
var fallbackObject = {};
var IndexMap = (
  /** @class */
  function() {
    function IndexMap2(indexes_, indexSet_) {
      this.indexes_ = indexes_;
      this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap2, "Default", {
      /**
       * The default IndexMap for nodes without a priority
       */
      get: function() {
        assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
        _defaultIndexMap = _defaultIndexMap || new IndexMap2({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
        return _defaultIndexMap;
      },
      enumerable: false,
      configurable: true
    });
    IndexMap2.prototype.get = function(indexKey) {
      var sortedMap = safeGet(this.indexes_, indexKey);
      if (!sortedMap) {
        throw new Error("No index defined for " + indexKey);
      }
      if (sortedMap instanceof SortedMap) {
        return sortedMap;
      } else {
        return null;
      }
    };
    IndexMap2.prototype.hasIndex = function(indexDefinition) {
      return contains(this.indexSet_, indexDefinition.toString());
    };
    IndexMap2.prototype.addIndex = function(indexDefinition, existingChildren) {
      assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
      var childList = [];
      var sawIndexedValue = false;
      var iter = existingChildren.getIterator(NamedNode.Wrap);
      var next = iter.getNext();
      while (next) {
        sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
        childList.push(next);
        next = iter.getNext();
      }
      var newIndex;
      if (sawIndexedValue) {
        newIndex = buildChildSet(childList, indexDefinition.getCompare());
      } else {
        newIndex = fallbackObject;
      }
      var indexName = indexDefinition.toString();
      var newIndexSet = __assign({}, this.indexSet_);
      newIndexSet[indexName] = indexDefinition;
      var newIndexes = __assign({}, this.indexes_);
      newIndexes[indexName] = newIndex;
      return new IndexMap2(newIndexes, newIndexSet);
    };
    IndexMap2.prototype.addToIndexes = function(namedNode, existingChildren) {
      var _this = this;
      var newIndexes = map(this.indexes_, function(indexedChildren, indexName) {
        var index = safeGet(_this.indexSet_, indexName);
        assert(index, "Missing index implementation for " + indexName);
        if (indexedChildren === fallbackObject) {
          if (index.isDefinedOn(namedNode.node)) {
            var childList = [];
            var iter = existingChildren.getIterator(NamedNode.Wrap);
            var next = iter.getNext();
            while (next) {
              if (next.name !== namedNode.name) {
                childList.push(next);
              }
              next = iter.getNext();
            }
            childList.push(namedNode);
            return buildChildSet(childList, index.getCompare());
          } else {
            return fallbackObject;
          }
        } else {
          var existingSnap = existingChildren.get(namedNode.name);
          var newChildren = indexedChildren;
          if (existingSnap) {
            newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
          }
          return newChildren.insert(namedNode, namedNode.node);
        }
      });
      return new IndexMap2(newIndexes, this.indexSet_);
    };
    IndexMap2.prototype.removeFromIndexes = function(namedNode, existingChildren) {
      var newIndexes = map(this.indexes_, function(indexedChildren) {
        if (indexedChildren === fallbackObject) {
          return indexedChildren;
        } else {
          var existingSnap = existingChildren.get(namedNode.name);
          if (existingSnap) {
            return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
          } else {
            return indexedChildren;
          }
        }
      });
      return new IndexMap2(newIndexes, this.indexSet_);
    };
    return IndexMap2;
  }()
);
function NAME_ONLY_COMPARATOR(left, right) {
  return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
  return nameCompare(left, right);
}
var EMPTY_NODE;
var ChildrenNode = (
  /** @class */
  function() {
    function ChildrenNode2(children_, priorityNode_, indexMap_) {
      this.children_ = children_;
      this.priorityNode_ = priorityNode_;
      this.indexMap_ = indexMap_;
      this.lazyHash_ = null;
      if (this.priorityNode_) {
        validatePriorityNode(this.priorityNode_);
      }
      if (this.children_.isEmpty()) {
        assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
      }
    }
    Object.defineProperty(ChildrenNode2, "EMPTY_NODE", {
      get: function() {
        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode2(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
      },
      enumerable: false,
      configurable: true
    });
    ChildrenNode2.prototype.isLeafNode = function() {
      return false;
    };
    ChildrenNode2.prototype.getPriority = function() {
      return this.priorityNode_ || EMPTY_NODE;
    };
    ChildrenNode2.prototype.updatePriority = function(newPriorityNode) {
      if (this.children_.isEmpty()) {
        return this;
      } else {
        return new ChildrenNode2(this.children_, newPriorityNode, this.indexMap_);
      }
    };
    ChildrenNode2.prototype.getImmediateChild = function(childName) {
      if (childName === ".priority") {
        return this.getPriority();
      } else {
        var child2 = this.children_.get(childName);
        return child2 === null ? EMPTY_NODE : child2;
      }
    };
    ChildrenNode2.prototype.getChild = function(path) {
      var front = pathGetFront(path);
      if (front === null) {
        return this;
      }
      return this.getImmediateChild(front).getChild(pathPopFront(path));
    };
    ChildrenNode2.prototype.hasChild = function(childName) {
      return this.children_.get(childName) !== null;
    };
    ChildrenNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
      assert(newChildNode, "We should always be passing snapshot nodes");
      if (childName === ".priority") {
        return this.updatePriority(newChildNode);
      } else {
        var namedNode = new NamedNode(childName, newChildNode);
        var newChildren = void 0, newIndexMap = void 0;
        if (newChildNode.isEmpty()) {
          newChildren = this.children_.remove(childName);
          newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
        } else {
          newChildren = this.children_.insert(childName, newChildNode);
          newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
        }
        var newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
        return new ChildrenNode2(newChildren, newPriority, newIndexMap);
      }
    };
    ChildrenNode2.prototype.updateChild = function(path, newChildNode) {
      var front = pathGetFront(path);
      if (front === null) {
        return newChildNode;
      } else {
        assert(pathGetFront(path) !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
        var newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
        return this.updateImmediateChild(front, newImmediateChild);
      }
    };
    ChildrenNode2.prototype.isEmpty = function() {
      return this.children_.isEmpty();
    };
    ChildrenNode2.prototype.numChildren = function() {
      return this.children_.count();
    };
    ChildrenNode2.prototype.val = function(exportFormat) {
      if (this.isEmpty()) {
        return null;
      }
      var obj = {};
      var numKeys = 0, maxKey = 0, allIntegerKeys = true;
      this.forEachChild(PRIORITY_INDEX, function(key2, childNode) {
        obj[key2] = childNode.val(exportFormat);
        numKeys++;
        if (allIntegerKeys && ChildrenNode2.INTEGER_REGEXP_.test(key2)) {
          maxKey = Math.max(maxKey, Number(key2));
        } else {
          allIntegerKeys = false;
        }
      });
      if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
        var array = [];
        for (var key in obj) {
          array[key] = obj[key];
        }
        return array;
      } else {
        if (exportFormat && !this.getPriority().isEmpty()) {
          obj[".priority"] = this.getPriority().val();
        }
        return obj;
      }
    };
    ChildrenNode2.prototype.hash = function() {
      if (this.lazyHash_ === null) {
        var toHash_1 = "";
        if (!this.getPriority().isEmpty()) {
          toHash_1 += "priority:" + priorityHashText(this.getPriority().val()) + ":";
        }
        this.forEachChild(PRIORITY_INDEX, function(key, childNode) {
          var childHash = childNode.hash();
          if (childHash !== "") {
            toHash_1 += ":" + key + ":" + childHash;
          }
        });
        this.lazyHash_ = toHash_1 === "" ? "" : sha1(toHash_1);
      }
      return this.lazyHash_;
    };
    ChildrenNode2.prototype.getPredecessorChildName = function(childName, childNode, index) {
      var idx = this.resolveIndex_(index);
      if (idx) {
        var predecessor2 = idx.getPredecessorKey(new NamedNode(childName, childNode));
        return predecessor2 ? predecessor2.name : null;
      } else {
        return this.children_.getPredecessorKey(childName);
      }
    };
    ChildrenNode2.prototype.getFirstChildName = function(indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        var minKey = idx.minKey();
        return minKey && minKey.name;
      } else {
        return this.children_.minKey();
      }
    };
    ChildrenNode2.prototype.getFirstChild = function(indexDefinition) {
      var minKey = this.getFirstChildName(indexDefinition);
      if (minKey) {
        return new NamedNode(minKey, this.children_.get(minKey));
      } else {
        return null;
      }
    };
    ChildrenNode2.prototype.getLastChildName = function(indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        var maxKey = idx.maxKey();
        return maxKey && maxKey.name;
      } else {
        return this.children_.maxKey();
      }
    };
    ChildrenNode2.prototype.getLastChild = function(indexDefinition) {
      var maxKey = this.getLastChildName(indexDefinition);
      if (maxKey) {
        return new NamedNode(maxKey, this.children_.get(maxKey));
      } else {
        return null;
      }
    };
    ChildrenNode2.prototype.forEachChild = function(index, action) {
      var idx = this.resolveIndex_(index);
      if (idx) {
        return idx.inorderTraversal(function(wrappedNode) {
          return action(wrappedNode.name, wrappedNode.node);
        });
      } else {
        return this.children_.inorderTraversal(action);
      }
    };
    ChildrenNode2.prototype.getIterator = function(indexDefinition) {
      return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    ChildrenNode2.prototype.getIteratorFrom = function(startPost, indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        return idx.getIteratorFrom(startPost, function(key) {
          return key;
        });
      } else {
        var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
        var next = iterator.peek();
        while (next != null && indexDefinition.compare(next, startPost) < 0) {
          iterator.getNext();
          next = iterator.peek();
        }
        return iterator;
      }
    };
    ChildrenNode2.prototype.getReverseIterator = function(indexDefinition) {
      return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    ChildrenNode2.prototype.getReverseIteratorFrom = function(endPost, indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        return idx.getReverseIteratorFrom(endPost, function(key) {
          return key;
        });
      } else {
        var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
        var next = iterator.peek();
        while (next != null && indexDefinition.compare(next, endPost) > 0) {
          iterator.getNext();
          next = iterator.peek();
        }
        return iterator;
      }
    };
    ChildrenNode2.prototype.compareTo = function(other) {
      if (this.isEmpty()) {
        if (other.isEmpty()) {
          return 0;
        } else {
          return -1;
        }
      } else if (other.isLeafNode() || other.isEmpty()) {
        return 1;
      } else if (other === MAX_NODE$2) {
        return -1;
      } else {
        return 0;
      }
    };
    ChildrenNode2.prototype.withIndex = function(indexDefinition) {
      if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
        return this;
      } else {
        var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
        return new ChildrenNode2(this.children_, this.priorityNode_, newIndexMap);
      }
    };
    ChildrenNode2.prototype.isIndexed = function(index) {
      return index === KEY_INDEX || this.indexMap_.hasIndex(index);
    };
    ChildrenNode2.prototype.equals = function(other) {
      if (other === this) {
        return true;
      } else if (other.isLeafNode()) {
        return false;
      } else {
        var otherChildrenNode = other;
        if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
          return false;
        } else if (this.children_.count() === otherChildrenNode.children_.count()) {
          var thisIter = this.getIterator(PRIORITY_INDEX);
          var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
          var thisCurrent = thisIter.getNext();
          var otherCurrent = otherIter.getNext();
          while (thisCurrent && otherCurrent) {
            if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
              return false;
            }
            thisCurrent = thisIter.getNext();
            otherCurrent = otherIter.getNext();
          }
          return thisCurrent === null && otherCurrent === null;
        } else {
          return false;
        }
      }
    };
    ChildrenNode2.prototype.resolveIndex_ = function(indexDefinition) {
      if (indexDefinition === KEY_INDEX) {
        return null;
      } else {
        return this.indexMap_.get(indexDefinition.toString());
      }
    };
    ChildrenNode2.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode2;
  }()
);
var MaxNode = (
  /** @class */
  function(_super) {
    __extends(MaxNode2, _super);
    function MaxNode2() {
      return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;
    }
    MaxNode2.prototype.compareTo = function(other) {
      if (other === this) {
        return 0;
      } else {
        return 1;
      }
    };
    MaxNode2.prototype.equals = function(other) {
      return other === this;
    };
    MaxNode2.prototype.getPriority = function() {
      return this;
    };
    MaxNode2.prototype.getImmediateChild = function(childName) {
      return ChildrenNode.EMPTY_NODE;
    };
    MaxNode2.prototype.isEmpty = function() {
      return false;
    };
    return MaxNode2;
  }(ChildrenNode)
);
var MAX_NODE$2 = new MaxNode();
Object.defineProperties(NamedNode, {
  MIN: {
    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
  },
  MAX: {
    value: new NamedNode(MAX_NAME, MAX_NODE$2)
  }
});
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode(MAX_NODE$2);
setMaxNode$1(MAX_NODE$2);
var USE_HINZE = true;
function nodeFromJSON$1(json, priority) {
  if (priority === void 0) {
    priority = null;
  }
  if (json === null) {
    return ChildrenNode.EMPTY_NODE;
  }
  if (typeof json === "object" && ".priority" in json) {
    priority = json[".priority"];
  }
  assert(priority === null || typeof priority === "string" || typeof priority === "number" || typeof priority === "object" && ".sv" in priority, "Invalid priority type found: " + typeof priority);
  if (typeof json === "object" && ".value" in json && json[".value"] !== null) {
    json = json[".value"];
  }
  if (typeof json !== "object" || ".sv" in json) {
    var jsonLeaf = json;
    return new LeafNode(jsonLeaf, nodeFromJSON$1(priority));
  }
  if (!(json instanceof Array) && USE_HINZE) {
    var children_1 = [];
    var childrenHavePriority_1 = false;
    var hinzeJsonObj = json;
    each(hinzeJsonObj, function(key, child2) {
      if (key.substring(0, 1) !== ".") {
        var childNode = nodeFromJSON$1(child2);
        if (!childNode.isEmpty()) {
          childrenHavePriority_1 = childrenHavePriority_1 || !childNode.getPriority().isEmpty();
          children_1.push(new NamedNode(key, childNode));
        }
      }
    });
    if (children_1.length === 0) {
      return ChildrenNode.EMPTY_NODE;
    }
    var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function(namedNode) {
      return namedNode.name;
    }, NAME_COMPARATOR);
    if (childrenHavePriority_1) {
      var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());
      return new ChildrenNode(childSet, nodeFromJSON$1(priority), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
    } else {
      return new ChildrenNode(childSet, nodeFromJSON$1(priority), IndexMap.Default);
    }
  } else {
    var node_1 = ChildrenNode.EMPTY_NODE;
    each(json, function(key, childData) {
      if (contains(json, key)) {
        if (key.substring(0, 1) !== ".") {
          var childNode = nodeFromJSON$1(childData);
          if (childNode.isLeafNode() || !childNode.isEmpty()) {
            node_1 = node_1.updateImmediateChild(key, childNode);
          }
        }
      }
    });
    return node_1.updatePriority(nodeFromJSON$1(priority));
  }
}
setNodeFromJSON(nodeFromJSON$1);
var OperationType;
(function(OperationType2) {
  OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
  OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
  OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
  OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));
function newOperationSourceUser() {
  return {
    fromUser: true,
    fromServer: false,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServer() {
  return {
    fromUser: false,
    fromServer: true,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServerTaggedQuery(queryId) {
  return {
    fromUser: false,
    fromServer: true,
    queryId,
    tagged: true
  };
}
var AckUserWrite = (
  /** @class */
  function() {
    function AckUserWrite2(path, affectedTree, revert) {
      this.path = path;
      this.affectedTree = affectedTree;
      this.revert = revert;
      this.type = OperationType.ACK_USER_WRITE;
      this.source = newOperationSourceUser();
    }
    AckUserWrite2.prototype.operationForChild = function(childName) {
      if (!pathIsEmpty(this.path)) {
        assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
        return new AckUserWrite2(pathPopFront(this.path), this.affectedTree, this.revert);
      } else if (this.affectedTree.value != null) {
        assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
        return this;
      } else {
        var childTree = this.affectedTree.subtree(new Path(childName));
        return new AckUserWrite2(newEmptyPath(), childTree, this.revert);
      }
    };
    return AckUserWrite2;
  }()
);
var emptyChildrenSingleton;
var EmptyChildren = function() {
  if (!emptyChildrenSingleton) {
    emptyChildrenSingleton = new SortedMap(stringCompare);
  }
  return emptyChildrenSingleton;
};
var ImmutableTree = (
  /** @class */
  function() {
    function ImmutableTree2(value, children) {
      if (children === void 0) {
        children = EmptyChildren();
      }
      this.value = value;
      this.children = children;
    }
    ImmutableTree2.fromObject = function(obj) {
      var tree = new ImmutableTree2(null);
      each(obj, function(childPath, childSnap) {
        tree = tree.set(new Path(childPath), childSnap);
      });
      return tree;
    };
    ImmutableTree2.prototype.isEmpty = function() {
      return this.value === null && this.children.isEmpty();
    };
    ImmutableTree2.prototype.findRootMostMatchingPathAndValue = function(relativePath, predicate) {
      if (this.value != null && predicate(this.value)) {
        return { path: newEmptyPath(), value: this.value };
      } else {
        if (pathIsEmpty(relativePath)) {
          return null;
        } else {
          var front = pathGetFront(relativePath);
          var child2 = this.children.get(front);
          if (child2 !== null) {
            var childExistingPathAndValue = child2.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
            if (childExistingPathAndValue != null) {
              var fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
              return { path: fullPath, value: childExistingPathAndValue.value };
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
      }
    };
    ImmutableTree2.prototype.findRootMostValueAndPath = function(relativePath) {
      return this.findRootMostMatchingPathAndValue(relativePath, function() {
        return true;
      });
    };
    ImmutableTree2.prototype.subtree = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        return this;
      } else {
        var front = pathGetFront(relativePath);
        var childTree = this.children.get(front);
        if (childTree !== null) {
          return childTree.subtree(pathPopFront(relativePath));
        } else {
          return new ImmutableTree2(null);
        }
      }
    };
    ImmutableTree2.prototype.set = function(relativePath, toSet) {
      if (pathIsEmpty(relativePath)) {
        return new ImmutableTree2(toSet, this.children);
      } else {
        var front = pathGetFront(relativePath);
        var child2 = this.children.get(front) || new ImmutableTree2(null);
        var newChild = child2.set(pathPopFront(relativePath), toSet);
        var newChildren = this.children.insert(front, newChild);
        return new ImmutableTree2(this.value, newChildren);
      }
    };
    ImmutableTree2.prototype.remove = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        if (this.children.isEmpty()) {
          return new ImmutableTree2(null);
        } else {
          return new ImmutableTree2(null, this.children);
        }
      } else {
        var front = pathGetFront(relativePath);
        var child2 = this.children.get(front);
        if (child2) {
          var newChild = child2.remove(pathPopFront(relativePath));
          var newChildren = void 0;
          if (newChild.isEmpty()) {
            newChildren = this.children.remove(front);
          } else {
            newChildren = this.children.insert(front, newChild);
          }
          if (this.value === null && newChildren.isEmpty()) {
            return new ImmutableTree2(null);
          } else {
            return new ImmutableTree2(this.value, newChildren);
          }
        } else {
          return this;
        }
      }
    };
    ImmutableTree2.prototype.get = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        return this.value;
      } else {
        var front = pathGetFront(relativePath);
        var child2 = this.children.get(front);
        if (child2) {
          return child2.get(pathPopFront(relativePath));
        } else {
          return null;
        }
      }
    };
    ImmutableTree2.prototype.setTree = function(relativePath, newTree) {
      if (pathIsEmpty(relativePath)) {
        return newTree;
      } else {
        var front = pathGetFront(relativePath);
        var child2 = this.children.get(front) || new ImmutableTree2(null);
        var newChild = child2.setTree(pathPopFront(relativePath), newTree);
        var newChildren = void 0;
        if (newChild.isEmpty()) {
          newChildren = this.children.remove(front);
        } else {
          newChildren = this.children.insert(front, newChild);
        }
        return new ImmutableTree2(this.value, newChildren);
      }
    };
    ImmutableTree2.prototype.fold = function(fn2) {
      return this.fold_(newEmptyPath(), fn2);
    };
    ImmutableTree2.prototype.fold_ = function(pathSoFar, fn2) {
      var accum = {};
      this.children.inorderTraversal(function(childKey, childTree) {
        accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn2);
      });
      return fn2(pathSoFar, this.value, accum);
    };
    ImmutableTree2.prototype.findOnPath = function(path, f) {
      return this.findOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree2.prototype.findOnPath_ = function(pathToFollow, pathSoFar, f) {
      var result = this.value ? f(pathSoFar, this.value) : false;
      if (result) {
        return result;
      } else {
        if (pathIsEmpty(pathToFollow)) {
          return null;
        } else {
          var front = pathGetFront(pathToFollow);
          var nextChild = this.children.get(front);
          if (nextChild) {
            return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
          } else {
            return null;
          }
        }
      }
    };
    ImmutableTree2.prototype.foreachOnPath = function(path, f) {
      return this.foreachOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree2.prototype.foreachOnPath_ = function(pathToFollow, currentRelativePath, f) {
      if (pathIsEmpty(pathToFollow)) {
        return this;
      } else {
        if (this.value) {
          f(currentRelativePath, this.value);
        }
        var front = pathGetFront(pathToFollow);
        var nextChild = this.children.get(front);
        if (nextChild) {
          return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
        } else {
          return new ImmutableTree2(null);
        }
      }
    };
    ImmutableTree2.prototype.foreach = function(f) {
      this.foreach_(newEmptyPath(), f);
    };
    ImmutableTree2.prototype.foreach_ = function(currentRelativePath, f) {
      this.children.inorderTraversal(function(childName, childTree) {
        childTree.foreach_(pathChild(currentRelativePath, childName), f);
      });
      if (this.value) {
        f(currentRelativePath, this.value);
      }
    };
    ImmutableTree2.prototype.foreachChild = function(f) {
      this.children.inorderTraversal(function(childName, childTree) {
        if (childTree.value) {
          f(childName, childTree.value);
        }
      });
    };
    return ImmutableTree2;
  }()
);
var ListenComplete = (
  /** @class */
  function() {
    function ListenComplete2(source, path) {
      this.source = source;
      this.path = path;
      this.type = OperationType.LISTEN_COMPLETE;
    }
    ListenComplete2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        return new ListenComplete2(this.source, newEmptyPath());
      } else {
        return new ListenComplete2(this.source, pathPopFront(this.path));
      }
    };
    return ListenComplete2;
  }()
);
var Overwrite = (
  /** @class */
  function() {
    function Overwrite2(source, path, snap) {
      this.source = source;
      this.path = path;
      this.snap = snap;
      this.type = OperationType.OVERWRITE;
    }
    Overwrite2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        return new Overwrite2(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
      } else {
        return new Overwrite2(this.source, pathPopFront(this.path), this.snap);
      }
    };
    return Overwrite2;
  }()
);
var Merge = (
  /** @class */
  function() {
    function Merge2(source, path, children) {
      this.source = source;
      this.path = path;
      this.children = children;
      this.type = OperationType.MERGE;
    }
    Merge2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        var childTree = this.children.subtree(new Path(childName));
        if (childTree.isEmpty()) {
          return null;
        } else if (childTree.value) {
          return new Overwrite(this.source, newEmptyPath(), childTree.value);
        } else {
          return new Merge2(this.source, newEmptyPath(), childTree);
        }
      } else {
        assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
        return new Merge2(this.source, pathPopFront(this.path), this.children);
      }
    };
    Merge2.prototype.toString = function() {
      return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
    };
    return Merge2;
  }()
);
var CacheNode = (
  /** @class */
  function() {
    function CacheNode2(node_, fullyInitialized_, filtered_) {
      this.node_ = node_;
      this.fullyInitialized_ = fullyInitialized_;
      this.filtered_ = filtered_;
    }
    CacheNode2.prototype.isFullyInitialized = function() {
      return this.fullyInitialized_;
    };
    CacheNode2.prototype.isFiltered = function() {
      return this.filtered_;
    };
    CacheNode2.prototype.isCompleteForPath = function(path) {
      if (pathIsEmpty(path)) {
        return this.isFullyInitialized() && !this.filtered_;
      }
      var childKey = pathGetFront(path);
      return this.isCompleteForChild(childKey);
    };
    CacheNode2.prototype.isCompleteForChild = function(key) {
      return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
    };
    CacheNode2.prototype.getNode = function() {
      return this.node_;
    };
    return CacheNode2;
  }()
);
function newViewCache(eventCache, serverCache) {
  return { eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
  return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
  return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
  return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
  return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
}
function changeValue(snapshotNode) {
  return { type: "value", snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
  return { type: "child_added", snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) {
  return { type: "child_removed", snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
  return {
    type: "child_changed",
    snapshotNode,
    childName,
    oldSnap
  };
}
function changeChildMoved(childName, snapshotNode) {
  return { type: "child_moved", snapshotNode, childName };
}
var IndexedFilter = (
  /** @class */
  function() {
    function IndexedFilter2(index_) {
      this.index_ = index_;
    }
    IndexedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
      var oldChild = snap.getImmediateChild(key);
      if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
        if (oldChild.isEmpty() === newChild.isEmpty()) {
          return snap;
        }
      }
      if (optChangeAccumulator != null) {
        if (newChild.isEmpty()) {
          if (snap.hasChild(key)) {
            optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
          } else {
            assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node");
          }
        } else if (oldChild.isEmpty()) {
          optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
        } else {
          optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
        }
      }
      if (snap.isLeafNode() && newChild.isEmpty()) {
        return snap;
      } else {
        return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
      }
    };
    IndexedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      if (optChangeAccumulator != null) {
        if (!oldSnap.isLeafNode()) {
          oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            if (!newSnap.hasChild(key)) {
              optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
            }
          });
        }
        if (!newSnap.isLeafNode()) {
          newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            if (oldSnap.hasChild(key)) {
              var oldChild = oldSnap.getImmediateChild(key);
              if (!oldChild.equals(childNode)) {
                optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
              }
            } else {
              optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
            }
          });
        }
      }
      return newSnap.withIndex(this.index_);
    };
    IndexedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      if (oldSnap.isEmpty()) {
        return ChildrenNode.EMPTY_NODE;
      } else {
        return oldSnap.updatePriority(newPriority);
      }
    };
    IndexedFilter2.prototype.filtersNodes = function() {
      return false;
    };
    IndexedFilter2.prototype.getIndexedFilter = function() {
      return this;
    };
    IndexedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    return IndexedFilter2;
  }()
);
var ChildChangeAccumulator = (
  /** @class */
  function() {
    function ChildChangeAccumulator2() {
      this.changeMap = /* @__PURE__ */ new Map();
    }
    ChildChangeAccumulator2.prototype.trackChildChange = function(change) {
      var type = change.type;
      var childKey = change.childName;
      assert(type === "child_added" || type === "child_changed" || type === "child_removed", "Only child changes supported for tracking");
      assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
      var oldChange = this.changeMap.get(childKey);
      if (oldChange) {
        var oldType = oldChange.type;
        if (type === "child_added" && oldType === "child_removed") {
          this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
        } else if (type === "child_removed" && oldType === "child_added") {
          this.changeMap.delete(childKey);
        } else if (type === "child_removed" && oldType === "child_changed") {
          this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
        } else if (type === "child_changed" && oldType === "child_added") {
          this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
        } else if (type === "child_changed" && oldType === "child_changed") {
          this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
        } else {
          throw assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
        }
      } else {
        this.changeMap.set(childKey, change);
      }
    };
    ChildChangeAccumulator2.prototype.getChanges = function() {
      return Array.from(this.changeMap.values());
    };
    return ChildChangeAccumulator2;
  }()
);
var CompoundWrite = (
  /** @class */
  function() {
    function CompoundWrite2(writeTree_) {
      this.writeTree_ = writeTree_;
    }
    CompoundWrite2.empty = function() {
      return new CompoundWrite2(new ImmutableTree(null));
    };
    return CompoundWrite2;
  }()
);
function compoundWriteAddWrite(compoundWrite, path, node) {
  if (pathIsEmpty(path)) {
    return new CompoundWrite(new ImmutableTree(node));
  } else {
    var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
      var rootMostPath = rootmost.path;
      var value = rootmost.value;
      var relativePath = newRelativePath(rootMostPath, path);
      value = value.updateChild(relativePath, node);
      return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
    } else {
      var subtree = new ImmutableTree(node);
      var newWriteTree2 = compoundWrite.writeTree_.setTree(path, subtree);
      return new CompoundWrite(newWriteTree2);
    }
  }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
  var newWrite = compoundWrite;
  each(updates, function(childKey, node) {
    newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
  });
  return newWrite;
}
function compoundWriteRemoveWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return CompoundWrite.empty();
  } else {
    var newWriteTree2 = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
    return new CompoundWrite(newWriteTree2);
  }
}
function compoundWriteHasCompleteWrite(compoundWrite, path) {
  return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
function compoundWriteGetCompleteNode(compoundWrite, path) {
  var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
  if (rootmost != null) {
    return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));
  } else {
    return null;
  }
}
function compoundWriteGetCompleteChildren(compoundWrite) {
  var children = [];
  var node = compoundWrite.writeTree_.value;
  if (node != null) {
    if (!node.isLeafNode()) {
      node.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
        children.push(new NamedNode(childName, childNode));
      });
    }
  } else {
    compoundWrite.writeTree_.children.inorderTraversal(function(childName, childTree) {
      if (childTree.value != null) {
        children.push(new NamedNode(childName, childTree.value));
      }
    });
  }
  return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return compoundWrite;
  } else {
    var shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
    if (shadowingNode != null) {
      return new CompoundWrite(new ImmutableTree(shadowingNode));
    } else {
      return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
    }
  }
}
function compoundWriteIsEmpty(compoundWrite) {
  return compoundWrite.writeTree_.isEmpty();
}
function compoundWriteApply(compoundWrite, node) {
  return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
  if (writeTree.value != null) {
    return node.updateChild(relativePath, writeTree.value);
  } else {
    var priorityWrite_1 = null;
    writeTree.children.inorderTraversal(function(childKey, childTree) {
      if (childKey === ".priority") {
        assert(childTree.value !== null, "Priority writes must always be leaf nodes");
        priorityWrite_1 = childTree.value;
      } else {
        node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
      }
    });
    if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
      node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite_1);
    }
    return node;
  }
}
function writeTreeChildWrites(writeTree, path) {
  return newWriteTreeRef(path, writeTree);
}
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
  if (visible === void 0) {
    visible = true;
  }
  writeTree.allWrites.push({
    path,
    snap,
    writeId,
    visible
  });
  if (visible) {
    writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
  }
  writeTree.lastWriteId = writeId;
}
function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older merge on top of newer ones");
  writeTree.allWrites.push({
    path,
    children: changedChildren,
    writeId,
    visible: true
  });
  writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
  writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
  for (var i = 0; i < writeTree.allWrites.length; i++) {
    var record = writeTree.allWrites[i];
    if (record.writeId === writeId) {
      return record;
    }
  }
  return null;
}
function writeTreeRemoveWrite(writeTree, writeId) {
  var idx = writeTree.allWrites.findIndex(function(s) {
    return s.writeId === writeId;
  });
  assert(idx >= 0, "removeWrite called with nonexistent writeId.");
  var writeToRemove = writeTree.allWrites[idx];
  writeTree.allWrites.splice(idx, 1);
  var removedWriteWasVisible = writeToRemove.visible;
  var removedWriteOverlapsWithOtherWrites = false;
  var i = writeTree.allWrites.length - 1;
  while (removedWriteWasVisible && i >= 0) {
    var currentWrite = writeTree.allWrites[i];
    if (currentWrite.visible) {
      if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
        removedWriteWasVisible = false;
      } else if (pathContains(writeToRemove.path, currentWrite.path)) {
        removedWriteOverlapsWithOtherWrites = true;
      }
    }
    i--;
  }
  if (!removedWriteWasVisible) {
    return false;
  } else if (removedWriteOverlapsWithOtherWrites) {
    writeTreeResetTree_(writeTree);
    return true;
  } else {
    if (writeToRemove.snap) {
      writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
    } else {
      var children = writeToRemove.children;
      each(children, function(childName) {
        writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
      });
    }
    return true;
  }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
  if (writeRecord.snap) {
    return pathContains(writeRecord.path, path);
  } else {
    for (var childName in writeRecord.children) {
      if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {
        return true;
      }
    }
    return false;
  }
}
function writeTreeResetTree_(writeTree) {
  writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
  if (writeTree.allWrites.length > 0) {
    writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
  } else {
    writeTree.lastWriteId = -1;
  }
}
function writeTreeDefaultFilter_(write) {
  return write.visible;
}
function writeTreeLayerTree_(writes, filter, treeRoot) {
  var compoundWrite = CompoundWrite.empty();
  for (var i = 0; i < writes.length; ++i) {
    var write = writes[i];
    if (filter(write)) {
      var writePath = write.path;
      var relativePath = void 0;
      if (write.snap) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
        } else
          ;
      } else if (write.children) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          if (pathIsEmpty(relativePath)) {
            compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
          } else {
            var child2 = safeGet(write.children, pathGetFront(relativePath));
            if (child2) {
              var deepNode = child2.getChild(pathPopFront(relativePath));
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
            }
          }
        } else
          ;
      } else {
        throw assertionError("WriteRecord should have .snap or .children");
      }
    }
  }
  return compoundWrite;
}
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  if (!writeIdsToExclude && !includeHiddenWrites) {
    var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (shadowingNode != null) {
      return shadowingNode;
    } else {
      var subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      if (compoundWriteIsEmpty(subMerge)) {
        return completeServerCache;
      } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
        return null;
      } else {
        var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(subMerge, layeredCache);
      }
    }
  } else {
    var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
      return completeServerCache;
    } else {
      if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
        return null;
      } else {
        var filter = function(write) {
          return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));
        };
        var mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
        var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(mergeAtPath, layeredCache);
      }
    }
  }
}
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
  var completeChildren = ChildrenNode.EMPTY_NODE;
  var topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
  if (topLevelSet) {
    if (!topLevelSet.isLeafNode()) {
      topLevelSet.forEachChild(PRIORITY_INDEX, function(childName, childSnap) {
        completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
      });
    }
    return completeChildren;
  } else if (completeServerChildren) {
    var merge_1 = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    completeServerChildren.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
      var node = compoundWriteApply(compoundWriteChildCompoundWrite(merge_1, new Path(childName)), childNode);
      completeChildren = completeChildren.updateImmediateChild(childName, node);
    });
    compoundWriteGetCompleteChildren(merge_1).forEach(function(namedNode) {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  } else {
    var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    compoundWriteGetCompleteChildren(merge).forEach(function(namedNode) {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  }
}
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
  assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
  var path = pathChild(treePath, childPath);
  if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
    return null;
  } else {
    var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
    if (compoundWriteIsEmpty(childMerge)) {
      return existingServerSnap.getChild(childPath);
    } else {
      return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
    }
  }
}
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
  var path = pathChild(treePath, childKey);
  var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
  if (shadowingNode != null) {
    return shadowingNode;
  } else {
    if (existingServerSnap.isCompleteForChild(childKey)) {
      var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
      return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
    } else {
      return null;
    }
  }
}
function writeTreeShadowingWrite(writeTree, path) {
  return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
  var toIterate;
  var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
  var shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
  if (shadowingNode != null) {
    toIterate = shadowingNode;
  } else if (completeServerData != null) {
    toIterate = compoundWriteApply(merge, completeServerData);
  } else {
    return [];
  }
  toIterate = toIterate.withIndex(index);
  if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
    var nodes = [];
    var cmp = index.getCompare();
    var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
    var next = iter.getNext();
    while (next && nodes.length < count) {
      if (cmp(next, startPost) !== 0) {
        nodes.push(next);
      }
      next = iter.getNext();
    }
    return nodes;
  } else {
    return [];
  }
}
function newWriteTree() {
  return {
    visibleWrites: CompoundWrite.empty(),
    allWrites: [],
    lastWriteId: -1
  };
}
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
  return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
  return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
function writeTreeRefShadowingWrite(writeTreeRef, path) {
  return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
  return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
  return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
function writeTreeRefChild(writeTreeRef, childName) {
  return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
  return {
    treePath: path,
    writeTree
  };
}
var NoCompleteChildSource_ = (
  /** @class */
  function() {
    function NoCompleteChildSource_2() {
    }
    NoCompleteChildSource_2.prototype.getCompleteChild = function(childKey) {
      return null;
    };
    NoCompleteChildSource_2.prototype.getChildAfterChild = function(index, child2, reverse) {
      return null;
    };
    return NoCompleteChildSource_2;
  }()
);
var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
var WriteTreeCompleteChildSource = (
  /** @class */
  function() {
    function WriteTreeCompleteChildSource2(writes_, viewCache_, optCompleteServerCache_) {
      if (optCompleteServerCache_ === void 0) {
        optCompleteServerCache_ = null;
      }
      this.writes_ = writes_;
      this.viewCache_ = viewCache_;
      this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    WriteTreeCompleteChildSource2.prototype.getCompleteChild = function(childKey) {
      var node = this.viewCache_.eventCache;
      if (node.isCompleteForChild(childKey)) {
        return node.getNode().getImmediateChild(childKey);
      } else {
        var serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
        return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
      }
    };
    WriteTreeCompleteChildSource2.prototype.getChildAfterChild = function(index, child2, reverse) {
      var completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
      var nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child2, 1, reverse, index);
      if (nodes.length === 0) {
        return null;
      } else {
        return nodes[0];
      }
    };
    return WriteTreeCompleteChildSource2;
  }()
);
function newViewProcessor(filter) {
  return { filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
  assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
  assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
  var accumulator = new ChildChangeAccumulator();
  var newViewCache2, filterServerNode;
  if (operation.type === OperationType.OVERWRITE) {
    var overwrite = operation;
    if (overwrite.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
    } else {
      assert(overwrite.source.fromServer, "Unknown source.");
      filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
      newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.MERGE) {
    var merge = operation;
    if (merge.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
    } else {
      assert(merge.source.fromServer, "Unknown source.");
      filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
      newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.ACK_USER_WRITE) {
    var ackUserWrite = operation;
    if (!ackUserWrite.revert) {
      newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
    } else {
      newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
    }
  } else if (operation.type === OperationType.LISTEN_COMPLETE) {
    newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
  } else {
    throw assertionError("Unknown operation type: " + operation.type);
  }
  var changes = accumulator.getChanges();
  viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
  return { viewCache: newViewCache2, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, accumulator) {
  var eventSnap = newViewCache2.eventCache;
  if (eventSnap.isFullyInitialized()) {
    var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
    var oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
    if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
      accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
    }
  }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
  var oldEventSnap = viewCache.eventCache;
  if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
    return viewCache;
  } else {
    var newEventCache = void 0, serverNode = void 0;
    if (pathIsEmpty(changePath)) {
      assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
      if (viewCache.serverCache.isFiltered()) {
        var serverCache = viewCacheGetCompleteServerSnap(viewCache);
        var completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
        var completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
      } else {
        var completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
      }
    } else {
      var childKey = pathGetFront(changePath);
      if (childKey === ".priority") {
        assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
        var oldEventNode = oldEventSnap.getNode();
        serverNode = viewCache.serverCache.getNode();
        var updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
        if (updatedPriority != null) {
          newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      } else {
        var childChangePath = pathPopFront(changePath);
        var newEventChild = void 0;
        if (oldEventSnap.isCompleteForChild(childKey)) {
          serverNode = viewCache.serverCache.getNode();
          var eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
          if (eventChildUpdate != null) {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
          } else {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
          }
        } else {
          newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
        }
        if (newEventChild != null) {
          newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      }
    }
    return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
  }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
  var oldServerSnap = oldViewCache.serverCache;
  var newServerCache;
  var serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
  if (pathIsEmpty(changePath)) {
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
  } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
    var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
  } else {
    var childKey = pathGetFront(changePath);
    if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
      return oldViewCache;
    }
    var childChangePath = pathPopFront(changePath);
    var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
    var newChildNode = childNode.updateChild(childChangePath, changedSnap);
    if (childKey === ".priority") {
      newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
    } else {
      newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
    }
  }
  var newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
  var source = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
  var oldEventSnap = oldViewCache.eventCache;
  var newViewCache2, newEventCache;
  var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
  if (pathIsEmpty(changePath)) {
    newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
    newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
  } else {
    var childKey = pathGetFront(changePath);
    if (childKey === ".priority") {
      newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
      newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
    } else {
      var childChangePath = pathPopFront(changePath);
      var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
      var newChild = void 0;
      if (pathIsEmpty(childChangePath)) {
        newChild = changedSnap;
      } else {
        var childNode = source.getCompleteChild(childKey);
        if (childNode != null) {
          if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
            newChild = childNode;
          } else {
            newChild = childNode.updateChild(childChangePath, changedSnap);
          }
        } else {
          newChild = ChildrenNode.EMPTY_NODE;
        }
      }
      if (!oldChild.equals(newChild)) {
        var newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
      } else {
        newViewCache2 = oldViewCache;
      }
    }
  }
  return newViewCache2;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
  return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
  var curViewCache = viewCache;
  changedChildren.foreach(function(relativePath, childNode) {
    var writePath = pathChild(path, relativePath);
    if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  changedChildren.foreach(function(relativePath, childNode) {
    var writePath = pathChild(path, relativePath);
    if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
  merge.foreach(function(relativePath, childNode) {
    node = node.updateChild(relativePath, childNode);
  });
  return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
  if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
    return viewCache;
  }
  var curViewCache = viewCache;
  var viewMergeTree;
  if (pathIsEmpty(path)) {
    viewMergeTree = changedChildren;
  } else {
    viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
  }
  var serverNode = viewCache.serverCache.getNode();
  viewMergeTree.children.inorderTraversal(function(childKey, childTree) {
    if (serverNode.hasChild(childKey)) {
      var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  viewMergeTree.children.inorderTraversal(function(childKey, childMergeTree) {
    var isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === void 0;
    if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
      var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
  if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
    return viewCache;
  }
  var filterServerNode = viewCache.serverCache.isFiltered();
  var serverCache = viewCache.serverCache;
  if (affectedTree.value != null) {
    if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
      return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
    } else if (pathIsEmpty(ackPath)) {
      var changedChildren_1 = new ImmutableTree(null);
      serverCache.getNode().forEachChild(KEY_INDEX, function(name10, node) {
        changedChildren_1 = changedChildren_1.set(new Path(name10), node);
      });
      return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
    } else {
      return viewCache;
    }
  } else {
    var changedChildren_2 = new ImmutableTree(null);
    affectedTree.foreach(function(mergePath, value) {
      var serverCachePath = pathChild(ackPath, mergePath);
      if (serverCache.isCompleteForPath(serverCachePath)) {
        changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
      }
    });
    return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
  }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
  var oldServerNode = viewCache.serverCache;
  var newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
  var complete;
  if (writeTreeRefShadowingWrite(writesCache, path) != null) {
    return viewCache;
  } else {
    var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
    var oldEventCache = viewCache.eventCache.getNode();
    var newEventCache = void 0;
    if (pathIsEmpty(path) || pathGetFront(path) === ".priority") {
      var newNode = void 0;
      if (viewCache.serverCache.isFullyInitialized()) {
        newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
      } else {
        var serverChildren = viewCache.serverCache.getNode();
        assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
        newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
      }
      newNode = newNode;
      newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
    } else {
      var childKey = pathGetFront(path);
      var newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
      if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
        newChild = oldEventCache.getImmediateChild(childKey);
      }
      if (newChild != null) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
      } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
      } else {
        newEventCache = oldEventCache;
      }
      if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
        complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        if (complete.isLeafNode()) {
          newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
        }
      }
    }
    complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
    return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
  }
}
var EventGenerator = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventGenerator2(query_) {
      this.query_ = query_;
      this.index_ = this.query_.getQueryParams().getIndex();
    }
    return EventGenerator2;
  }()
);
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
  var events = [];
  var moves = [];
  changes.forEach(function(change) {
    if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
      moves.push(changeChildMoved(change.childName, change.snapshotNode));
    }
  });
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved", moves, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "value", changes, eventRegistrations, eventCache);
  return events;
}
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
  var filteredChanges = changes.filter(function(change) {
    return change.type === eventType;
  });
  filteredChanges.sort(function(a, b) {
    return eventGeneratorCompareChanges(eventGenerator, a, b);
  });
  filteredChanges.forEach(function(change) {
    var materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
    registrations.forEach(function(registration) {
      if (registration.respondsTo(change.type)) {
        events.push(registration.createEvent(materializedChange, eventGenerator.query_));
      }
    });
  });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
  if (change.type === "value" || change.type === "child_removed") {
    return change;
  } else {
    change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
    return change;
  }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
  if (a.childName == null || b.childName == null) {
    throw assertionError("Should only compare child_ events.");
  }
  var aWrapped = new NamedNode(a.childName, a.snapshotNode);
  var bWrapped = new NamedNode(b.childName, b.snapshotNode);
  return eventGenerator.index_.compare(aWrapped, bWrapped);
}
var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
var MIN_PUSH_CHAR = "-";
var MAX_PUSH_CHAR = "z";
var MAX_KEY_LEN = 786;
var nextPushId = /* @__PURE__ */ function() {
  var lastPushTime = 0;
  var lastRandChars = [];
  return function(now) {
    var duplicateTime = now === lastPushTime;
    lastPushTime = now;
    var i;
    var timeStampChars = new Array(8);
    for (i = 7; i >= 0; i--) {
      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
      now = Math.floor(now / 64);
    }
    assert(now === 0, "Cannot push at time == 0");
    var id2 = timeStampChars.join("");
    if (!duplicateTime) {
      for (i = 0; i < 12; i++) {
        lastRandChars[i] = Math.floor(Math.random() * 64);
      }
    } else {
      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
        lastRandChars[i] = 0;
      }
      lastRandChars[i]++;
    }
    for (i = 0; i < 12; i++) {
      id2 += PUSH_CHARS.charAt(lastRandChars[i]);
    }
    assert(id2.length === 20, "nextPushId: Length should be 20.");
    return id2;
  };
}();
var successor = function(key) {
  if (key === "" + INTEGER_32_MAX) {
    return MIN_PUSH_CHAR;
  }
  var keyAsInt = tryParseInt(key);
  if (keyAsInt != null) {
    return "" + (keyAsInt + 1);
  }
  var next = new Array(key.length);
  for (var i_1 = 0; i_1 < next.length; i_1++) {
    next[i_1] = key.charAt(i_1);
  }
  if (next.length < MAX_KEY_LEN) {
    next.push(MIN_PUSH_CHAR);
    return next.join("");
  }
  var i = next.length - 1;
  while (i >= 0 && next[i] === MAX_PUSH_CHAR) {
    i--;
  }
  if (i === -1) {
    return MAX_NAME;
  }
  var source = next[i];
  var sourcePlusOne = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source) + 1);
  next[i] = sourcePlusOne;
  return next.slice(0, i + 1).join("");
};
var predecessor = function(key) {
  if (key === "" + INTEGER_32_MIN) {
    return MIN_NAME;
  }
  var keyAsInt = tryParseInt(key);
  if (keyAsInt != null) {
    return "" + (keyAsInt - 1);
  }
  var next = new Array(key.length);
  for (var i = 0; i < next.length; i++) {
    next[i] = key.charAt(i);
  }
  if (next[next.length - 1] === MIN_PUSH_CHAR) {
    if (next.length === 1) {
      return "" + INTEGER_32_MAX;
    }
    delete next[next.length - 1];
    return next.join("");
  }
  next[next.length - 1] = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length - 1]) - 1);
  return next.join("") + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - next.length);
};
var ValueIndex = (
  /** @class */
  function(_super) {
    __extends(ValueIndex2, _super);
    function ValueIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ValueIndex2.prototype.compare = function(a, b) {
      var indexCmp = a.node.compareTo(b.node);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    ValueIndex2.prototype.isDefinedOn = function(node) {
      return true;
    };
    ValueIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return !oldNode.equals(newNode);
    };
    ValueIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    ValueIndex2.prototype.maxPost = function() {
      return NamedNode.MAX;
    };
    ValueIndex2.prototype.makePost = function(indexValue, name10) {
      var valueNode = nodeFromJSON$1(indexValue);
      return new NamedNode(name10, valueNode);
    };
    ValueIndex2.prototype.toString = function() {
      return ".value";
    };
    return ValueIndex2;
  }(Index)
);
var VALUE_INDEX = new ValueIndex();
var PathIndex = (
  /** @class */
  function(_super) {
    __extends(PathIndex2, _super);
    function PathIndex2(indexPath_) {
      var _this = _super.call(this) || this;
      _this.indexPath_ = indexPath_;
      assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
      return _this;
    }
    PathIndex2.prototype.extractChild = function(snap) {
      return snap.getChild(this.indexPath_);
    };
    PathIndex2.prototype.isDefinedOn = function(node) {
      return !node.getChild(this.indexPath_).isEmpty();
    };
    PathIndex2.prototype.compare = function(a, b) {
      var aChild = this.extractChild(a.node);
      var bChild = this.extractChild(b.node);
      var indexCmp = aChild.compareTo(bChild);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    PathIndex2.prototype.makePost = function(indexValue, name10) {
      var valueNode = nodeFromJSON$1(indexValue);
      var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
      return new NamedNode(name10, node);
    };
    PathIndex2.prototype.maxPost = function() {
      var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE$2);
      return new NamedNode(MAX_NAME, node);
    };
    PathIndex2.prototype.toString = function() {
      return pathSlice(this.indexPath_, 0).join("/");
    };
    return PathIndex2;
  }(Index)
);
var RangedFilter = (
  /** @class */
  function() {
    function RangedFilter2(params) {
      this.indexedFilter_ = new IndexedFilter(params.getIndex());
      this.index_ = params.getIndex();
      this.startPost_ = RangedFilter2.getStartPost_(params);
      this.endPost_ = RangedFilter2.getEndPost_(params);
    }
    RangedFilter2.prototype.getStartPost = function() {
      return this.startPost_;
    };
    RangedFilter2.prototype.getEndPost = function() {
      return this.endPost_;
    };
    RangedFilter2.prototype.matches = function(node) {
      return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;
    };
    RangedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      if (!this.matches(new NamedNode(key, newChild))) {
        newChild = ChildrenNode.EMPTY_NODE;
      }
      return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    RangedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      if (newSnap.isLeafNode()) {
        newSnap = ChildrenNode.EMPTY_NODE;
      }
      var filtered = newSnap.withIndex(this.index_);
      filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
      var self2 = this;
      newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
        if (!self2.matches(new NamedNode(key, childNode))) {
          filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
        }
      });
      return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    RangedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      return oldSnap;
    };
    RangedFilter2.prototype.filtersNodes = function() {
      return true;
    };
    RangedFilter2.prototype.getIndexedFilter = function() {
      return this.indexedFilter_;
    };
    RangedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    RangedFilter2.getStartPost_ = function(params) {
      if (params.hasStart()) {
        var startName = params.getIndexStartName();
        return params.getIndex().makePost(params.getIndexStartValue(), startName);
      } else {
        return params.getIndex().minPost();
      }
    };
    RangedFilter2.getEndPost_ = function(params) {
      if (params.hasEnd()) {
        var endName = params.getIndexEndName();
        return params.getIndex().makePost(params.getIndexEndValue(), endName);
      } else {
        return params.getIndex().maxPost();
      }
    };
    return RangedFilter2;
  }()
);
var LimitedFilter = (
  /** @class */
  function() {
    function LimitedFilter2(params) {
      this.rangedFilter_ = new RangedFilter(params);
      this.index_ = params.getIndex();
      this.limit_ = params.getLimit();
      this.reverse_ = !params.isViewFromLeft();
    }
    LimitedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
        newChild = ChildrenNode.EMPTY_NODE;
      }
      if (snap.getImmediateChild(key).equals(newChild)) {
        return snap;
      } else if (snap.numChildren() < this.limit_) {
        return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
      } else {
        return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
      }
    };
    LimitedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      var filtered;
      if (newSnap.isLeafNode() || newSnap.isEmpty()) {
        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
      } else {
        if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
          filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
          var iterator = void 0;
          if (this.reverse_) {
            iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
          } else {
            iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
          }
          var count = 0;
          while (iterator.hasNext() && count < this.limit_) {
            var next = iterator.getNext();
            var inRange = void 0;
            if (this.reverse_) {
              inRange = this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
            } else {
              inRange = this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
            }
            if (inRange) {
              filtered = filtered.updateImmediateChild(next.name, next.node);
              count++;
            } else {
              break;
            }
          }
        } else {
          filtered = newSnap.withIndex(this.index_);
          filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
          var startPost = void 0;
          var endPost = void 0;
          var cmp = void 0;
          var iterator = void 0;
          if (this.reverse_) {
            iterator = filtered.getReverseIterator(this.index_);
            startPost = this.rangedFilter_.getEndPost();
            endPost = this.rangedFilter_.getStartPost();
            var indexCompare_1 = this.index_.getCompare();
            cmp = function(a, b) {
              return indexCompare_1(b, a);
            };
          } else {
            iterator = filtered.getIterator(this.index_);
            startPost = this.rangedFilter_.getStartPost();
            endPost = this.rangedFilter_.getEndPost();
            cmp = this.index_.getCompare();
          }
          var count = 0;
          var foundStartPost = false;
          while (iterator.hasNext()) {
            var next = iterator.getNext();
            if (!foundStartPost && cmp(startPost, next) <= 0) {
              foundStartPost = true;
            }
            var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
            if (inRange) {
              count++;
            } else {
              filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
            }
          }
        }
      }
      return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    LimitedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      return oldSnap;
    };
    LimitedFilter2.prototype.filtersNodes = function() {
      return true;
    };
    LimitedFilter2.prototype.getIndexedFilter = function() {
      return this.rangedFilter_.getIndexedFilter();
    };
    LimitedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    LimitedFilter2.prototype.fullLimitUpdateChild_ = function(snap, childKey, childSnap, source, changeAccumulator) {
      var cmp;
      if (this.reverse_) {
        var indexCmp_1 = this.index_.getCompare();
        cmp = function(a, b) {
          return indexCmp_1(b, a);
        };
      } else {
        cmp = this.index_.getCompare();
      }
      var oldEventCache = snap;
      assert(oldEventCache.numChildren() === this.limit_, "");
      var newChildNamedNode = new NamedNode(childKey, childSnap);
      var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
      var inRange = this.rangedFilter_.matches(newChildNamedNode);
      if (oldEventCache.hasChild(childKey)) {
        var oldChildSnap = oldEventCache.getImmediateChild(childKey);
        var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
        while (nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
          nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
        }
        var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
        var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
        if (remainsInWindow) {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
          }
          return oldEventCache.updateImmediateChild(childKey, childSnap);
        } else {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
          }
          var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
          var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
          if (nextChildInRange) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
            }
            return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
          } else {
            return newEventCache;
          }
        }
      } else if (childSnap.isEmpty()) {
        return snap;
      } else if (inRange) {
        if (cmp(windowBoundary, newChildNamedNode) >= 0) {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
            changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
          }
          return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
        } else {
          return snap;
        }
      } else {
        return snap;
      }
    };
    return LimitedFilter2;
  }()
);
var QueryParams = (
  /** @class */
  function() {
    function QueryParams2() {
      this.limitSet_ = false;
      this.startSet_ = false;
      this.startNameSet_ = false;
      this.startAfterSet_ = false;
      this.endSet_ = false;
      this.endNameSet_ = false;
      this.endBeforeSet_ = false;
      this.limit_ = 0;
      this.viewFrom_ = "";
      this.indexStartValue_ = null;
      this.indexStartName_ = "";
      this.indexEndValue_ = null;
      this.indexEndName_ = "";
      this.index_ = PRIORITY_INDEX;
    }
    QueryParams2.prototype.hasStart = function() {
      return this.startSet_;
    };
    QueryParams2.prototype.hasStartAfter = function() {
      return this.startAfterSet_;
    };
    QueryParams2.prototype.hasEndBefore = function() {
      return this.endBeforeSet_;
    };
    QueryParams2.prototype.isViewFromLeft = function() {
      if (this.viewFrom_ === "") {
        return this.startSet_;
      } else {
        return this.viewFrom_ === "l";
      }
    };
    QueryParams2.prototype.getIndexStartValue = function() {
      assert(this.startSet_, "Only valid if start has been set");
      return this.indexStartValue_;
    };
    QueryParams2.prototype.getIndexStartName = function() {
      assert(this.startSet_, "Only valid if start has been set");
      if (this.startNameSet_) {
        return this.indexStartName_;
      } else {
        return MIN_NAME;
      }
    };
    QueryParams2.prototype.hasEnd = function() {
      return this.endSet_;
    };
    QueryParams2.prototype.getIndexEndValue = function() {
      assert(this.endSet_, "Only valid if end has been set");
      return this.indexEndValue_;
    };
    QueryParams2.prototype.getIndexEndName = function() {
      assert(this.endSet_, "Only valid if end has been set");
      if (this.endNameSet_) {
        return this.indexEndName_;
      } else {
        return MAX_NAME;
      }
    };
    QueryParams2.prototype.hasLimit = function() {
      return this.limitSet_;
    };
    QueryParams2.prototype.hasAnchoredLimit = function() {
      return this.limitSet_ && this.viewFrom_ !== "";
    };
    QueryParams2.prototype.getLimit = function() {
      assert(this.limitSet_, "Only valid if limit has been set");
      return this.limit_;
    };
    QueryParams2.prototype.getIndex = function() {
      return this.index_;
    };
    QueryParams2.prototype.loadsAllData = function() {
      return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    QueryParams2.prototype.isDefault = function() {
      return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    };
    QueryParams2.prototype.copy = function() {
      var copy = new QueryParams2();
      copy.limitSet_ = this.limitSet_;
      copy.limit_ = this.limit_;
      copy.startSet_ = this.startSet_;
      copy.indexStartValue_ = this.indexStartValue_;
      copy.startNameSet_ = this.startNameSet_;
      copy.indexStartName_ = this.indexStartName_;
      copy.endSet_ = this.endSet_;
      copy.indexEndValue_ = this.indexEndValue_;
      copy.endNameSet_ = this.endNameSet_;
      copy.indexEndName_ = this.indexEndName_;
      copy.index_ = this.index_;
      copy.viewFrom_ = this.viewFrom_;
      return copy;
    };
    return QueryParams2;
  }()
);
function queryParamsGetNodeFilter(queryParams) {
  if (queryParams.loadsAllData()) {
    return new IndexedFilter(queryParams.getIndex());
  } else if (queryParams.hasLimit()) {
    return new LimitedFilter(queryParams);
  } else {
    return new RangedFilter(queryParams);
  }
}
function queryParamsLimitToFirst(queryParams, newLimit) {
  var newParams = queryParams.copy();
  newParams.limitSet_ = true;
  newParams.limit_ = newLimit;
  newParams.viewFrom_ = "l";
  return newParams;
}
function queryParamsLimitToLast(queryParams, newLimit) {
  var newParams = queryParams.copy();
  newParams.limitSet_ = true;
  newParams.limit_ = newLimit;
  newParams.viewFrom_ = "r";
  return newParams;
}
function queryParamsStartAt(queryParams, indexValue, key) {
  var newParams = queryParams.copy();
  newParams.startSet_ = true;
  if (indexValue === void 0) {
    indexValue = null;
  }
  newParams.indexStartValue_ = indexValue;
  if (key != null) {
    newParams.startNameSet_ = true;
    newParams.indexStartName_ = key;
  } else {
    newParams.startNameSet_ = false;
    newParams.indexStartName_ = "";
  }
  return newParams;
}
function queryParamsStartAfter(queryParams, indexValue, key) {
  var params;
  if (queryParams.index_ === KEY_INDEX) {
    if (typeof indexValue === "string") {
      indexValue = successor(indexValue);
    }
    params = queryParamsStartAt(queryParams, indexValue, key);
  } else {
    var childKey = void 0;
    if (key == null) {
      childKey = MAX_NAME;
    } else {
      childKey = successor(key);
    }
    params = queryParamsStartAt(queryParams, indexValue, childKey);
  }
  params.startAfterSet_ = true;
  return params;
}
function queryParamsEndAt(queryParams, indexValue, key) {
  var newParams = queryParams.copy();
  newParams.endSet_ = true;
  if (indexValue === void 0) {
    indexValue = null;
  }
  newParams.indexEndValue_ = indexValue;
  if (key !== void 0) {
    newParams.endNameSet_ = true;
    newParams.indexEndName_ = key;
  } else {
    newParams.endNameSet_ = false;
    newParams.indexEndName_ = "";
  }
  return newParams;
}
function queryParamsEndBefore(queryParams, indexValue, key) {
  var childKey;
  var params;
  if (queryParams.index_ === KEY_INDEX) {
    if (typeof indexValue === "string") {
      indexValue = predecessor(indexValue);
    }
    params = queryParamsEndAt(queryParams, indexValue, key);
  } else {
    if (key == null) {
      childKey = MIN_NAME;
    } else {
      childKey = predecessor(key);
    }
    params = queryParamsEndAt(queryParams, indexValue, childKey);
  }
  params.endBeforeSet_ = true;
  return params;
}
function queryParamsOrderBy(queryParams, index) {
  var newParams = queryParams.copy();
  newParams.index_ = index;
  return newParams;
}
function queryParamsToRestQueryStringParameters(queryParams) {
  var qs2 = {};
  if (queryParams.isDefault()) {
    return qs2;
  }
  var orderBy;
  if (queryParams.index_ === PRIORITY_INDEX) {
    orderBy = "$priority";
  } else if (queryParams.index_ === VALUE_INDEX) {
    orderBy = "$value";
  } else if (queryParams.index_ === KEY_INDEX) {
    orderBy = "$key";
  } else {
    assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
    orderBy = queryParams.index_.toString();
  }
  qs2[
    "orderBy"
    /* ORDER_BY */
  ] = stringify(orderBy);
  if (queryParams.startSet_) {
    qs2[
      "startAt"
      /* START_AT */
    ] = stringify(queryParams.indexStartValue_);
    if (queryParams.startNameSet_) {
      qs2[
        "startAt"
        /* START_AT */
      ] += "," + stringify(queryParams.indexStartName_);
    }
  }
  if (queryParams.endSet_) {
    qs2[
      "endAt"
      /* END_AT */
    ] = stringify(queryParams.indexEndValue_);
    if (queryParams.endNameSet_) {
      qs2[
        "endAt"
        /* END_AT */
      ] += "," + stringify(queryParams.indexEndName_);
    }
  }
  if (queryParams.limitSet_) {
    if (queryParams.isViewFromLeft()) {
      qs2[
        "limitToFirst"
        /* LIMIT_TO_FIRST */
      ] = queryParams.limit_;
    } else {
      qs2[
        "limitToLast"
        /* LIMIT_TO_LAST */
      ] = queryParams.limit_;
    }
  }
  return qs2;
}
function queryParamsGetQueryObject(queryParams) {
  var obj = {};
  if (queryParams.startSet_) {
    obj[
      "sp"
      /* INDEX_START_VALUE */
    ] = queryParams.indexStartValue_;
    if (queryParams.startNameSet_) {
      obj[
        "sn"
        /* INDEX_START_NAME */
      ] = queryParams.indexStartName_;
    }
  }
  if (queryParams.endSet_) {
    obj[
      "ep"
      /* INDEX_END_VALUE */
    ] = queryParams.indexEndValue_;
    if (queryParams.endNameSet_) {
      obj[
        "en"
        /* INDEX_END_NAME */
      ] = queryParams.indexEndName_;
    }
  }
  if (queryParams.limitSet_) {
    obj[
      "l"
      /* LIMIT */
    ] = queryParams.limit_;
    var viewFrom = queryParams.viewFrom_;
    if (viewFrom === "") {
      if (queryParams.isViewFromLeft()) {
        viewFrom = "l";
      } else {
        viewFrom = "r";
      }
    }
    obj[
      "vf"
      /* VIEW_FROM */
    ] = viewFrom;
  }
  if (queryParams.index_ !== PRIORITY_INDEX) {
    obj[
      "i"
      /* INDEX */
    ] = queryParams.index_.toString();
  }
  return obj;
}
var View = (
  /** @class */
  function() {
    function View2(query_, initialViewCache) {
      this.query_ = query_;
      this.eventRegistrations_ = [];
      var params = this.query_.getQueryParams();
      var indexFilter = new IndexedFilter(params.getIndex());
      var filter = queryParamsGetNodeFilter(params);
      this.processor_ = newViewProcessor(filter);
      var initialServerCache = initialViewCache.serverCache;
      var initialEventCache = initialViewCache.eventCache;
      var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
      var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
      var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
      var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
      this.viewCache_ = newViewCache(newEventCache, newServerCache);
      this.eventGenerator_ = new EventGenerator(this.query_);
    }
    Object.defineProperty(View2.prototype, "query", {
      get: function() {
        return this.query_;
      },
      enumerable: false,
      configurable: true
    });
    return View2;
  }()
);
function viewGetServerCache(view) {
  return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(view) {
  return viewCacheGetCompleteEventSnap(view.viewCache_);
}
function viewGetCompleteServerCache(view, path) {
  var cache = viewCacheGetCompleteServerSnap(view.viewCache_);
  if (cache) {
    if (view.query.getQueryParams().loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {
      return cache.getChild(path);
    }
  }
  return null;
}
function viewIsEmpty(view) {
  return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) {
  view.eventRegistrations_.push(eventRegistration);
}
function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
  var cancelEvents = [];
  if (cancelError) {
    assert(eventRegistration == null, "A cancel should cancel all event registrations.");
    var path_1 = view.query.path;
    view.eventRegistrations_.forEach(function(registration) {
      var maybeEvent = registration.createCancelEvent(cancelError, path_1);
      if (maybeEvent) {
        cancelEvents.push(maybeEvent);
      }
    });
  }
  if (eventRegistration) {
    var remaining = [];
    for (var i = 0; i < view.eventRegistrations_.length; ++i) {
      var existing = view.eventRegistrations_[i];
      if (!existing.matches(eventRegistration)) {
        remaining.push(existing);
      } else if (eventRegistration.hasAnyCallback()) {
        remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
        break;
      }
    }
    view.eventRegistrations_ = remaining;
  } else {
    view.eventRegistrations_ = [];
  }
  return cancelEvents;
}
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
  if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
    assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
    assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
  }
  var oldViewCache = view.viewCache_;
  var result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
  viewProcessorAssertIndexed(view.processor_, result.viewCache);
  assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
  view.viewCache_ = result.viewCache;
  return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) {
  var eventSnap = view.viewCache_.eventCache;
  var initialChanges = [];
  if (!eventSnap.getNode().isLeafNode()) {
    var eventNode = eventSnap.getNode();
    eventNode.forEachChild(PRIORITY_INDEX, function(key, childNode) {
      initialChanges.push(changeChildAdded(key, childNode));
    });
  }
  if (eventSnap.isFullyInitialized()) {
    initialChanges.push(changeValue(eventSnap.getNode()));
  }
  return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
  var registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
  return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}
var referenceConstructor;
var SyncPoint = (
  /** @class */
  /* @__PURE__ */ function() {
    function SyncPoint2() {
      this.views = /* @__PURE__ */ new Map();
    }
    return SyncPoint2;
  }()
);
function syncPointSetReferenceConstructor(val) {
  assert(!referenceConstructor, "__referenceConstructor has already been defined");
  referenceConstructor = val;
}
function syncPointGetReferenceConstructor() {
  assert(referenceConstructor, "Reference.ts has not been loaded");
  return referenceConstructor;
}
function syncPointIsEmpty(syncPoint) {
  return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
  var e_1, _a9;
  var queryId = operation.source.queryId;
  if (queryId !== null) {
    var view = syncPoint.views.get(queryId);
    assert(view != null, "SyncTree gave us an op for an invalid query.");
    return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
  } else {
    var events = [];
    try {
      for (var _b = __values(syncPoint.views.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var view = _c2.value;
        events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a9 = _b.return))
          _a9.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return events;
  }
}
function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {
  var queryId = query.queryIdentifier();
  var view = syncPoint.views.get(queryId);
  if (!view) {
    var eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
    var eventCacheComplete = false;
    if (eventCache) {
      eventCacheComplete = true;
    } else if (serverCache instanceof ChildrenNode) {
      eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
      eventCacheComplete = false;
    } else {
      eventCache = ChildrenNode.EMPTY_NODE;
      eventCacheComplete = false;
    }
    var viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
    return new View(query, viewCache);
  }
  return view;
}
function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
  var view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
  if (!syncPoint.views.has(query.queryIdentifier())) {
    syncPoint.views.set(query.queryIdentifier(), view);
  }
  viewAddEventRegistration(view, eventRegistration);
  return viewGetInitialEvents(view, eventRegistration);
}
function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {
  var e_2, _a9;
  var queryId = query.queryIdentifier();
  var removed = [];
  var cancelEvents = [];
  var hadCompleteView = syncPointHasCompleteView(syncPoint);
  if (queryId === "default") {
    try {
      for (var _b = __values(syncPoint.views.entries()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var _d = __read(_c2.value, 2), viewQueryId = _d[0], view = _d[1];
        cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
        if (viewIsEmpty(view)) {
          syncPoint.views.delete(viewQueryId);
          if (!view.query.getQueryParams().loadsAllData()) {
            removed.push(view.query);
          }
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a9 = _b.return))
          _a9.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  } else {
    var view = syncPoint.views.get(queryId);
    if (view) {
      cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
      if (viewIsEmpty(view)) {
        syncPoint.views.delete(queryId);
        if (!view.query.getQueryParams().loadsAllData()) {
          removed.push(view.query);
        }
      }
    }
  }
  if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
    removed.push(new (syncPointGetReferenceConstructor())(query.repo, query.path));
  }
  return { removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) {
  var e_3, _a9;
  var result = [];
  try {
    for (var _b = __values(syncPoint.views.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
      var view = _c2.value;
      if (!view.query.getQueryParams().loadsAllData()) {
        result.push(view);
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c2 && !_c2.done && (_a9 = _b.return))
        _a9.call(_b);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  return result;
}
function syncPointGetCompleteServerCache(syncPoint, path) {
  var e_4, _a9;
  var serverCache = null;
  try {
    for (var _b = __values(syncPoint.views.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
      var view = _c2.value;
      serverCache = serverCache || viewGetCompleteServerCache(view, path);
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (_c2 && !_c2.done && (_a9 = _b.return))
        _a9.call(_b);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return serverCache;
}
function syncPointViewForQuery(syncPoint, query) {
  var params = query.getQueryParams();
  if (params.loadsAllData()) {
    return syncPointGetCompleteView(syncPoint);
  } else {
    var queryId = query.queryIdentifier();
    return syncPoint.views.get(queryId);
  }
}
function syncPointViewExistsForQuery(syncPoint, query) {
  return syncPointViewForQuery(syncPoint, query) != null;
}
function syncPointHasCompleteView(syncPoint) {
  return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) {
  var e_5, _a9;
  try {
    for (var _b = __values(syncPoint.views.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
      var view = _c2.value;
      if (view.query.getQueryParams().loadsAllData()) {
        return view;
      }
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c2 && !_c2.done && (_a9 = _b.return))
        _a9.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return null;
}
var syncTreeNextQueryTag_ = 1;
var SyncTree = (
  /** @class */
  /* @__PURE__ */ function() {
    function SyncTree2(listenProvider_) {
      this.listenProvider_ = listenProvider_;
      this.syncPointTree_ = new ImmutableTree(null);
      this.pendingWriteTree_ = newWriteTree();
      this.tagToQueryMap = /* @__PURE__ */ new Map();
      this.queryToTagMap = /* @__PURE__ */ new Map();
    }
    return SyncTree2;
  }()
);
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
  writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
  if (!visible) {
    return [];
  } else {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
  }
}
function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
  writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
  var changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
}
function syncTreeAckUserWrite(syncTree, writeId, revert) {
  if (revert === void 0) {
    revert = false;
  }
  var write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
  var needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
  if (!needToReevaluate) {
    return [];
  } else {
    var affectedTree_1 = new ImmutableTree(null);
    if (write.snap != null) {
      affectedTree_1 = affectedTree_1.set(newEmptyPath(), true);
    } else {
      each(write.children, function(pathString) {
        affectedTree_1 = affectedTree_1.set(new Path(pathString), true);
      });
    }
    return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree_1, revert));
  }
}
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
  var changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
function syncTreeApplyListenComplete(syncTree, path) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    var r2 = syncTreeParseQueryKey_(queryKey);
    var queryPath = r2.path, queryId = r2.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError) {
  var path = query.path;
  var maybeSyncPoint = syncTree.syncPointTree_.get(path);
  var cancelEvents = [];
  if (maybeSyncPoint && (query.queryIdentifier() === "default" || syncPointViewExistsForQuery(maybeSyncPoint, query))) {
    var removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
    if (syncPointIsEmpty(maybeSyncPoint)) {
      syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
    }
    var removed = removedAndEvents.removed;
    cancelEvents = removedAndEvents.events;
    var removingDefault = -1 !== removed.findIndex(function(query2) {
      return query2.getQueryParams().loadsAllData();
    });
    var covered = syncTree.syncPointTree_.findOnPath(path, function(relativePath, parentSyncPoint) {
      return syncPointHasCompleteView(parentSyncPoint);
    });
    if (removingDefault && !covered) {
      var subtree = syncTree.syncPointTree_.subtree(path);
      if (!subtree.isEmpty()) {
        var newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
        for (var i = 0; i < newViews.length; ++i) {
          var view = newViews[i], newQuery = view.query;
          var listener = syncTreeCreateListenerForView_(syncTree, view);
          syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery_(syncTree, newQuery), listener.hashFn, listener.onComplete);
        }
      }
    }
    if (!covered && removed.length > 0 && !cancelError) {
      if (removingDefault) {
        var defaultTag = null;
        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
      } else {
        removed.forEach(function(queryToRemove) {
          var tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
          syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
        });
      }
    }
    syncTreeRemoveTags_(syncTree, removed);
  }
  return cancelEvents;
}
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey != null) {
    var r2 = syncTreeParseQueryKey_(queryKey);
    var queryPath = r2.path, queryId = r2.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    var r2 = syncTreeParseQueryKey_(queryKey);
    var queryPath = r2.path, queryId = r2.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var changeTree = ImmutableTree.fromObject(changedChildren);
    var op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeAddEventRegistration(syncTree, query, eventRegistration) {
  var path = query.path;
  var serverCache = null;
  var foundAncestorDefaultView = false;
  syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
    var relativePath = newRelativePath(pathToSyncPoint, path);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);
  });
  var syncPoint = syncTree.syncPointTree_.get(path);
  if (!syncPoint) {
    syncPoint = new SyncPoint();
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  } else {
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var serverCacheComplete;
  if (serverCache != null) {
    serverCacheComplete = true;
  } else {
    serverCacheComplete = false;
    serverCache = ChildrenNode.EMPTY_NODE;
    var subtree = syncTree.syncPointTree_.subtree(path);
    subtree.foreachChild(function(childName, childSyncPoint) {
      var completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
      if (completeCache) {
        serverCache = serverCache.updateImmediateChild(childName, completeCache);
      }
    });
  }
  var viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
  if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {
    var queryKey = syncTreeMakeQueryKey_(query);
    assert(!syncTree.queryToTagMap.has(queryKey), "View does not exist, but we have a tag");
    var tag = syncTreeGetNextQueryTag_();
    syncTree.queryToTagMap.set(queryKey, tag);
    syncTree.tagToQueryMap.set(tag, queryKey);
  }
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
  var events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
  if (!viewAlreadyExists && !foundAncestorDefaultView) {
    var view = syncPointViewForQuery(syncPoint, query);
    events = events.concat(syncTreeSetupListener_(syncTree, query, view));
  }
  return events;
}
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
  var includeHiddenSets = true;
  var writeTree = syncTree.pendingWriteTree_;
  var serverCache = syncTree.syncPointTree_.findOnPath(path, function(pathSoFar, syncPoint) {
    var relativePath = newRelativePath(pathSoFar, path);
    var serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
    if (serverCache2) {
      return serverCache2;
    }
  });
  return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeGetServerValue(syncTree, query) {
  var path = query.path;
  var serverCache = null;
  syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
    var relativePath = newRelativePath(pathToSyncPoint, path);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
  });
  var syncPoint = syncTree.syncPointTree_.get(path);
  if (!syncPoint) {
    syncPoint = new SyncPoint();
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  } else {
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var serverCacheComplete = serverCache != null;
  var serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query.path);
  var view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
  return viewGetCompleteNode(view);
}
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
  return syncTreeApplyOperationHelper_(
    operation,
    syncTree.syncPointTree_,
    /*serverCache=*/
    null,
    writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath())
  );
}
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
  if (pathIsEmpty(operation.path)) {
    return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
  } else {
    var syncPoint = syncPointTree.get(newEmptyPath());
    if (serverCache == null && syncPoint != null) {
      serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    var events = [];
    var childName = pathGetFront(operation.path);
    var childOperation = operation.operationForChild(childName);
    var childTree = syncPointTree.children.get(childName);
    if (childTree && childOperation) {
      var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
      var childWritesCache = writeTreeRefChild(writesCache, childName);
      events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
    if (syncPoint) {
      events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
  }
}
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
  var syncPoint = syncPointTree.get(newEmptyPath());
  if (serverCache == null && syncPoint != null) {
    serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var events = [];
  syncPointTree.children.inorderTraversal(function(childName, childTree) {
    var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
    var childWritesCache = writeTreeRefChild(writesCache, childName);
    var childOperation = operation.operationForChild(childName);
    if (childOperation) {
      events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
  });
  if (syncPoint) {
    events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
  }
  return events;
}
function syncTreeCreateListenerForView_(syncTree, view) {
  var query = view.query;
  var tag = syncTreeTagForQuery_(syncTree, query);
  return {
    hashFn: function() {
      var cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
      return cache.hash();
    },
    onComplete: function(status) {
      if (status === "ok") {
        if (tag) {
          return syncTreeApplyTaggedListenComplete(syncTree, query.path, tag);
        } else {
          return syncTreeApplyListenComplete(syncTree, query.path);
        }
      } else {
        var error2 = errorForServerCode(status, query);
        return syncTreeRemoveEventRegistration(
          syncTree,
          query,
          /*eventRegistration*/
          null,
          error2
        );
      }
    }
  };
}
function syncTreeTagForQuery_(syncTree, query) {
  var queryKey = syncTreeMakeQueryKey_(query);
  return syncTree.queryToTagMap.get(queryKey);
}
function syncTreeMakeQueryKey_(query) {
  return query.path.toString() + "$" + query.queryIdentifier();
}
function syncTreeQueryKeyForTag_(syncTree, tag) {
  return syncTree.tagToQueryMap.get(tag);
}
function syncTreeParseQueryKey_(queryKey) {
  var splitIndex = queryKey.indexOf("$");
  assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
  return {
    queryId: queryKey.substr(splitIndex + 1),
    path: new Path(queryKey.substr(0, splitIndex))
  };
}
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
  var syncPoint = syncTree.syncPointTree_.get(queryPath);
  assert(syncPoint, "Missing sync point for query tag that we're tracking");
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
  return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
function syncTreeCollectDistinctViewsForSubTree_(subtree) {
  return subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
    if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
      var completeView = syncPointGetCompleteView(maybeChildSyncPoint);
      return [completeView];
    } else {
      var views_1 = [];
      if (maybeChildSyncPoint) {
        views_1 = syncPointGetQueryViews(maybeChildSyncPoint);
      }
      each(childMap, function(_key, childViews) {
        views_1 = views_1.concat(childViews);
      });
      return views_1;
    }
  });
}
function syncTreeQueryForListening_(query) {
  if (query.getQueryParams().loadsAllData() && !query.getQueryParams().isDefault()) {
    return query.getRef();
  } else {
    return query;
  }
}
function syncTreeRemoveTags_(syncTree, queries) {
  for (var j2 = 0; j2 < queries.length; ++j2) {
    var removedQuery = queries[j2];
    if (!removedQuery.getQueryParams().loadsAllData()) {
      var removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
      var removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
      syncTree.queryToTagMap.delete(removedQueryKey);
      syncTree.tagToQueryMap.delete(removedQueryTag);
    }
  }
}
function syncTreeGetNextQueryTag_() {
  return syncTreeNextQueryTag_++;
}
function syncTreeSetupListener_(syncTree, query, view) {
  var path = query.path;
  var tag = syncTreeTagForQuery_(syncTree, query);
  var listener = syncTreeCreateListenerForView_(syncTree, view);
  var events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
  var subtree = syncTree.syncPointTree_.subtree(path);
  if (tag) {
    assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
  } else {
    var queriesToStop = subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
      if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
        return [syncPointGetCompleteView(maybeChildSyncPoint).query];
      } else {
        var queries_1 = [];
        if (maybeChildSyncPoint) {
          queries_1 = queries_1.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(function(view2) {
            return view2.query;
          }));
        }
        each(childMap, function(_key, childQueries) {
          queries_1 = queries_1.concat(childQueries);
        });
        return queries_1;
      }
    });
    for (var i = 0; i < queriesToStop.length; ++i) {
      var queryToStop = queriesToStop[i];
      syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery_(syncTree, queryToStop));
    }
  }
  return events;
}
var ExistingValueProvider = (
  /** @class */
  function() {
    function ExistingValueProvider2(node_) {
      this.node_ = node_;
    }
    ExistingValueProvider2.prototype.getImmediateChild = function(childName) {
      var child2 = this.node_.getImmediateChild(childName);
      return new ExistingValueProvider2(child2);
    };
    ExistingValueProvider2.prototype.node = function() {
      return this.node_;
    };
    return ExistingValueProvider2;
  }()
);
var DeferredValueProvider = (
  /** @class */
  function() {
    function DeferredValueProvider2(syncTree, path) {
      this.syncTree_ = syncTree;
      this.path_ = path;
    }
    DeferredValueProvider2.prototype.getImmediateChild = function(childName) {
      var childPath = pathChild(this.path_, childName);
      return new DeferredValueProvider2(this.syncTree_, childPath);
    };
    DeferredValueProvider2.prototype.node = function() {
      return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    };
    return DeferredValueProvider2;
  }()
);
var generateWithValues = function(values) {
  values = values || {};
  values["timestamp"] = values["timestamp"] || (/* @__PURE__ */ new Date()).getTime();
  return values;
};
var resolveDeferredLeafValue = function(value, existingVal, serverValues) {
  if (!value || typeof value !== "object") {
    return value;
  }
  assert(".sv" in value, "Unexpected leaf node or priority contents");
  if (typeof value[".sv"] === "string") {
    return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
  } else if (typeof value[".sv"] === "object") {
    return resolveComplexDeferredValue(value[".sv"], existingVal);
  } else {
    assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
  }
};
var resolveScalarDeferredValue = function(op, existing, serverValues) {
  switch (op) {
    case "timestamp":
      return serverValues["timestamp"];
    default:
      assert(false, "Unexpected server value: " + op);
  }
};
var resolveComplexDeferredValue = function(op, existing, unused) {
  if (!op.hasOwnProperty("increment")) {
    assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
  }
  var delta = op["increment"];
  if (typeof delta !== "number") {
    assert(false, "Unexpected increment value: " + delta);
  }
  var existingNode = existing.node();
  assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
  if (!existingNode.isLeafNode()) {
    return delta;
  }
  var leaf = existingNode;
  var existingVal = leaf.getValue();
  if (typeof existingVal !== "number") {
    return delta;
  }
  return existingVal + delta;
};
var resolveDeferredValueTree = function(path, node, syncTree, serverValues) {
  return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
var resolveDeferredValueSnapshot = function(node, existing, serverValues) {
  return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) {
  var rawPri = node.getPriority().val();
  var priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
  var newNode;
  if (node.isLeafNode()) {
    var leafNode = node;
    var value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {
      return new LeafNode(value, nodeFromJSON$1(priority));
    } else {
      return node;
    }
  } else {
    var childrenNode = node;
    newNode = childrenNode;
    if (priority !== childrenNode.getPriority().val()) {
      newNode = newNode.updatePriority(new LeafNode(priority));
    }
    childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
      var newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
      if (newChildNode !== childNode) {
        newNode = newNode.updateImmediateChild(childName, newChildNode);
      }
    });
    return newNode;
  }
}
function newSparseSnapshotTree() {
  return {
    value: null,
    children: /* @__PURE__ */ new Map()
  };
}
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
  if (pathIsEmpty(path)) {
    sparseSnapshotTree.value = data;
    sparseSnapshotTree.children.clear();
  } else if (sparseSnapshotTree.value !== null) {
    sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
  } else {
    var childKey = pathGetFront(path);
    if (!sparseSnapshotTree.children.has(childKey)) {
      sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
    }
    var child2 = sparseSnapshotTree.children.get(childKey);
    path = pathPopFront(path);
    sparseSnapshotTreeRemember(child2, path, data);
  }
}
function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
  if (pathIsEmpty(path)) {
    sparseSnapshotTree.value = null;
    sparseSnapshotTree.children.clear();
    return true;
  } else {
    if (sparseSnapshotTree.value !== null) {
      if (sparseSnapshotTree.value.isLeafNode()) {
        return false;
      } else {
        var value = sparseSnapshotTree.value;
        sparseSnapshotTree.value = null;
        value.forEachChild(PRIORITY_INDEX, function(key, tree) {
          sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
        });
        return sparseSnapshotTreeForget(sparseSnapshotTree, path);
      }
    } else if (sparseSnapshotTree.children.size > 0) {
      var childKey = pathGetFront(path);
      path = pathPopFront(path);
      if (sparseSnapshotTree.children.has(childKey)) {
        var safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
        if (safeToRemove) {
          sparseSnapshotTree.children.delete(childKey);
        }
      }
      return sparseSnapshotTree.children.size === 0;
    } else {
      return true;
    }
  }
}
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
  if (sparseSnapshotTree.value !== null) {
    func(prefixPath, sparseSnapshotTree.value);
  } else {
    sparseSnapshotTreeForEachChild(sparseSnapshotTree, function(key, tree) {
      var path = new Path(prefixPath.toString() + "/" + key);
      sparseSnapshotTreeForEachTree(tree, path, func);
    });
  }
}
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
  sparseSnapshotTree.children.forEach(function(tree, key) {
    func(key, tree);
  });
}
var SnapshotHolder = (
  /** @class */
  function() {
    function SnapshotHolder2() {
      this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    SnapshotHolder2.prototype.getNode = function(path) {
      return this.rootNode_.getChild(path);
    };
    SnapshotHolder2.prototype.updateSnapshot = function(path, newSnapshotNode) {
      this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder2;
  }()
);
var StatsCollection = (
  /** @class */
  function() {
    function StatsCollection2() {
      this.counters_ = {};
    }
    StatsCollection2.prototype.incrementCounter = function(name10, amount) {
      if (amount === void 0) {
        amount = 1;
      }
      if (!contains(this.counters_, name10)) {
        this.counters_[name10] = 0;
      }
      this.counters_[name10] += amount;
    };
    StatsCollection2.prototype.get = function() {
      return deepCopy(this.counters_);
    };
    return StatsCollection2;
  }()
);
var collections = {};
var reporters = {};
function statsManagerGetCollection(repoInfo) {
  var hashString = repoInfo.toString();
  if (!collections[hashString]) {
    collections[hashString] = new StatsCollection();
  }
  return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
  var hashString = repoInfo.toString();
  if (!reporters[hashString]) {
    reporters[hashString] = creatorFunction();
  }
  return reporters[hashString];
}
var StatsListener = (
  /** @class */
  function() {
    function StatsListener2(collection_) {
      this.collection_ = collection_;
      this.last_ = null;
    }
    StatsListener2.prototype.get = function() {
      var newStats = this.collection_.get();
      var delta = __assign({}, newStats);
      if (this.last_) {
        each(this.last_, function(stat, value) {
          delta[stat] = delta[stat] - value;
        });
      }
      this.last_ = newStats;
      return delta;
    };
    return StatsListener2;
  }()
);
var FIRST_STATS_MIN_TIME = 10 * 1e3;
var FIRST_STATS_MAX_TIME = 30 * 1e3;
var REPORT_STATS_INTERVAL = 5 * 60 * 1e3;
var StatsReporter = (
  /** @class */
  function() {
    function StatsReporter2(collection, server_) {
      this.server_ = server_;
      this.statsToReport_ = {};
      this.statsListener_ = new StatsListener(collection);
      var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
      setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter2.prototype.reportStats_ = function() {
      var _this = this;
      var stats2 = this.statsListener_.get();
      var reportedStats = {};
      var haveStatsToReport = false;
      each(stats2, function(stat, value) {
        if (value > 0 && contains(_this.statsToReport_, stat)) {
          reportedStats[stat] = value;
          haveStatsToReport = true;
        }
      });
      if (haveStatsToReport) {
        this.server_.reportStats(reportedStats);
      }
      setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter2;
  }()
);
function statsReporterIncludeStat(reporter, stat) {
  reporter.statsToReport_[stat] = true;
}
var EventQueue = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventQueue2() {
      this.eventLists_ = [];
      this.recursionDepth_ = 0;
    }
    return EventQueue2;
  }()
);
function eventQueueQueueEvents(eventQueue, eventDataList) {
  var currList = null;
  for (var i = 0; i < eventDataList.length; i++) {
    var data = eventDataList[i];
    var path = data.getPath();
    if (currList !== null && !pathEquals(path, currList.path)) {
      eventQueue.eventLists_.push(currList);
      currList = null;
    }
    if (currList === null) {
      currList = { events: [], path };
    }
    currList.events.push(data);
  }
  if (currList) {
    eventQueue.eventLists_.push(currList);
  }
}
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
    return pathEquals(eventPath, path);
  });
}
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
    return pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath);
  });
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
  eventQueue.recursionDepth_++;
  var sentAll = true;
  for (var i = 0; i < eventQueue.eventLists_.length; i++) {
    var eventList = eventQueue.eventLists_[i];
    if (eventList) {
      var eventPath = eventList.path;
      if (predicate(eventPath)) {
        eventListRaise(eventQueue.eventLists_[i]);
        eventQueue.eventLists_[i] = null;
      } else {
        sentAll = false;
      }
    }
  }
  if (sentAll) {
    eventQueue.eventLists_ = [];
  }
  eventQueue.recursionDepth_--;
}
function eventListRaise(eventList) {
  for (var i = 0; i < eventList.events.length; i++) {
    var eventData = eventList.events[i];
    if (eventData !== null) {
      eventList.events[i] = null;
      var eventFn = eventData.getEventRunner();
      if (logger2) {
        log("event: " + eventData.toString());
      }
      exceptionGuard(eventFn);
    }
  }
}
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2(allowedEvents_) {
      this.allowedEvents_ = allowedEvents_;
      this.listeners_ = {};
      assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
    }
    EventEmitter2.prototype.trigger = function(eventType) {
      var varArgs = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        varArgs[_i2 - 1] = arguments[_i2];
      }
      if (Array.isArray(this.listeners_[eventType])) {
        var listeners = __spreadArray([], __read(this.listeners_[eventType]));
        for (var i = 0; i < listeners.length; i++) {
          listeners[i].callback.apply(listeners[i].context, varArgs);
        }
      }
    };
    EventEmitter2.prototype.on = function(eventType, callback, context) {
      this.validateEventType_(eventType);
      this.listeners_[eventType] = this.listeners_[eventType] || [];
      this.listeners_[eventType].push({ callback, context });
      var eventData = this.getInitialEvent(eventType);
      if (eventData) {
        callback.apply(context, eventData);
      }
    };
    EventEmitter2.prototype.off = function(eventType, callback, context) {
      this.validateEventType_(eventType);
      var listeners = this.listeners_[eventType] || [];
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    EventEmitter2.prototype.validateEventType_ = function(eventType) {
      assert(this.allowedEvents_.find(function(et2) {
        return et2 === eventType;
      }), "Unknown event: " + eventType);
    };
    return EventEmitter2;
  }()
);
var VisibilityMonitor = (
  /** @class */
  function(_super) {
    __extends(VisibilityMonitor2, _super);
    function VisibilityMonitor2() {
      var _this = _super.call(this, ["visible"]) || this;
      var hidden;
      var visibilityChange;
      if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
        if (typeof document["hidden"] !== "undefined") {
          visibilityChange = "visibilitychange";
          hidden = "hidden";
        } else if (typeof document["mozHidden"] !== "undefined") {
          visibilityChange = "mozvisibilitychange";
          hidden = "mozHidden";
        } else if (typeof document["msHidden"] !== "undefined") {
          visibilityChange = "msvisibilitychange";
          hidden = "msHidden";
        } else if (typeof document["webkitHidden"] !== "undefined") {
          visibilityChange = "webkitvisibilitychange";
          hidden = "webkitHidden";
        }
      }
      _this.visible_ = true;
      if (visibilityChange) {
        document.addEventListener(visibilityChange, function() {
          var visible = !document[hidden];
          if (visible !== _this.visible_) {
            _this.visible_ = visible;
            _this.trigger("visible", visible);
          }
        }, false);
      }
      return _this;
    }
    VisibilityMonitor2.getInstance = function() {
      return new VisibilityMonitor2();
    };
    VisibilityMonitor2.prototype.getInitialEvent = function(eventType) {
      assert(eventType === "visible", "Unknown event type: " + eventType);
      return [this.visible_];
    };
    return VisibilityMonitor2;
  }(EventEmitter)
);
var OnlineMonitor = (
  /** @class */
  function(_super) {
    __extends(OnlineMonitor2, _super);
    function OnlineMonitor2() {
      var _this = _super.call(this, ["online"]) || this;
      _this.online_ = true;
      if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !isMobileCordova()) {
        window.addEventListener("online", function() {
          if (!_this.online_) {
            _this.online_ = true;
            _this.trigger("online", true);
          }
        }, false);
        window.addEventListener("offline", function() {
          if (_this.online_) {
            _this.online_ = false;
            _this.trigger("online", false);
          }
        }, false);
      }
      return _this;
    }
    OnlineMonitor2.getInstance = function() {
      return new OnlineMonitor2();
    };
    OnlineMonitor2.prototype.getInitialEvent = function(eventType) {
      assert(eventType === "online", "Unknown event type: " + eventType);
      return [this.online_];
    };
    OnlineMonitor2.prototype.currentlyOnline = function() {
      return this.online_;
    };
    return OnlineMonitor2;
  }(EventEmitter)
);
var PacketReceiver = (
  /** @class */
  function() {
    function PacketReceiver2(onMessage_) {
      this.onMessage_ = onMessage_;
      this.pendingResponses = [];
      this.currentResponseNum = 0;
      this.closeAfterResponse = -1;
      this.onClose = null;
    }
    PacketReceiver2.prototype.closeAfter = function(responseNum, callback) {
      this.closeAfterResponse = responseNum;
      this.onClose = callback;
      if (this.closeAfterResponse < this.currentResponseNum) {
        this.onClose();
        this.onClose = null;
      }
    };
    PacketReceiver2.prototype.handleResponse = function(requestNum, data) {
      var _this = this;
      this.pendingResponses[requestNum] = data;
      var _loop_1 = function() {
        var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
        delete this_1.pendingResponses[this_1.currentResponseNum];
        var _loop_2 = function(i2) {
          if (toProcess[i2]) {
            exceptionGuard(function() {
              _this.onMessage_(toProcess[i2]);
            });
          }
        };
        for (var i = 0; i < toProcess.length; ++i) {
          _loop_2(i);
        }
        if (this_1.currentResponseNum === this_1.closeAfterResponse) {
          if (this_1.onClose) {
            this_1.onClose();
            this_1.onClose = null;
          }
          return "break";
        }
        this_1.currentResponseNum++;
      };
      var this_1 = this;
      while (this.pendingResponses[this.currentResponseNum]) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
    };
    return PacketReceiver2;
  }()
);
var FIREBASE_LONGPOLL_START_PARAM = "start";
var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
var FIREBASE_LONGPOLL_ID_PARAM = "id";
var FIREBASE_LONGPOLL_PW_PARAM = "pw";
var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
var FIREBASE_LONGPOLL_DATA_PARAM = "d";
var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30;
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
var KEEPALIVE_REQUEST_INTERVAL = 25e3;
var LP_CONNECT_TIMEOUT = 3e4;
var BrowserPollConnection = (
  /** @class */
  function() {
    function BrowserPollConnection2(connId, repoInfo, applicationId, transportSessionId, lastSessionId) {
      this.connId = connId;
      this.repoInfo = repoInfo;
      this.applicationId = applicationId;
      this.transportSessionId = transportSessionId;
      this.lastSessionId = lastSessionId;
      this.bytesSent = 0;
      this.bytesReceived = 0;
      this.everConnected_ = false;
      this.log_ = logWrapper(connId);
      this.stats_ = statsManagerGetCollection(repoInfo);
      this.urlFn = function(params) {
        return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
      };
    }
    BrowserPollConnection2.prototype.open = function(onMessage, onDisconnect) {
      var _this = this;
      this.curSegmentNum = 0;
      this.onDisconnect_ = onDisconnect;
      this.myPacketOrderer = new PacketReceiver(onMessage);
      this.isClosed_ = false;
      this.connectTimeoutTimer_ = setTimeout(function() {
        _this.log_("Timed out trying to connect.");
        _this.onClosed_();
        _this.connectTimeoutTimer_ = null;
      }, Math.floor(LP_CONNECT_TIMEOUT));
      executeWhenDOMReady(function() {
        if (_this.isClosed_) {
          return;
        }
        _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          var _a9 = __read(args, 5), command = _a9[0], arg1 = _a9[1], arg2 = _a9[2], arg3 = _a9[3], arg4 = _a9[4];
          _this.incrementIncomingBytes_(args);
          if (!_this.scriptTagHolder) {
            return;
          }
          if (_this.connectTimeoutTimer_) {
            clearTimeout(_this.connectTimeoutTimer_);
            _this.connectTimeoutTimer_ = null;
          }
          _this.everConnected_ = true;
          if (command === FIREBASE_LONGPOLL_START_PARAM) {
            _this.id = arg1;
            _this.password = arg2;
          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
            if (arg1) {
              _this.scriptTagHolder.sendNewPolls = false;
              _this.myPacketOrderer.closeAfter(arg1, function() {
                _this.onClosed_();
              });
            } else {
              _this.onClosed_();
            }
          } else {
            throw new Error("Unrecognized command received: " + command);
          }
        }, function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          var _a9 = __read(args, 2), pN = _a9[0], data = _a9[1];
          _this.incrementIncomingBytes_(args);
          _this.myPacketOrderer.handleResponse(pN, data);
        }, function() {
          _this.onClosed_();
        }, _this.urlFn);
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
        urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
        if (_this.scriptTagHolder.uniqueCallbackIdentifier) {
          urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
        }
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (_this.transportSessionId) {
          urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId;
        }
        if (_this.lastSessionId) {
          urlParams[LAST_SESSION_PARAM] = _this.lastSessionId;
        }
        if (_this.applicationId) {
          urlParams[APPLICATION_ID_PARAM] = _this.applicationId;
        }
        if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
          urlParams[REFERER_PARAM] = FORGE_REF;
        }
        var connectURL = _this.urlFn(urlParams);
        _this.log_("Connecting via long-poll to " + connectURL);
        _this.scriptTagHolder.addTag(connectURL, function() {
        });
      });
    };
    BrowserPollConnection2.prototype.start = function() {
      this.scriptTagHolder.startLongPoll(this.id, this.password);
      this.addDisconnectPingFrame(this.id, this.password);
    };
    BrowserPollConnection2.forceAllow = function() {
      BrowserPollConnection2.forceAllow_ = true;
    };
    BrowserPollConnection2.forceDisallow = function() {
      BrowserPollConnection2.forceDisallow_ = true;
    };
    BrowserPollConnection2.isAvailable = function() {
      if (isNodeSdk()) {
        return false;
      } else if (BrowserPollConnection2.forceAllow_) {
        return true;
      } else {
        return !BrowserPollConnection2.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
      }
    };
    BrowserPollConnection2.prototype.markConnectionHealthy = function() {
    };
    BrowserPollConnection2.prototype.shutdown_ = function() {
      this.isClosed_ = true;
      if (this.scriptTagHolder) {
        this.scriptTagHolder.close();
        this.scriptTagHolder = null;
      }
      if (this.myDisconnFrame) {
        document.body.removeChild(this.myDisconnFrame);
        this.myDisconnFrame = null;
      }
      if (this.connectTimeoutTimer_) {
        clearTimeout(this.connectTimeoutTimer_);
        this.connectTimeoutTimer_ = null;
      }
    };
    BrowserPollConnection2.prototype.onClosed_ = function() {
      if (!this.isClosed_) {
        this.log_("Longpoll is closing itself");
        this.shutdown_();
        if (this.onDisconnect_) {
          this.onDisconnect_(this.everConnected_);
          this.onDisconnect_ = null;
        }
      }
    };
    BrowserPollConnection2.prototype.close = function() {
      if (!this.isClosed_) {
        this.log_("Longpoll is being closed.");
        this.shutdown_();
      }
    };
    BrowserPollConnection2.prototype.send = function(data) {
      var dataStr = stringify(data);
      this.bytesSent += dataStr.length;
      this.stats_.incrementCounter("bytes_sent", dataStr.length);
      var base64data = base64Encode(dataStr);
      var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
      for (var i = 0; i < dataSegs.length; i++) {
        this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
        this.curSegmentNum++;
      }
    };
    BrowserPollConnection2.prototype.addDisconnectPingFrame = function(id2, pw) {
      if (isNodeSdk()) {
        return;
      }
      this.myDisconnFrame = document.createElement("iframe");
      var urlParams = {};
      urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id2;
      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
      this.myDisconnFrame.src = this.urlFn(urlParams);
      this.myDisconnFrame.style.display = "none";
      document.body.appendChild(this.myDisconnFrame);
    };
    BrowserPollConnection2.prototype.incrementIncomingBytes_ = function(args) {
      var bytesReceived = stringify(args).length;
      this.bytesReceived += bytesReceived;
      this.stats_.incrementCounter("bytes_received", bytesReceived);
    };
    return BrowserPollConnection2;
  }()
);
var FirebaseIFrameScriptHolder = (
  /** @class */
  function() {
    function FirebaseIFrameScriptHolder2(commandCB, onMessageCB, onDisconnect, urlFn) {
      this.onDisconnect = onDisconnect;
      this.urlFn = urlFn;
      this.outstandingRequests = /* @__PURE__ */ new Set();
      this.pendingSegs = [];
      this.currentSerial = Math.floor(Math.random() * 1e8);
      this.sendNewPolls = true;
      if (!isNodeSdk()) {
        this.uniqueCallbackIdentifier = LUIDGenerator();
        window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
        window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
        this.myIFrame = FirebaseIFrameScriptHolder2.createIFrame_();
        var script = "";
        if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
          var currentDomain = document.domain;
          script = '<script>document.domain="' + currentDomain + '";<\/script>';
        }
        var iframeContents = "<html><body>" + script + "</body></html>";
        try {
          this.myIFrame.doc.open();
          this.myIFrame.doc.write(iframeContents);
          this.myIFrame.doc.close();
        } catch (e) {
          log("frame writing exception");
          if (e.stack) {
            log(e.stack);
          }
          log(e);
        }
      } else {
        this.commandCB = commandCB;
        this.onMessageCB = onMessageCB;
      }
    }
    FirebaseIFrameScriptHolder2.createIFrame_ = function() {
      var iframe = document.createElement("iframe");
      iframe.style.display = "none";
      if (document.body) {
        document.body.appendChild(iframe);
        try {
          var a = iframe.contentWindow.document;
          if (!a) {
            log("No IE domain setting required");
          }
        } catch (e) {
          var domain = document.domain;
          iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
        }
      } else {
        throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
      }
      if (iframe.contentDocument) {
        iframe.doc = iframe.contentDocument;
      } else if (iframe.contentWindow) {
        iframe.doc = iframe.contentWindow.document;
      } else if (iframe.document) {
        iframe.doc = iframe.document;
      }
      return iframe;
    };
    FirebaseIFrameScriptHolder2.prototype.close = function() {
      var _this = this;
      this.alive = false;
      if (this.myIFrame) {
        this.myIFrame.doc.body.innerHTML = "";
        setTimeout(function() {
          if (_this.myIFrame !== null) {
            document.body.removeChild(_this.myIFrame);
            _this.myIFrame = null;
          }
        }, Math.floor(0));
      }
      var onDisconnect = this.onDisconnect;
      if (onDisconnect) {
        this.onDisconnect = null;
        onDisconnect();
      }
    };
    FirebaseIFrameScriptHolder2.prototype.startLongPoll = function(id2, pw) {
      this.myID = id2;
      this.myPW = pw;
      this.alive = true;
      while (this.newRequest_()) {
      }
    };
    FirebaseIFrameScriptHolder2.prototype.newRequest_ = function() {
      if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
        this.currentSerial++;
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
        urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
        var theURL = this.urlFn(urlParams);
        var curDataString = "";
        var i = 0;
        while (this.pendingSegs.length > 0) {
          var nextSeg = this.pendingSegs[0];
          if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
            var theSeg = this.pendingSegs.shift();
            curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
            i++;
          } else {
            break;
          }
        }
        theURL = theURL + curDataString;
        this.addLongPollTag_(theURL, this.currentSerial);
        return true;
      } else {
        return false;
      }
    };
    FirebaseIFrameScriptHolder2.prototype.enqueueSegment = function(segnum, totalsegs, data) {
      this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
      if (this.alive) {
        this.newRequest_();
      }
    };
    FirebaseIFrameScriptHolder2.prototype.addLongPollTag_ = function(url, serial) {
      var _this = this;
      this.outstandingRequests.add(serial);
      var doNewRequest = function() {
        _this.outstandingRequests.delete(serial);
        _this.newRequest_();
      };
      var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
      var readyStateCB = function() {
        clearTimeout(keepaliveTimeout);
        doNewRequest();
      };
      this.addTag(url, readyStateCB);
    };
    FirebaseIFrameScriptHolder2.prototype.addTag = function(url, loadCB) {
      var _this = this;
      if (isNodeSdk()) {
        this.doNodeLongPoll(url, loadCB);
      } else {
        setTimeout(function() {
          try {
            if (!_this.sendNewPolls) {
              return;
            }
            var newScript_1 = _this.myIFrame.doc.createElement("script");
            newScript_1.type = "text/javascript";
            newScript_1.async = true;
            newScript_1.src = url;
            newScript_1.onload = newScript_1.onreadystatechange = function() {
              var rstate = newScript_1.readyState;
              if (!rstate || rstate === "loaded" || rstate === "complete") {
                newScript_1.onload = newScript_1.onreadystatechange = null;
                if (newScript_1.parentNode) {
                  newScript_1.parentNode.removeChild(newScript_1);
                }
                loadCB();
              }
            };
            newScript_1.onerror = function() {
              log("Long-poll script failed to load: " + url);
              _this.sendNewPolls = false;
              _this.close();
            };
            _this.myIFrame.doc.body.appendChild(newScript_1);
          } catch (e) {
          }
        }, Math.floor(1));
      }
    };
    return FirebaseIFrameScriptHolder2;
  }()
);
var SDK_VERSION = "";
function setSDKVersion(version10) {
  SDK_VERSION = version10;
}
var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
var WebSocketImpl = null;
if (typeof MozWebSocket !== "undefined") {
  WebSocketImpl = MozWebSocket;
} else if (typeof WebSocket !== "undefined") {
  WebSocketImpl = WebSocket;
}
var WebSocketConnection = (
  /** @class */
  function() {
    function WebSocketConnection2(connId, repoInfo, applicationId, transportSessionId, lastSessionId) {
      this.connId = connId;
      this.applicationId = applicationId;
      this.keepaliveTimer = null;
      this.frames = null;
      this.totalFrames = 0;
      this.bytesSent = 0;
      this.bytesReceived = 0;
      this.log_ = logWrapper(this.connId);
      this.stats_ = statsManagerGetCollection(repoInfo);
      this.connURL = WebSocketConnection2.connectionURL_(repoInfo, transportSessionId, lastSessionId);
      this.nodeAdmin = repoInfo.nodeAdmin;
    }
    WebSocketConnection2.connectionURL_ = function(repoInfo, transportSessionId, lastSessionId) {
      var urlParams = {};
      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
      if (!isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
        urlParams[REFERER_PARAM] = FORGE_REF;
      }
      if (transportSessionId) {
        urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
      }
      if (lastSessionId) {
        urlParams[LAST_SESSION_PARAM] = lastSessionId;
      }
      return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
    };
    WebSocketConnection2.prototype.open = function(onMessage, onDisconnect) {
      var _this = this;
      this.onDisconnect = onDisconnect;
      this.onMessage = onMessage;
      this.log_("Websocket connecting to " + this.connURL);
      this.everConnected_ = false;
      PersistentStorage.set("previous_websocket_failure", true);
      try {
        if (isNodeSdk()) {
          var device = this.nodeAdmin ? "AdminNode" : "Node";
          var options = {
            headers: {
              "User-Agent": "Firebase/" + PROTOCOL_VERSION + "/" + SDK_VERSION + "/" + process.platform + "/" + device,
              "X-Firebase-GMPID": this.applicationId || ""
            }
          };
          var env = process["env"];
          var proxy = this.connURL.indexOf("wss://") === 0 ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
          if (proxy) {
            options["proxy"] = { origin: proxy };
          }
          this.mySock = new WebSocketImpl(this.connURL, [], options);
        } else {
          var options = {
            headers: {
              "X-Firebase-GMPID": this.applicationId || ""
            }
          };
          this.mySock = new WebSocketImpl(this.connURL, [], options);
        }
      } catch (e) {
        this.log_("Error instantiating WebSocket.");
        var error2 = e.message || e.data;
        if (error2) {
          this.log_(error2);
        }
        this.onClosed_();
        return;
      }
      this.mySock.onopen = function() {
        _this.log_("Websocket connected.");
        _this.everConnected_ = true;
      };
      this.mySock.onclose = function() {
        _this.log_("Websocket connection was disconnected.");
        _this.mySock = null;
        _this.onClosed_();
      };
      this.mySock.onmessage = function(m) {
        _this.handleIncomingFrame(m);
      };
      this.mySock.onerror = function(e) {
        _this.log_("WebSocket error.  Closing connection.");
        var error3 = e.message || e.data;
        if (error3) {
          _this.log_(error3);
        }
        _this.onClosed_();
      };
    };
    WebSocketConnection2.prototype.start = function() {
    };
    WebSocketConnection2.forceDisallow = function() {
      WebSocketConnection2.forceDisallow_ = true;
    };
    WebSocketConnection2.isAvailable = function() {
      var isOldAndroid = false;
      if (typeof navigator !== "undefined" && navigator.userAgent) {
        var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
        var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
        if (oldAndroidMatch && oldAndroidMatch.length > 1) {
          if (parseFloat(oldAndroidMatch[1]) < 4.4) {
            isOldAndroid = true;
          }
        }
      }
      return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection2.forceDisallow_;
    };
    WebSocketConnection2.previouslyFailed = function() {
      return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
    };
    WebSocketConnection2.prototype.markConnectionHealthy = function() {
      PersistentStorage.remove("previous_websocket_failure");
    };
    WebSocketConnection2.prototype.appendFrame_ = function(data) {
      this.frames.push(data);
      if (this.frames.length === this.totalFrames) {
        var fullMess = this.frames.join("");
        this.frames = null;
        var jsonMess = jsonEval(fullMess);
        this.onMessage(jsonMess);
      }
    };
    WebSocketConnection2.prototype.handleNewFrameCount_ = function(frameCount) {
      this.totalFrames = frameCount;
      this.frames = [];
    };
    WebSocketConnection2.prototype.extractFrameCount_ = function(data) {
      assert(this.frames === null, "We already have a frame buffer");
      if (data.length <= 6) {
        var frameCount = Number(data);
        if (!isNaN(frameCount)) {
          this.handleNewFrameCount_(frameCount);
          return null;
        }
      }
      this.handleNewFrameCount_(1);
      return data;
    };
    WebSocketConnection2.prototype.handleIncomingFrame = function(mess) {
      if (this.mySock === null) {
        return;
      }
      var data = mess["data"];
      this.bytesReceived += data.length;
      this.stats_.incrementCounter("bytes_received", data.length);
      this.resetKeepAlive();
      if (this.frames !== null) {
        this.appendFrame_(data);
      } else {
        var remainingData = this.extractFrameCount_(data);
        if (remainingData !== null) {
          this.appendFrame_(remainingData);
        }
      }
    };
    WebSocketConnection2.prototype.send = function(data) {
      this.resetKeepAlive();
      var dataStr = stringify(data);
      this.bytesSent += dataStr.length;
      this.stats_.incrementCounter("bytes_sent", dataStr.length);
      var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
      if (dataSegs.length > 1) {
        this.sendString_(String(dataSegs.length));
      }
      for (var i = 0; i < dataSegs.length; i++) {
        this.sendString_(dataSegs[i]);
      }
    };
    WebSocketConnection2.prototype.shutdown_ = function() {
      this.isClosed_ = true;
      if (this.keepaliveTimer) {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = null;
      }
      if (this.mySock) {
        this.mySock.close();
        this.mySock = null;
      }
    };
    WebSocketConnection2.prototype.onClosed_ = function() {
      if (!this.isClosed_) {
        this.log_("WebSocket is closing itself");
        this.shutdown_();
        if (this.onDisconnect) {
          this.onDisconnect(this.everConnected_);
          this.onDisconnect = null;
        }
      }
    };
    WebSocketConnection2.prototype.close = function() {
      if (!this.isClosed_) {
        this.log_("WebSocket is being closed");
        this.shutdown_();
      }
    };
    WebSocketConnection2.prototype.resetKeepAlive = function() {
      var _this = this;
      clearInterval(this.keepaliveTimer);
      this.keepaliveTimer = setInterval(function() {
        if (_this.mySock) {
          _this.sendString_("0");
        }
        _this.resetKeepAlive();
      }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    };
    WebSocketConnection2.prototype.sendString_ = function(str) {
      try {
        this.mySock.send(str);
      } catch (e) {
        this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
        setTimeout(this.onClosed_.bind(this), 0);
      }
    };
    WebSocketConnection2.responsesRequiredToBeHealthy = 2;
    WebSocketConnection2.healthyTimeout = 3e4;
    return WebSocketConnection2;
  }()
);
var TransportManager = (
  /** @class */
  function() {
    function TransportManager2(repoInfo) {
      this.initTransports_(repoInfo);
    }
    Object.defineProperty(TransportManager2, "ALL_TRANSPORTS", {
      get: function() {
        return [BrowserPollConnection, WebSocketConnection];
      },
      enumerable: false,
      configurable: true
    });
    TransportManager2.prototype.initTransports_ = function(repoInfo) {
      var e_1, _a9;
      var isWebSocketsAvailable2 = WebSocketConnection && WebSocketConnection["isAvailable"]();
      var isSkipPollConnection = isWebSocketsAvailable2 && !WebSocketConnection.previouslyFailed();
      if (repoInfo.webSocketOnly) {
        if (!isWebSocketsAvailable2) {
          warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
        }
        isSkipPollConnection = true;
      }
      if (isSkipPollConnection) {
        this.transports_ = [WebSocketConnection];
      } else {
        var transports = this.transports_ = [];
        try {
          for (var _b = __values(TransportManager2.ALL_TRANSPORTS), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
            var transport = _c2.value;
            if (transport && transport["isAvailable"]()) {
              transports.push(transport);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a9 = _b.return))
              _a9.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    };
    TransportManager2.prototype.initialTransport = function() {
      if (this.transports_.length > 0) {
        return this.transports_[0];
      } else {
        throw new Error("No transports available");
      }
    };
    TransportManager2.prototype.upgradeTransport = function() {
      if (this.transports_.length > 1) {
        return this.transports_[1];
      } else {
        return null;
      }
    };
    return TransportManager2;
  }()
);
var UPGRADE_TIMEOUT = 6e4;
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = "t";
var MESSAGE_DATA = "d";
var CONTROL_SHUTDOWN = "s";
var CONTROL_RESET = "r";
var CONTROL_ERROR = "e";
var CONTROL_PONG = "o";
var SWITCH_ACK = "a";
var END_TRANSMISSION = "n";
var PING = "p";
var SERVER_HELLO = "h";
var Connection = (
  /** @class */
  function() {
    function Connection2(id2, repoInfo_, applicationId_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
      this.id = id2;
      this.repoInfo_ = repoInfo_;
      this.applicationId_ = applicationId_;
      this.onMessage_ = onMessage_;
      this.onReady_ = onReady_;
      this.onDisconnect_ = onDisconnect_;
      this.onKill_ = onKill_;
      this.lastSessionId = lastSessionId;
      this.connectionCount = 0;
      this.pendingDataMessages = [];
      this.state_ = 0;
      this.log_ = logWrapper("c:" + this.id + ":");
      this.transportManager_ = new TransportManager(repoInfo_);
      this.log_("Connection created");
      this.start_();
    }
    Connection2.prototype.start_ = function() {
      var _this = this;
      var conn = this.transportManager_.initialTransport();
      this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, void 0, this.lastSessionId);
      this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
      var onMessageReceived = this.connReceiver_(this.conn_);
      var onConnectionLost = this.disconnReceiver_(this.conn_);
      this.tx_ = this.conn_;
      this.rx_ = this.conn_;
      this.secondaryConn_ = null;
      this.isHealthy_ = false;
      setTimeout(function() {
        _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
      }, Math.floor(0));
      var healthyTimeoutMS = conn["healthyTimeout"] || 0;
      if (healthyTimeoutMS > 0) {
        this.healthyTimeout_ = setTimeoutNonBlocking(function() {
          _this.healthyTimeout_ = null;
          if (!_this.isHealthy_) {
            if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
              _this.log_("Connection exceeded healthy timeout but has received " + _this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
              _this.isHealthy_ = true;
              _this.conn_.markConnectionHealthy();
            } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
              _this.log_("Connection exceeded healthy timeout but has sent " + _this.conn_.bytesSent + " bytes.  Leaving connection alive.");
            } else {
              _this.log_("Closing unhealthy connection after timeout.");
              _this.close();
            }
          }
        }, Math.floor(healthyTimeoutMS));
      }
    };
    Connection2.prototype.nextTransportId_ = function() {
      return "c:" + this.id + ":" + this.connectionCount++;
    };
    Connection2.prototype.disconnReceiver_ = function(conn) {
      var _this = this;
      return function(everConnected) {
        if (conn === _this.conn_) {
          _this.onConnectionLost_(everConnected);
        } else if (conn === _this.secondaryConn_) {
          _this.log_("Secondary connection lost.");
          _this.onSecondaryConnectionLost_();
        } else {
          _this.log_("closing an old connection");
        }
      };
    };
    Connection2.prototype.connReceiver_ = function(conn) {
      var _this = this;
      return function(message) {
        if (_this.state_ !== 2) {
          if (conn === _this.rx_) {
            _this.onPrimaryMessageReceived_(message);
          } else if (conn === _this.secondaryConn_) {
            _this.onSecondaryMessageReceived_(message);
          } else {
            _this.log_("message on old connection");
          }
        }
      };
    };
    Connection2.prototype.sendRequest = function(dataMsg) {
      var msg = { t: "d", d: dataMsg };
      this.sendData_(msg);
    };
    Connection2.prototype.tryCleanupConnection = function() {
      if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
        this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
        this.conn_ = this.secondaryConn_;
        this.secondaryConn_ = null;
      }
    };
    Connection2.prototype.onSecondaryControl_ = function(controlData) {
      if (MESSAGE_TYPE in controlData) {
        var cmd = controlData[MESSAGE_TYPE];
        if (cmd === SWITCH_ACK) {
          this.upgradeIfSecondaryHealthy_();
        } else if (cmd === CONTROL_RESET) {
          this.log_("Got a reset on secondary, closing it");
          this.secondaryConn_.close();
          if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
            this.close();
          }
        } else if (cmd === CONTROL_PONG) {
          this.log_("got pong on secondary.");
          this.secondaryResponsesRequired_--;
          this.upgradeIfSecondaryHealthy_();
        }
      }
    };
    Connection2.prototype.onSecondaryMessageReceived_ = function(parsedData) {
      var layer = requireKey("t", parsedData);
      var data = requireKey("d", parsedData);
      if (layer === "c") {
        this.onSecondaryControl_(data);
      } else if (layer === "d") {
        this.pendingDataMessages.push(data);
      } else {
        throw new Error("Unknown protocol layer: " + layer);
      }
    };
    Connection2.prototype.upgradeIfSecondaryHealthy_ = function() {
      if (this.secondaryResponsesRequired_ <= 0) {
        this.log_("Secondary connection is healthy.");
        this.isHealthy_ = true;
        this.secondaryConn_.markConnectionHealthy();
        this.proceedWithUpgrade_();
      } else {
        this.log_("sending ping on secondary.");
        this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
      }
    };
    Connection2.prototype.proceedWithUpgrade_ = function() {
      this.secondaryConn_.start();
      this.log_("sending client ack on secondary");
      this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
      this.log_("Ending transmission on primary");
      this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
      this.tx_ = this.secondaryConn_;
      this.tryCleanupConnection();
    };
    Connection2.prototype.onPrimaryMessageReceived_ = function(parsedData) {
      var layer = requireKey("t", parsedData);
      var data = requireKey("d", parsedData);
      if (layer === "c") {
        this.onControl_(data);
      } else if (layer === "d") {
        this.onDataMessage_(data);
      }
    };
    Connection2.prototype.onDataMessage_ = function(message) {
      this.onPrimaryResponse_();
      this.onMessage_(message);
    };
    Connection2.prototype.onPrimaryResponse_ = function() {
      if (!this.isHealthy_) {
        this.primaryResponsesRequired_--;
        if (this.primaryResponsesRequired_ <= 0) {
          this.log_("Primary connection is healthy.");
          this.isHealthy_ = true;
          this.conn_.markConnectionHealthy();
        }
      }
    };
    Connection2.prototype.onControl_ = function(controlData) {
      var cmd = requireKey(MESSAGE_TYPE, controlData);
      if (MESSAGE_DATA in controlData) {
        var payload = controlData[MESSAGE_DATA];
        if (cmd === SERVER_HELLO) {
          this.onHandshake_(payload);
        } else if (cmd === END_TRANSMISSION) {
          this.log_("recvd end transmission on primary");
          this.rx_ = this.secondaryConn_;
          for (var i = 0; i < this.pendingDataMessages.length; ++i) {
            this.onDataMessage_(this.pendingDataMessages[i]);
          }
          this.pendingDataMessages = [];
          this.tryCleanupConnection();
        } else if (cmd === CONTROL_SHUTDOWN) {
          this.onConnectionShutdown_(payload);
        } else if (cmd === CONTROL_RESET) {
          this.onReset_(payload);
        } else if (cmd === CONTROL_ERROR) {
          error("Server Error: " + payload);
        } else if (cmd === CONTROL_PONG) {
          this.log_("got pong on primary.");
          this.onPrimaryResponse_();
          this.sendPingOnPrimaryIfNecessary_();
        } else {
          error("Unknown control packet command: " + cmd);
        }
      }
    };
    Connection2.prototype.onHandshake_ = function(handshake) {
      var timestamp = handshake.ts;
      var version10 = handshake.v;
      var host = handshake.h;
      this.sessionId = handshake.s;
      this.repoInfo_.host = host;
      if (this.state_ === 0) {
        this.conn_.start();
        this.onConnectionEstablished_(this.conn_, timestamp);
        if (PROTOCOL_VERSION !== version10) {
          warn("Protocol version mismatch detected");
        }
        this.tryStartUpgrade_();
      }
    };
    Connection2.prototype.tryStartUpgrade_ = function() {
      var conn = this.transportManager_.upgradeTransport();
      if (conn) {
        this.startUpgrade_(conn);
      }
    };
    Connection2.prototype.startUpgrade_ = function(conn) {
      var _this = this;
      this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.sessionId);
      this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
      var onMessage = this.connReceiver_(this.secondaryConn_);
      var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
      this.secondaryConn_.open(onMessage, onDisconnect);
      setTimeoutNonBlocking(function() {
        if (_this.secondaryConn_) {
          _this.log_("Timed out trying to upgrade.");
          _this.secondaryConn_.close();
        }
      }, Math.floor(UPGRADE_TIMEOUT));
    };
    Connection2.prototype.onReset_ = function(host) {
      this.log_("Reset packet received.  New host: " + host);
      this.repoInfo_.host = host;
      if (this.state_ === 1) {
        this.close();
      } else {
        this.closeConnections_();
        this.start_();
      }
    };
    Connection2.prototype.onConnectionEstablished_ = function(conn, timestamp) {
      var _this = this;
      this.log_("Realtime connection established.");
      this.conn_ = conn;
      this.state_ = 1;
      if (this.onReady_) {
        this.onReady_(timestamp, this.sessionId);
        this.onReady_ = null;
      }
      if (this.primaryResponsesRequired_ === 0) {
        this.log_("Primary connection is healthy.");
        this.isHealthy_ = true;
      } else {
        setTimeoutNonBlocking(function() {
          _this.sendPingOnPrimaryIfNecessary_();
        }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
      }
    };
    Connection2.prototype.sendPingOnPrimaryIfNecessary_ = function() {
      if (!this.isHealthy_ && this.state_ === 1) {
        this.log_("sending ping on primary.");
        this.sendData_({ t: "c", d: { t: PING, d: {} } });
      }
    };
    Connection2.prototype.onSecondaryConnectionLost_ = function() {
      var conn = this.secondaryConn_;
      this.secondaryConn_ = null;
      if (this.tx_ === conn || this.rx_ === conn) {
        this.close();
      }
    };
    Connection2.prototype.onConnectionLost_ = function(everConnected) {
      this.conn_ = null;
      if (!everConnected && this.state_ === 0) {
        this.log_("Realtime connection failed.");
        if (this.repoInfo_.isCacheableHost()) {
          PersistentStorage.remove("host:" + this.repoInfo_.host);
          this.repoInfo_.internalHost = this.repoInfo_.host;
        }
      } else if (this.state_ === 1) {
        this.log_("Realtime connection lost.");
      }
      this.close();
    };
    Connection2.prototype.onConnectionShutdown_ = function(reason) {
      this.log_("Connection shutdown command received. Shutting down...");
      if (this.onKill_) {
        this.onKill_(reason);
        this.onKill_ = null;
      }
      this.onDisconnect_ = null;
      this.close();
    };
    Connection2.prototype.sendData_ = function(data) {
      if (this.state_ !== 1) {
        throw "Connection is not connected";
      } else {
        this.tx_.send(data);
      }
    };
    Connection2.prototype.close = function() {
      if (this.state_ !== 2) {
        this.log_("Closing realtime connection.");
        this.state_ = 2;
        this.closeConnections_();
        if (this.onDisconnect_) {
          this.onDisconnect_();
          this.onDisconnect_ = null;
        }
      }
    };
    Connection2.prototype.closeConnections_ = function() {
      this.log_("Shutting down all connections");
      if (this.conn_) {
        this.conn_.close();
        this.conn_ = null;
      }
      if (this.secondaryConn_) {
        this.secondaryConn_.close();
        this.secondaryConn_ = null;
      }
      if (this.healthyTimeout_) {
        clearTimeout(this.healthyTimeout_);
        this.healthyTimeout_ = null;
      }
    };
    return Connection2;
  }()
);
var ServerActions = (
  /** @class */
  function() {
    function ServerActions2() {
    }
    ServerActions2.prototype.put = function(pathString, data, onComplete, hash) {
    };
    ServerActions2.prototype.merge = function(pathString, data, onComplete, hash) {
    };
    ServerActions2.prototype.refreshAuthToken = function(token) {
    };
    ServerActions2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
    };
    ServerActions2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
    };
    ServerActions2.prototype.onDisconnectCancel = function(pathString, onComplete) {
    };
    ServerActions2.prototype.reportStats = function(stats2) {
    };
    return ServerActions2;
  }()
);
var RECONNECT_MIN_DELAY = 1e3;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1e3;
var GET_CONNECT_TIMEOUT = 3 * 1e3;
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1e3;
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
var SERVER_KILL_INTERRUPT_REASON = "server_kill";
var INVALID_AUTH_TOKEN_THRESHOLD = 3;
var PersistentConnection = (
  /** @class */
  function(_super) {
    __extends(PersistentConnection2, _super);
    function PersistentConnection2(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {
      var _this = _super.call(this) || this;
      _this.repoInfo_ = repoInfo_;
      _this.applicationId_ = applicationId_;
      _this.onDataUpdate_ = onDataUpdate_;
      _this.onConnectStatus_ = onConnectStatus_;
      _this.onServerInfoUpdate_ = onServerInfoUpdate_;
      _this.authTokenProvider_ = authTokenProvider_;
      _this.authOverride_ = authOverride_;
      _this.id = PersistentConnection2.nextPersistentConnectionId_++;
      _this.log_ = logWrapper("p:" + _this.id + ":");
      _this.interruptReasons_ = {};
      _this.listens = /* @__PURE__ */ new Map();
      _this.outstandingPuts_ = [];
      _this.outstandingGets_ = [];
      _this.outstandingPutCount_ = 0;
      _this.outstandingGetCount_ = 0;
      _this.onDisconnectRequestQueue_ = [];
      _this.connected_ = false;
      _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
      _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
      _this.securityDebugCallback_ = null;
      _this.lastSessionId = null;
      _this.establishConnectionTimer_ = null;
      _this.visible_ = false;
      _this.requestCBHash_ = {};
      _this.requestNumber_ = 0;
      _this.realtime_ = null;
      _this.authToken_ = null;
      _this.forceTokenRefresh_ = false;
      _this.invalidAuthTokenCount_ = 0;
      _this.firstConnection_ = true;
      _this.lastConnectionAttemptTime_ = null;
      _this.lastConnectionEstablishedTime_ = null;
      if (authOverride_ && !isNodeSdk()) {
        throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
      }
      _this.scheduleConnect_(0);
      VisibilityMonitor.getInstance().on("visible", _this.onVisible_, _this);
      if (repoInfo_.host.indexOf("fblocal") === -1) {
        OnlineMonitor.getInstance().on("online", _this.onOnline_, _this);
      }
      return _this;
    }
    PersistentConnection2.prototype.sendRequest = function(action, body, onResponse) {
      var curReqNum = ++this.requestNumber_;
      var msg = { r: curReqNum, a: action, b: body };
      this.log_(stringify(msg));
      assert(this.connected_, "sendRequest call when we're not connected not allowed.");
      this.realtime_.sendRequest(msg);
      if (onResponse) {
        this.requestCBHash_[curReqNum] = onResponse;
      }
    };
    PersistentConnection2.prototype.get = function(query) {
      var _this = this;
      var deferred = new Deferred();
      var request = {
        p: query.path.toString(),
        q: query.queryObject()
      };
      var outstandingGet = {
        action: "g",
        request,
        onComplete: function(message) {
          var payload = message["d"];
          if (message["s"] === "ok") {
            _this.onDataUpdate_(
              request["p"],
              payload,
              /*isMerge*/
              false,
              /*tag*/
              null
            );
            deferred.resolve(payload);
          } else {
            deferred.reject(payload);
          }
        }
      };
      this.outstandingGets_.push(outstandingGet);
      this.outstandingGetCount_++;
      var index = this.outstandingGets_.length - 1;
      if (!this.connected_) {
        setTimeout(function() {
          var get = _this.outstandingGets_[index];
          if (get === void 0 || outstandingGet !== get) {
            return;
          }
          delete _this.outstandingGets_[index];
          _this.outstandingGetCount_--;
          if (_this.outstandingGetCount_ === 0) {
            _this.outstandingGets_ = [];
          }
          _this.log_("get " + index + " timed out on connection");
          deferred.reject(new Error("Client is offline."));
        }, GET_CONNECT_TIMEOUT);
      }
      if (this.connected_) {
        this.sendGet_(index);
      }
      return deferred.promise;
    };
    PersistentConnection2.prototype.listen = function(query, currentHashFn, tag, onComplete) {
      var queryId = query.queryIdentifier();
      var pathString = query.path.toString();
      this.log_("Listen called for " + pathString + " " + queryId);
      if (!this.listens.has(pathString)) {
        this.listens.set(pathString, /* @__PURE__ */ new Map());
      }
      assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), "listen() called for non-default but complete query");
      assert(!this.listens.get(pathString).has(queryId), "listen() called twice for same path/queryId.");
      var listenSpec = {
        onComplete,
        hashFn: currentHashFn,
        query,
        tag
      };
      this.listens.get(pathString).set(queryId, listenSpec);
      if (this.connected_) {
        this.sendListen_(listenSpec);
      }
    };
    PersistentConnection2.prototype.sendGet_ = function(index) {
      var _this = this;
      var get = this.outstandingGets_[index];
      this.sendRequest("g", get.request, function(message) {
        delete _this.outstandingGets_[index];
        _this.outstandingGetCount_--;
        if (_this.outstandingGetCount_ === 0) {
          _this.outstandingGets_ = [];
        }
        if (get.onComplete) {
          get.onComplete(message);
        }
      });
    };
    PersistentConnection2.prototype.sendListen_ = function(listenSpec) {
      var _this = this;
      var query = listenSpec.query;
      var pathString = query.path.toString();
      var queryId = query.queryIdentifier();
      this.log_("Listen on " + pathString + " for " + queryId);
      var req = {
        /*path*/
        p: pathString
      };
      var action = "q";
      if (listenSpec.tag) {
        req["q"] = query.queryObject();
        req["t"] = listenSpec.tag;
      }
      req[
        /*hash*/
        "h"
      ] = listenSpec.hashFn();
      this.sendRequest(action, req, function(message) {
        var payload = message[
          /*data*/
          "d"
        ];
        var status = message[
          /*status*/
          "s"
        ];
        PersistentConnection2.warnOnListenWarnings_(payload, query);
        var currentListenSpec = _this.listens.get(pathString) && _this.listens.get(pathString).get(queryId);
        if (currentListenSpec === listenSpec) {
          _this.log_("listen response", message);
          if (status !== "ok") {
            _this.removeListen_(pathString, queryId);
          }
          if (listenSpec.onComplete) {
            listenSpec.onComplete(status, payload);
          }
        }
      });
    };
    PersistentConnection2.warnOnListenWarnings_ = function(payload, query) {
      if (payload && typeof payload === "object" && contains(payload, "w")) {
        var warnings = safeGet(payload, "w");
        if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
          var indexSpec = '".indexOn": "' + query.getQueryParams().getIndex().toString() + '"';
          var indexPath = query.path.toString();
          warn("Using an unspecified index. Your data will be downloaded and " + ("filtered on the client. Consider adding " + indexSpec + " at ") + (indexPath + " to your security rules for better performance."));
        }
      }
    };
    PersistentConnection2.prototype.refreshAuthToken = function(token) {
      this.authToken_ = token;
      this.log_("Auth token refreshed");
      if (this.authToken_) {
        this.tryAuth();
      } else {
        if (this.connected_) {
          this.sendRequest("unauth", {}, function() {
          });
        }
      }
      this.reduceReconnectDelayIfAdminCredential_(token);
    };
    PersistentConnection2.prototype.reduceReconnectDelayIfAdminCredential_ = function(credential) {
      var isFirebaseSecret = credential && credential.length === 40;
      if (isFirebaseSecret || isAdmin(credential)) {
        this.log_("Admin auth credential detected.  Reducing max reconnect time.");
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
      }
    };
    PersistentConnection2.prototype.tryAuth = function() {
      var _this = this;
      if (this.connected_ && this.authToken_) {
        var token_1 = this.authToken_;
        var authMethod = isValidFormat(token_1) ? "auth" : "gauth";
        var requestData = { cred: token_1 };
        if (this.authOverride_ === null) {
          requestData["noauth"] = true;
        } else if (typeof this.authOverride_ === "object") {
          requestData["authvar"] = this.authOverride_;
        }
        this.sendRequest(authMethod, requestData, function(res) {
          var status = res[
            /*status*/
            "s"
          ];
          var data = res[
            /*data*/
            "d"
          ] || "error";
          if (_this.authToken_ === token_1) {
            if (status === "ok") {
              _this.invalidAuthTokenCount_ = 0;
            } else {
              _this.onAuthRevoked_(status, data);
            }
          }
        });
      }
    };
    PersistentConnection2.prototype.unlisten = function(query, tag) {
      var pathString = query.path.toString();
      var queryId = query.queryIdentifier();
      this.log_("Unlisten called for " + pathString + " " + queryId);
      assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), "unlisten() called for non-default but complete query");
      var listen = this.removeListen_(pathString, queryId);
      if (listen && this.connected_) {
        this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);
      }
    };
    PersistentConnection2.prototype.sendUnlisten_ = function(pathString, queryId, queryObj, tag) {
      this.log_("Unlisten on " + pathString + " for " + queryId);
      var req = {
        /*path*/
        p: pathString
      };
      var action = "n";
      if (tag) {
        req["q"] = queryObj;
        req["t"] = tag;
      }
      this.sendRequest(action, req);
    };
    PersistentConnection2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
      if (this.connected_) {
        this.sendOnDisconnect_("o", pathString, data, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "o",
          data,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
      if (this.connected_) {
        this.sendOnDisconnect_("om", pathString, data, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "om",
          data,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.onDisconnectCancel = function(pathString, onComplete) {
      if (this.connected_) {
        this.sendOnDisconnect_("oc", pathString, null, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "oc",
          data: null,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.sendOnDisconnect_ = function(action, pathString, data, onComplete) {
      var request = {
        /*path*/
        p: pathString,
        /*data*/
        d: data
      };
      this.log_("onDisconnect " + action, request);
      this.sendRequest(action, request, function(response) {
        if (onComplete) {
          setTimeout(function() {
            onComplete(response[
              /*status*/
              "s"
            ], response[
              /* data */
              "d"
            ]);
          }, Math.floor(0));
        }
      });
    };
    PersistentConnection2.prototype.put = function(pathString, data, onComplete, hash) {
      this.putInternal("p", pathString, data, onComplete, hash);
    };
    PersistentConnection2.prototype.merge = function(pathString, data, onComplete, hash) {
      this.putInternal("m", pathString, data, onComplete, hash);
    };
    PersistentConnection2.prototype.putInternal = function(action, pathString, data, onComplete, hash) {
      var request = {
        /*path*/
        p: pathString,
        /*data*/
        d: data
      };
      if (hash !== void 0) {
        request[
          /*hash*/
          "h"
        ] = hash;
      }
      this.outstandingPuts_.push({
        action,
        request,
        onComplete
      });
      this.outstandingPutCount_++;
      var index = this.outstandingPuts_.length - 1;
      if (this.connected_) {
        this.sendPut_(index);
      } else {
        this.log_("Buffering put: " + pathString);
      }
    };
    PersistentConnection2.prototype.sendPut_ = function(index) {
      var _this = this;
      var action = this.outstandingPuts_[index].action;
      var request = this.outstandingPuts_[index].request;
      var onComplete = this.outstandingPuts_[index].onComplete;
      this.outstandingPuts_[index].queued = this.connected_;
      this.sendRequest(action, request, function(message) {
        _this.log_(action + " response", message);
        delete _this.outstandingPuts_[index];
        _this.outstandingPutCount_--;
        if (_this.outstandingPutCount_ === 0) {
          _this.outstandingPuts_ = [];
        }
        if (onComplete) {
          onComplete(message[
            /*status*/
            "s"
          ], message[
            /* data */
            "d"
          ]);
        }
      });
    };
    PersistentConnection2.prototype.reportStats = function(stats2) {
      var _this = this;
      if (this.connected_) {
        var request = {
          /*counters*/
          c: stats2
        };
        this.log_("reportStats", request);
        this.sendRequest(
          /*stats*/
          "s",
          request,
          function(result) {
            var status = result[
              /*status*/
              "s"
            ];
            if (status !== "ok") {
              var errorReason = result[
                /* data */
                "d"
              ];
              _this.log_("reportStats", "Error sending stats: " + errorReason);
            }
          }
        );
      }
    };
    PersistentConnection2.prototype.onDataMessage_ = function(message) {
      if ("r" in message) {
        this.log_("from server: " + stringify(message));
        var reqNum = message["r"];
        var onResponse = this.requestCBHash_[reqNum];
        if (onResponse) {
          delete this.requestCBHash_[reqNum];
          onResponse(message[
            /*body*/
            "b"
          ]);
        }
      } else if ("error" in message) {
        throw "A server-side error has occurred: " + message["error"];
      } else if ("a" in message) {
        this.onDataPush_(message["a"], message["b"]);
      }
    };
    PersistentConnection2.prototype.onDataPush_ = function(action, body) {
      this.log_("handleServerMessage", action, body);
      if (action === "d") {
        this.onDataUpdate_(
          body[
            /*path*/
            "p"
          ],
          body[
            /*data*/
            "d"
          ],
          /*isMerge*/
          false,
          body["t"]
        );
      } else if (action === "m") {
        this.onDataUpdate_(
          body[
            /*path*/
            "p"
          ],
          body[
            /*data*/
            "d"
          ],
          /*isMerge=*/
          true,
          body["t"]
        );
      } else if (action === "c") {
        this.onListenRevoked_(body[
          /*path*/
          "p"
        ], body[
          /*query*/
          "q"
        ]);
      } else if (action === "ac") {
        this.onAuthRevoked_(body[
          /*status code*/
          "s"
        ], body[
          /* explanation */
          "d"
        ]);
      } else if (action === "sd") {
        this.onSecurityDebugPacket_(body);
      } else {
        error("Unrecognized action received from server: " + stringify(action) + "\nAre you using the latest client?");
      }
    };
    PersistentConnection2.prototype.onReady_ = function(timestamp, sessionId) {
      this.log_("connection ready");
      this.connected_ = true;
      this.lastConnectionEstablishedTime_ = (/* @__PURE__ */ new Date()).getTime();
      this.handleTimestamp_(timestamp);
      this.lastSessionId = sessionId;
      if (this.firstConnection_) {
        this.sendConnectStats_();
      }
      this.restoreState_();
      this.firstConnection_ = false;
      this.onConnectStatus_(true);
    };
    PersistentConnection2.prototype.scheduleConnect_ = function(timeout) {
      var _this = this;
      assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
      if (this.establishConnectionTimer_) {
        clearTimeout(this.establishConnectionTimer_);
      }
      this.establishConnectionTimer_ = setTimeout(function() {
        _this.establishConnectionTimer_ = null;
        _this.establishConnection_();
      }, Math.floor(timeout));
    };
    PersistentConnection2.prototype.onVisible_ = function(visible) {
      if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
        this.log_("Window became visible.  Reducing delay.");
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      }
      this.visible_ = visible;
    };
    PersistentConnection2.prototype.onOnline_ = function(online) {
      if (online) {
        this.log_("Browser went online.");
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      } else {
        this.log_("Browser went offline.  Killing connection.");
        if (this.realtime_) {
          this.realtime_.close();
        }
      }
    };
    PersistentConnection2.prototype.onRealtimeDisconnect_ = function() {
      this.log_("data client disconnected");
      this.connected_ = false;
      this.realtime_ = null;
      this.cancelSentTransactions_();
      this.requestCBHash_ = {};
      if (this.shouldReconnect_()) {
        if (!this.visible_) {
          this.log_("Window isn't visible.  Delaying reconnect.");
          this.reconnectDelay_ = this.maxReconnectDelay_;
          this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
        } else if (this.lastConnectionEstablishedTime_) {
          var timeSinceLastConnectSucceeded = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionEstablishedTime_;
          if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          }
          this.lastConnectionEstablishedTime_ = null;
        }
        var timeSinceLastConnectAttempt = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionAttemptTime_;
        var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
        reconnectDelay = Math.random() * reconnectDelay;
        this.log_("Trying to reconnect in " + reconnectDelay + "ms");
        this.scheduleConnect_(reconnectDelay);
        this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
      }
      this.onConnectStatus_(false);
    };
    PersistentConnection2.prototype.establishConnection_ = function() {
      var _this = this;
      if (this.shouldReconnect_()) {
        this.log_("Making a connection attempt");
        this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
        this.lastConnectionEstablishedTime_ = null;
        var onDataMessage_1 = this.onDataMessage_.bind(this);
        var onReady_1 = this.onReady_.bind(this);
        var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
        var connId_1 = this.id + ":" + PersistentConnection2.nextConnectionId_++;
        var self_1 = this;
        var lastSessionId_1 = this.lastSessionId;
        var canceled_1 = false;
        var connection_1 = null;
        var closeFn_1 = function() {
          if (connection_1) {
            connection_1.close();
          } else {
            canceled_1 = true;
            onDisconnect_1();
          }
        };
        var sendRequestFn = function(msg) {
          assert(connection_1, "sendRequest call when we're not connected not allowed.");
          connection_1.sendRequest(msg);
        };
        this.realtime_ = {
          close: closeFn_1,
          sendRequest: sendRequestFn
        };
        var forceRefresh = this.forceTokenRefresh_;
        this.forceTokenRefresh_ = false;
        this.authTokenProvider_.getToken(forceRefresh).then(function(result) {
          if (!canceled_1) {
            log("getToken() completed. Creating connection.");
            self_1.authToken_ = result && result.accessToken;
            connection_1 = new Connection(
              connId_1,
              self_1.repoInfo_,
              self_1.applicationId_,
              onDataMessage_1,
              onReady_1,
              onDisconnect_1,
              /* onKill= */
              function(reason) {
                warn(reason + " (" + self_1.repoInfo_.toString() + ")");
                self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);
              },
              lastSessionId_1
            );
          } else {
            log("getToken() completed but was canceled");
          }
        }).then(null, function(error2) {
          self_1.log_("Failed to get token: " + error2);
          if (!canceled_1) {
            if (_this.repoInfo_.nodeAdmin) {
              warn(error2);
            }
            closeFn_1();
          }
        });
      }
    };
    PersistentConnection2.prototype.interrupt = function(reason) {
      log("Interrupting connection for reason: " + reason);
      this.interruptReasons_[reason] = true;
      if (this.realtime_) {
        this.realtime_.close();
      } else {
        if (this.establishConnectionTimer_) {
          clearTimeout(this.establishConnectionTimer_);
          this.establishConnectionTimer_ = null;
        }
        if (this.connected_) {
          this.onRealtimeDisconnect_();
        }
      }
    };
    PersistentConnection2.prototype.resume = function(reason) {
      log("Resuming connection for reason: " + reason);
      delete this.interruptReasons_[reason];
      if (isEmpty(this.interruptReasons_)) {
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      }
    };
    PersistentConnection2.prototype.handleTimestamp_ = function(timestamp) {
      var delta = timestamp - (/* @__PURE__ */ new Date()).getTime();
      this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection2.prototype.cancelSentTransactions_ = function() {
      for (var i = 0; i < this.outstandingPuts_.length; i++) {
        var put = this.outstandingPuts_[i];
        if (put && /*hash*/
        "h" in put.request && put.queued) {
          if (put.onComplete) {
            put.onComplete("disconnect");
          }
          delete this.outstandingPuts_[i];
          this.outstandingPutCount_--;
        }
      }
      if (this.outstandingPutCount_ === 0) {
        this.outstandingPuts_ = [];
      }
    };
    PersistentConnection2.prototype.onListenRevoked_ = function(pathString, query) {
      var queryId;
      if (!query) {
        queryId = "default";
      } else {
        queryId = query.map(function(q3) {
          return ObjectToUniqueKey(q3);
        }).join("$");
      }
      var listen = this.removeListen_(pathString, queryId);
      if (listen && listen.onComplete) {
        listen.onComplete("permission_denied");
      }
    };
    PersistentConnection2.prototype.removeListen_ = function(pathString, queryId) {
      var normalizedPathString = new Path(pathString).toString();
      var listen;
      if (this.listens.has(normalizedPathString)) {
        var map2 = this.listens.get(normalizedPathString);
        listen = map2.get(queryId);
        map2.delete(queryId);
        if (map2.size === 0) {
          this.listens.delete(normalizedPathString);
        }
      } else {
        listen = void 0;
      }
      return listen;
    };
    PersistentConnection2.prototype.onAuthRevoked_ = function(statusCode, explanation) {
      log("Auth token revoked: " + statusCode + "/" + explanation);
      this.authToken_ = null;
      this.forceTokenRefresh_ = true;
      this.realtime_.close();
      if (statusCode === "invalid_token" || statusCode === "permission_denied") {
        this.invalidAuthTokenCount_++;
        if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {
          this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
          this.authTokenProvider_.notifyForInvalidToken();
        }
      }
    };
    PersistentConnection2.prototype.onSecurityDebugPacket_ = function(body) {
      if (this.securityDebugCallback_) {
        this.securityDebugCallback_(body);
      } else {
        if ("msg" in body) {
          console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
        }
      }
    };
    PersistentConnection2.prototype.restoreState_ = function() {
      var e_1, _a9, e_2, _b;
      this.tryAuth();
      try {
        for (var _c2 = __values(this.listens.values()), _d = _c2.next(); !_d.done; _d = _c2.next()) {
          var queries = _d.value;
          try {
            for (var _e2 = (e_2 = void 0, __values(queries.values())), _f = _e2.next(); !_f.done; _f = _e2.next()) {
              var listenSpec = _f.value;
              this.sendListen_(listenSpec);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_f && !_f.done && (_b = _e2.return))
                _b.call(_e2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a9 = _c2.return))
            _a9.call(_c2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      for (var i = 0; i < this.outstandingPuts_.length; i++) {
        if (this.outstandingPuts_[i]) {
          this.sendPut_(i);
        }
      }
      while (this.onDisconnectRequestQueue_.length) {
        var request = this.onDisconnectRequestQueue_.shift();
        this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
      }
      for (var i = 0; i < this.outstandingGets_.length; i++) {
        if (this.outstandingGets_[i]) {
          this.sendGet_(i);
        }
      }
    };
    PersistentConnection2.prototype.sendConnectStats_ = function() {
      var stats2 = {};
      var clientName = "js";
      if (isNodeSdk()) {
        if (this.repoInfo_.nodeAdmin) {
          clientName = "admin_node";
        } else {
          clientName = "node";
        }
      }
      stats2["sdk." + clientName + "." + SDK_VERSION.replace(/\./g, "-")] = 1;
      if (isMobileCordova()) {
        stats2["framework.cordova"] = 1;
      } else if (isReactNative()) {
        stats2["framework.reactnative"] = 1;
      }
      this.reportStats(stats2);
    };
    PersistentConnection2.prototype.shouldReconnect_ = function() {
      var online = OnlineMonitor.getInstance().currentlyOnline();
      return isEmpty(this.interruptReasons_) && online;
    };
    PersistentConnection2.nextPersistentConnectionId_ = 0;
    PersistentConnection2.nextConnectionId_ = 0;
    return PersistentConnection2;
  }(ServerActions)
);
var ReadonlyRestClient = (
  /** @class */
  function(_super) {
    __extends(ReadonlyRestClient2, _super);
    function ReadonlyRestClient2(repoInfo_, onDataUpdate_, authTokenProvider_) {
      var _this = _super.call(this) || this;
      _this.repoInfo_ = repoInfo_;
      _this.onDataUpdate_ = onDataUpdate_;
      _this.authTokenProvider_ = authTokenProvider_;
      _this.log_ = logWrapper("p:rest:");
      _this.listens_ = {};
      return _this;
    }
    ReadonlyRestClient2.prototype.reportStats = function(stats2) {
      throw new Error("Method not implemented.");
    };
    ReadonlyRestClient2.getListenId_ = function(query, tag) {
      if (tag !== void 0) {
        return "tag$" + tag;
      } else {
        assert(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
        return query.path.toString();
      }
    };
    ReadonlyRestClient2.prototype.listen = function(query, currentHashFn, tag, onComplete) {
      var _this = this;
      var pathString = query.path.toString();
      this.log_("Listen called for " + pathString + " " + query.queryIdentifier());
      var listenId = ReadonlyRestClient2.getListenId_(query, tag);
      var thisListen = {};
      this.listens_[listenId] = thisListen;
      var queryStringParameters = queryParamsToRestQueryStringParameters(query.getQueryParams());
      this.restRequest_(pathString + ".json", queryStringParameters, function(error2, result) {
        var data = result;
        if (error2 === 404) {
          data = null;
          error2 = null;
        }
        if (error2 === null) {
          _this.onDataUpdate_(
            pathString,
            data,
            /*isMerge=*/
            false,
            tag
          );
        }
        if (safeGet(_this.listens_, listenId) === thisListen) {
          var status_1;
          if (!error2) {
            status_1 = "ok";
          } else if (error2 === 401) {
            status_1 = "permission_denied";
          } else {
            status_1 = "rest_error:" + error2;
          }
          onComplete(status_1, null);
        }
      });
    };
    ReadonlyRestClient2.prototype.unlisten = function(query, tag) {
      var listenId = ReadonlyRestClient2.getListenId_(query, tag);
      delete this.listens_[listenId];
    };
    ReadonlyRestClient2.prototype.get = function(query) {
      var _this = this;
      var queryStringParameters = queryParamsToRestQueryStringParameters(query.getQueryParams());
      var pathString = query.path.toString();
      var deferred = new Deferred();
      this.restRequest_(pathString + ".json", queryStringParameters, function(error2, result) {
        var data = result;
        if (error2 === 404) {
          data = null;
          error2 = null;
        }
        if (error2 === null) {
          _this.onDataUpdate_(
            pathString,
            data,
            /*isMerge=*/
            false,
            /*tag=*/
            null
          );
          deferred.resolve(data);
        } else {
          deferred.reject(new Error(data));
        }
      });
      return deferred.promise;
    };
    ReadonlyRestClient2.prototype.refreshAuthToken = function(token) {
    };
    ReadonlyRestClient2.prototype.restRequest_ = function(pathString, queryStringParameters, callback) {
      var _this = this;
      if (queryStringParameters === void 0) {
        queryStringParameters = {};
      }
      queryStringParameters["format"] = "export";
      this.authTokenProvider_.getToken(
        /*forceRefresh=*/
        false
      ).then(function(authTokenData) {
        var authToken = authTokenData && authTokenData.accessToken;
        if (authToken) {
          queryStringParameters["auth"] = authToken;
        }
        var url = (_this.repoInfo_.secure ? "https://" : "http://") + _this.repoInfo_.host + pathString + "?ns=" + _this.repoInfo_.namespace + querystring(queryStringParameters);
        _this.log_("Sending REST request for " + url);
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (callback && xhr.readyState === 4) {
            _this.log_("REST Response for " + url + " received. status:", xhr.status, "response:", xhr.responseText);
            var res = null;
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                res = jsonEval(xhr.responseText);
              } catch (e) {
                warn("Failed to parse JSON response for " + url + ": " + xhr.responseText);
              }
              callback(null, res);
            } else {
              if (xhr.status !== 401 && xhr.status !== 404) {
                warn("Got unsuccessful REST response for " + url + " Status: " + xhr.status);
              }
              callback(xhr.status);
            }
            callback = null;
          }
        };
        xhr.open(
          "GET",
          url,
          /*asynchronous=*/
          true
        );
        xhr.send();
      });
    };
    return ReadonlyRestClient2;
  }(ServerActions)
);
var DataSnapshot = (
  /** @class */
  function() {
    function DataSnapshot2(node_, ref_, index_) {
      this.node_ = node_;
      this.ref_ = ref_;
      this.index_ = index_;
    }
    DataSnapshot2.prototype.val = function() {
      validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
      return this.node_.val();
    };
    DataSnapshot2.prototype.exportVal = function() {
      validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
      return this.node_.val(true);
    };
    DataSnapshot2.prototype.toJSON = function() {
      validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
      return this.exportVal();
    };
    DataSnapshot2.prototype.exists = function() {
      validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
      return !this.node_.isEmpty();
    };
    DataSnapshot2.prototype.child = function(childPathString) {
      validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
      childPathString = String(childPathString);
      validatePathString("DataSnapshot.child", 1, childPathString, false);
      var childPath = new Path(childPathString);
      var childRef = this.ref_.child(childPath);
      return new DataSnapshot2(this.node_.getChild(childPath), childRef, PRIORITY_INDEX);
    };
    DataSnapshot2.prototype.hasChild = function(childPathString) {
      validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
      validatePathString("DataSnapshot.hasChild", 1, childPathString, false);
      var childPath = new Path(childPathString);
      return !this.node_.getChild(childPath).isEmpty();
    };
    DataSnapshot2.prototype.getPriority = function() {
      validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
      return this.node_.getPriority().val();
    };
    DataSnapshot2.prototype.forEach = function(action) {
      var _this = this;
      validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
      validateCallback("DataSnapshot.forEach", 1, action, false);
      if (this.node_.isLeafNode()) {
        return false;
      }
      var childrenNode = this.node_;
      return !!childrenNode.forEachChild(this.index_, function(key, node) {
        return action(new DataSnapshot2(node, _this.ref_.child(key), PRIORITY_INDEX));
      });
    };
    DataSnapshot2.prototype.hasChildren = function() {
      validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
      if (this.node_.isLeafNode()) {
        return false;
      } else {
        return !this.node_.isEmpty();
      }
    };
    Object.defineProperty(DataSnapshot2.prototype, "key", {
      get: function() {
        return this.ref_.getKey();
      },
      enumerable: false,
      configurable: true
    });
    DataSnapshot2.prototype.numChildren = function() {
      validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
      return this.node_.numChildren();
    };
    DataSnapshot2.prototype.getRef = function() {
      validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
      return this.ref_;
    };
    Object.defineProperty(DataSnapshot2.prototype, "ref", {
      get: function() {
        return this.getRef();
      },
      enumerable: false,
      configurable: true
    });
    return DataSnapshot2;
  }()
);
var Tree = (
  /** @class */
  /* @__PURE__ */ function() {
    function Tree2(name10, parent2, node) {
      if (name10 === void 0) {
        name10 = "";
      }
      if (parent2 === void 0) {
        parent2 = null;
      }
      if (node === void 0) {
        node = { children: {}, childCount: 0 };
      }
      this.name = name10;
      this.parent = parent2;
      this.node = node;
    }
    return Tree2;
  }()
);
function treeSubTree(tree, pathObj) {
  var path = pathObj instanceof Path ? pathObj : new Path(pathObj);
  var child2 = tree, next = pathGetFront(path);
  while (next !== null) {
    var childNode = safeGet(child2.node.children, next) || {
      children: {},
      childCount: 0
    };
    child2 = new Tree(next, child2, childNode);
    path = pathPopFront(path);
    next = pathGetFront(path);
  }
  return child2;
}
function treeGetValue(tree) {
  return tree.node.value;
}
function treeSetValue(tree, value) {
  tree.node.value = value;
  treeUpdateParents(tree);
}
function treeHasChildren(tree) {
  return tree.node.childCount > 0;
}
function treeIsEmpty(tree) {
  return treeGetValue(tree) === void 0 && !treeHasChildren(tree);
}
function treeForEachChild(tree, action) {
  each(tree.node.children, function(child2, childTree) {
    action(new Tree(child2, tree, childTree));
  });
}
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
  if (includeSelf && !childrenFirst) {
    action(tree);
  }
  treeForEachChild(tree, function(child2) {
    treeForEachDescendant(child2, action, true, childrenFirst);
  });
  if (includeSelf && childrenFirst) {
    action(tree);
  }
}
function treeForEachAncestor(tree, action, includeSelf) {
  var node = includeSelf ? tree : tree.parent;
  while (node !== null) {
    if (action(node)) {
      return true;
    }
    node = node.parent;
  }
  return false;
}
function treeGetPath(tree) {
  return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
}
function treeUpdateParents(tree) {
  if (tree.parent !== null) {
    treeUpdateChild(tree.parent, tree.name, tree);
  }
}
function treeUpdateChild(tree, childName, child2) {
  var childEmpty = treeIsEmpty(child2);
  var childExists = contains(tree.node.children, childName);
  if (childEmpty && childExists) {
    delete tree.node.children[childName];
    tree.node.childCount--;
    treeUpdateParents(tree);
  } else if (!childEmpty && !childExists) {
    tree.node.children[childName] = child2.node;
    tree.node.childCount++;
    treeUpdateParents(tree);
  }
}
var INTERRUPT_REASON = "repo_interrupt";
var MAX_TRANSACTION_RETRIES = 25;
var Repo = (
  /** @class */
  function() {
    function Repo2(repoInfo_, forceRestClient_, app, authTokenProvider_) {
      this.repoInfo_ = repoInfo_;
      this.forceRestClient_ = forceRestClient_;
      this.app = app;
      this.authTokenProvider_ = authTokenProvider_;
      this.dataUpdateCount = 0;
      this.statsListener_ = null;
      this.eventQueue_ = new EventQueue();
      this.nextWriteId_ = 1;
      this.interceptServerDataCallback_ = null;
      this.onDisconnect_ = newSparseSnapshotTree();
      this.transactionQueueTree_ = new Tree();
      this.persistentConnection_ = null;
      this.key = this.repoInfo_.toURLString();
    }
    Repo2.prototype.toString = function() {
      return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
    };
    return Repo2;
  }()
);
function repoStart(repo) {
  repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
  if (repo.forceRestClient_ || beingCrawled()) {
    repo.server_ = new ReadonlyRestClient(repo.repoInfo_, function(pathString, data, isMerge, tag) {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, repo.authTokenProvider_);
    setTimeout(function() {
      return repoOnConnectStatus(
        repo,
        /* connectStatus= */
        true
      );
    }, 0);
  } else {
    var authOverride = repo.app.options["databaseAuthVariableOverride"];
    if (typeof authOverride !== "undefined" && authOverride !== null) {
      if (typeof authOverride !== "object") {
        throw new Error("Only objects are supported for option databaseAuthVariableOverride");
      }
      try {
        stringify(authOverride);
      } catch (e) {
        throw new Error("Invalid authOverride provided: " + e);
      }
    }
    repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, repo.app.options.appId, function(pathString, data, isMerge, tag) {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, function(connectStatus) {
      repoOnConnectStatus(repo, connectStatus);
    }, function(updates) {
      repoOnServerInfoUpdate(repo, updates);
    }, repo.authTokenProvider_, authOverride);
    repo.server_ = repo.persistentConnection_;
  }
  repo.authTokenProvider_.addTokenChangeListener(function(token) {
    repo.server_.refreshAuthToken(token);
  });
  repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, function() {
    return new StatsReporter(repo.stats_, repo.server_);
  });
  repo.infoData_ = new SnapshotHolder();
  repo.infoSyncTree_ = new SyncTree({
    startListening: function(query, tag, currentHashFn, onComplete) {
      var infoEvents = [];
      var node = repo.infoData_.getNode(query.path);
      if (!node.isEmpty()) {
        infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query.path, node);
        setTimeout(function() {
          onComplete("ok");
        }, 0);
      }
      return infoEvents;
    },
    stopListening: function() {
    }
  });
  repoUpdateInfo(repo, "connected", false);
  repo.serverSyncTree_ = new SyncTree({
    startListening: function(query, tag, currentHashFn, onComplete) {
      repo.server_.listen(query, currentHashFn, tag, function(status, data) {
        var events = onComplete(status, data);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query.path, events);
      });
      return [];
    },
    stopListening: function(query, tag) {
      repo.server_.unlisten(query, tag);
    }
  });
}
function repoServerTime(repo) {
  var offsetNode = repo.infoData_.getNode(new Path(".info/serverTimeOffset"));
  var offset = offsetNode.val() || 0;
  return (/* @__PURE__ */ new Date()).getTime() + offset;
}
function repoGenerateServerValues(repo) {
  return generateWithValues({
    timestamp: repoServerTime(repo)
  });
}
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
  repo.dataUpdateCount++;
  var path = new Path(pathString);
  data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
  var events = [];
  if (tag) {
    if (isMerge) {
      var taggedChildren = map(data, function(raw) {
        return nodeFromJSON$1(raw);
      });
      events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
    } else {
      var taggedSnap = nodeFromJSON$1(data);
      events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
    }
  } else if (isMerge) {
    var changedChildren = map(data, function(raw) {
      return nodeFromJSON$1(raw);
    });
    events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
  } else {
    var snap = nodeFromJSON$1(data);
    events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
  }
  var affectedPath = path;
  if (events.length > 0) {
    affectedPath = repoRerunTransactions(repo, path);
  }
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoInterceptServerData(repo, callback) {
  repo.interceptServerDataCallback_ = callback;
}
function repoOnConnectStatus(repo, connectStatus) {
  repoUpdateInfo(repo, "connected", connectStatus);
  if (connectStatus === false) {
    repoRunOnDisconnectEvents(repo);
  }
}
function repoOnServerInfoUpdate(repo, updates) {
  each(updates, function(key, value) {
    repoUpdateInfo(repo, key, value);
  });
}
function repoUpdateInfo(repo, pathString, value) {
  var path = new Path("/.info/" + pathString);
  var newNode = nodeFromJSON$1(value);
  repo.infoData_.updateSnapshot(path, newNode);
  var events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) {
  return repo.nextWriteId_++;
}
function repoGetValue(repo, query) {
  var cached = syncTreeGetServerValue(repo.serverSyncTree_, query);
  if (cached != null) {
    return Promise.resolve(new DataSnapshot(cached, query.getRef(), query.getQueryParams().getIndex()));
  }
  return repo.server_.get(query).then(function(payload) {
    var node = nodeFromJSON$1(payload);
    var events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query.path, node);
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query.path, events);
    return Promise.resolve(new DataSnapshot(node, query.getRef(), query.getQueryParams().getIndex()));
  }, function(err) {
    repoLog(repo, "get for query " + stringify(query) + " failed: " + err);
    return Promise.reject(new Error(err));
  });
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
  repoLog(repo, "set", {
    path: path.toString(),
    value: newVal,
    priority: newPriority
  });
  var serverValues = repoGenerateServerValues(repo);
  var newNodeUnresolved = nodeFromJSON$1(newVal, newPriority);
  var existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
  var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
  var writeId = repoGetNextWriteId(repo);
  var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
  eventQueueQueueEvents(repo.eventQueue_, events);
  repo.server_.put(path.toString(), newNodeUnresolved.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    var success = status === "ok";
    if (!success) {
      warn("set at " + path + " failed: " + status);
    }
    var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
  var affectedPath = repoAbortTransactions(repo, path);
  repoRerunTransactions(repo, affectedPath);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
function repoUpdate(repo, path, childrenToMerge, onComplete) {
  repoLog(repo, "update", { path: path.toString(), value: childrenToMerge });
  var empty = true;
  var serverValues = repoGenerateServerValues(repo);
  var changedChildren = {};
  each(childrenToMerge, function(changedKey, changedValue) {
    empty = false;
    changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON$1(changedValue), repo.serverSyncTree_, serverValues);
  });
  if (!empty) {
    var writeId_1 = repoGetNextWriteId(repo);
    var events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId_1);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.merge(path.toString(), childrenToMerge, function(status, errorReason) {
      var success = status === "ok";
      if (!success) {
        warn("update at " + path + " failed: " + status);
      }
      var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId_1, !success);
      var affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
      repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
    each(childrenToMerge, function(changedPath) {
      var affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
      repoRerunTransactions(repo, affectedPath);
    });
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
  } else {
    log("update() called with empty data.  Don't do anything.");
    repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
  }
}
function repoRunOnDisconnectEvents(repo) {
  repoLog(repo, "onDisconnectEvents");
  var serverValues = repoGenerateServerValues(repo);
  var resolvedOnDisconnectTree = newSparseSnapshotTree();
  sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), function(path, node) {
    var resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
    sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
  });
  var events = [];
  sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), function(path, snap) {
    events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
    var affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
  });
  repo.onDisconnect_ = newSparseSnapshotTree();
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoOnDisconnectCancel(repo, path, onComplete) {
  repo.server_.onDisconnectCancel(path.toString(), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeForget(repo.onDisconnect_, path);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectSet(repo, path, value, onComplete) {
  var newNode = nodeFromJSON$1(value);
  repo.server_.onDisconnectPut(path.toString(), newNode.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {
  var newNode = nodeFromJSON$1(value, priority);
  repo.server_.onDisconnectPut(path.toString(), newNode.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
  if (isEmpty(childrenToMerge)) {
    log("onDisconnect().update() called with empty data.  Don't do anything.");
    repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
    return;
  }
  repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, function(status, errorReason) {
    if (status === "ok") {
      each(childrenToMerge, function(childName, childNode) {
        var newChildNode = nodeFromJSON$1(childNode);
        sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
      });
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoAddEventCallbackForQuery(repo, query, eventRegistration) {
  var events;
  if (pathGetFront(query.path) === ".info") {
    events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);
  } else {
    events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);
  }
  eventQueueRaiseEventsAtPath(repo.eventQueue_, query.path, events);
}
function repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {
  var events;
  if (pathGetFront(query.path) === ".info") {
    events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);
  } else {
    events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);
  }
  eventQueueRaiseEventsAtPath(repo.eventQueue_, query.path, events);
}
function repoInterrupt(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.interrupt(INTERRUPT_REASON);
  }
}
function repoResume(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.resume(INTERRUPT_REASON);
  }
}
function repoStats(repo, showDelta) {
  if (showDelta === void 0) {
    showDelta = false;
  }
  if (typeof console === "undefined") {
    return;
  }
  var stats2;
  if (showDelta) {
    if (!repo.statsListener_) {
      repo.statsListener_ = new StatsListener(repo.stats_);
    }
    stats2 = repo.statsListener_.get();
  } else {
    stats2 = repo.stats_.get();
  }
  var longestName = Object.keys(stats2).reduce(function(previousValue, currentValue) {
    return Math.max(currentValue.length, previousValue);
  }, 0);
  each(stats2, function(stat, value) {
    var paddedStat = stat;
    for (var i = stat.length; i < longestName + 2; i++) {
      paddedStat += " ";
    }
    console.log(paddedStat + value);
  });
}
function repoStatsIncrementCounter(repo, metric) {
  repo.stats_.incrementCounter(metric);
  statsReporterIncludeStat(repo.statsReporter_, metric);
}
function repoLog(repo) {
  var varArgs = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    varArgs[_i2 - 1] = arguments[_i2];
  }
  var prefix = "";
  if (repo.persistentConnection_) {
    prefix = repo.persistentConnection_.id + ":";
  }
  log.apply(void 0, __spreadArray([prefix], __read(varArgs)));
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
  if (callback) {
    exceptionGuard(function() {
      if (status === "ok") {
        callback(null);
      } else {
        var code = (status || "error").toUpperCase();
        var message = code;
        if (errorReason) {
          message += ": " + errorReason;
        }
        var error2 = new Error(message);
        error2.code = code;
        callback(error2);
      }
    });
  }
}
function repoGetDatabase(repo) {
  return repo.__database || (repo.__database = new Database(repo));
}
function repoStartTransaction(repo, path, transactionUpdate, onComplete, applyLocally) {
  repoLog(repo, "transaction on " + path);
  var valueCallback = function() {
  };
  var watchRef = new Reference(repo, path);
  watchRef.on("value", valueCallback);
  var unwatcher = function() {
    watchRef.off("value", valueCallback);
  };
  var transaction = {
    path,
    update: transactionUpdate,
    onComplete,
    // One of TransactionStatus enums.
    status: null,
    // Used when combining transactions at different locations to figure out
    // which one goes first.
    order: LUIDGenerator(),
    // Whether to raise local events for this transaction.
    applyLocally,
    // Count of how many times we've retried the transaction.
    retryCount: 0,
    // Function to call to clean up our .on() listener.
    unwatcher,
    // Stores why a transaction was aborted.
    abortReason: null,
    currentWriteId: null,
    currentInputSnapshot: null,
    currentOutputSnapshotRaw: null,
    currentOutputSnapshotResolved: null
  };
  var currentState = repoGetLatestState(repo, path, void 0);
  transaction.currentInputSnapshot = currentState;
  var newVal = transaction.update(currentState.val());
  if (newVal === void 0) {
    transaction.unwatcher();
    transaction.currentOutputSnapshotRaw = null;
    transaction.currentOutputSnapshotResolved = null;
    if (transaction.onComplete) {
      var snapshot = new DataSnapshot(transaction.currentInputSnapshot, new Reference(repo, transaction.path), PRIORITY_INDEX);
      transaction.onComplete(null, false, snapshot);
    }
  } else {
    validateFirebaseData("transaction failed: Data returned ", newVal, transaction.path);
    transaction.status = 0;
    var queueNode = treeSubTree(repo.transactionQueueTree_, path);
    var nodeQueue = treeGetValue(queueNode) || [];
    nodeQueue.push(transaction);
    treeSetValue(queueNode, nodeQueue);
    var priorityForNode = void 0;
    if (typeof newVal === "object" && newVal !== null && contains(newVal, ".priority")) {
      priorityForNode = safeGet(newVal, ".priority");
      assert(isValidPriority(priorityForNode), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.");
    } else {
      var currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;
      priorityForNode = currentNode.getPriority().val();
    }
    var serverValues = repoGenerateServerValues(repo);
    var newNodeUnresolved = nodeFromJSON$1(newVal, priorityForNode);
    var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
    transaction.currentOutputSnapshotRaw = newNodeUnresolved;
    transaction.currentOutputSnapshotResolved = newNode;
    transaction.currentWriteId = repoGetNextWriteId(repo);
    var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
  }
}
function repoGetLatestState(repo, path, excludeSets) {
  return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;
}
function repoSendReadyTransactions(repo, node) {
  if (node === void 0) {
    node = repo.transactionQueueTree_;
  }
  if (!node) {
    repoPruneCompletedTransactionsBelowNode(repo, node);
  }
  if (treeGetValue(node)) {
    var queue2 = repoBuildTransactionQueue(repo, node);
    assert(queue2.length > 0, "Sending zero length transaction queue");
    var allRun = queue2.every(function(transaction) {
      return transaction.status === 0;
    });
    if (allRun) {
      repoSendTransactionQueue(repo, treeGetPath(node), queue2);
    }
  } else if (treeHasChildren(node)) {
    treeForEachChild(node, function(childNode) {
      repoSendReadyTransactions(repo, childNode);
    });
  }
}
function repoSendTransactionQueue(repo, path, queue2) {
  var setsToIgnore = queue2.map(function(txn2) {
    return txn2.currentWriteId;
  });
  var latestState = repoGetLatestState(repo, path, setsToIgnore);
  var snapToSend = latestState;
  var latestHash = latestState.hash();
  for (var i = 0; i < queue2.length; i++) {
    var txn = queue2[i];
    assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
    txn.status = 1;
    txn.retryCount++;
    var relativePath = newRelativePath(path, txn.path);
    snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
  }
  var dataToSend = snapToSend.val(true);
  var pathToSend = path;
  repo.server_.put(pathToSend.toString(), dataToSend, function(status) {
    repoLog(repo, "transaction put response", {
      path: pathToSend.toString(),
      status
    });
    var events = [];
    if (status === "ok") {
      var callbacks = [];
      for (var i2 = 0; i2 < queue2.length; i2++) {
        queue2[i2].status = 2;
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue2[i2].currentWriteId));
        if (queue2[i2].onComplete) {
          var node = queue2[i2].currentOutputSnapshotResolved;
          var ref2 = new Reference(repo, queue2[i2].path);
          var snapshot = new DataSnapshot(node, ref2, PRIORITY_INDEX);
          callbacks.push(queue2[i2].onComplete.bind(null, null, true, snapshot));
        }
        queue2[i2].unwatcher();
      }
      repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
      for (var i2 = 0; i2 < callbacks.length; i2++) {
        exceptionGuard(callbacks[i2]);
      }
    } else {
      if (status === "datastale") {
        for (var i2 = 0; i2 < queue2.length; i2++) {
          if (queue2[i2].status === 3) {
            queue2[i2].status = 4;
          } else {
            queue2[i2].status = 0;
          }
        }
      } else {
        warn("transaction at " + pathToSend.toString() + " failed: " + status);
        for (var i2 = 0; i2 < queue2.length; i2++) {
          queue2[i2].status = 4;
          queue2[i2].abortReason = status;
        }
      }
      repoRerunTransactions(repo, path);
    }
  }, latestHash);
}
function repoRerunTransactions(repo, changedPath) {
  var rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
  var path = treeGetPath(rootMostTransactionNode);
  var queue2 = repoBuildTransactionQueue(repo, rootMostTransactionNode);
  repoRerunTransactionQueue(repo, queue2, path);
  return path;
}
function repoRerunTransactionQueue(repo, queue2, path) {
  if (queue2.length === 0) {
    return;
  }
  var callbacks = [];
  var events = [];
  var txnsToRerun = queue2.filter(function(q3) {
    return q3.status === 0;
  });
  var setsToIgnore = txnsToRerun.map(function(q3) {
    return q3.currentWriteId;
  });
  for (var i = 0; i < queue2.length; i++) {
    var transaction = queue2[i];
    var relativePath = newRelativePath(path, transaction.path);
    var abortTransaction = false, abortReason = void 0;
    assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
    if (transaction.status === 4) {
      abortTransaction = true;
      abortReason = transaction.abortReason;
      events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
    } else if (transaction.status === 0) {
      if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
        abortTransaction = true;
        abortReason = "maxretry";
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
      } else {
        var currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
        transaction.currentInputSnapshot = currentNode;
        var newData = queue2[i].update(currentNode.val());
        if (newData !== void 0) {
          validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
          var newDataNode = nodeFromJSON$1(newData);
          var hasExplicitPriority = typeof newData === "object" && newData != null && contains(newData, ".priority");
          if (!hasExplicitPriority) {
            newDataNode = newDataNode.updatePriority(currentNode.getPriority());
          }
          var oldWriteId = transaction.currentWriteId;
          var serverValues = repoGenerateServerValues(repo);
          var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
          transaction.currentOutputSnapshotRaw = newDataNode;
          transaction.currentOutputSnapshotResolved = newNodeResolved;
          transaction.currentWriteId = repoGetNextWriteId(repo);
          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
          events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
        } else {
          abortTransaction = true;
          abortReason = "nodata";
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
      }
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    events = [];
    if (abortTransaction) {
      queue2[i].status = 2;
      (function(unwatcher) {
        setTimeout(unwatcher, Math.floor(0));
      })(queue2[i].unwatcher);
      if (queue2[i].onComplete) {
        if (abortReason === "nodata") {
          var ref2 = new Reference(repo, queue2[i].path);
          var lastInput = queue2[i].currentInputSnapshot;
          var snapshot = new DataSnapshot(lastInput, ref2, PRIORITY_INDEX);
          callbacks.push(queue2[i].onComplete.bind(null, null, false, snapshot));
        } else {
          callbacks.push(queue2[i].onComplete.bind(null, new Error(abortReason), false, null));
        }
      }
    }
  }
  repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
  for (var i = 0; i < callbacks.length; i++) {
    exceptionGuard(callbacks[i]);
  }
  repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
function repoGetAncestorTransactionNode(repo, path) {
  var front;
  var transactionNode = repo.transactionQueueTree_;
  front = pathGetFront(path);
  while (front !== null && treeGetValue(transactionNode) === void 0) {
    transactionNode = treeSubTree(transactionNode, front);
    path = pathPopFront(path);
    front = pathGetFront(path);
  }
  return transactionNode;
}
function repoBuildTransactionQueue(repo, transactionNode) {
  var transactionQueue = [];
  repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
  transactionQueue.sort(function(a, b) {
    return a.order - b.order;
  });
  return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue2) {
  var nodeQueue = treeGetValue(node);
  if (nodeQueue) {
    for (var i = 0; i < nodeQueue.length; i++) {
      queue2.push(nodeQueue[i]);
    }
  }
  treeForEachChild(node, function(child2) {
    repoAggregateTransactionQueuesForNode(repo, child2, queue2);
  });
}
function repoPruneCompletedTransactionsBelowNode(repo, node) {
  var queue2 = treeGetValue(node);
  if (queue2) {
    var to2 = 0;
    for (var from = 0; from < queue2.length; from++) {
      if (queue2[from].status !== 2) {
        queue2[to2] = queue2[from];
        to2++;
      }
    }
    queue2.length = to2;
    treeSetValue(node, queue2.length > 0 ? queue2 : void 0);
  }
  treeForEachChild(node, function(childNode) {
    repoPruneCompletedTransactionsBelowNode(repo, childNode);
  });
}
function repoAbortTransactions(repo, path) {
  var affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
  var transactionNode = treeSubTree(repo.transactionQueueTree_, path);
  treeForEachAncestor(transactionNode, function(node) {
    repoAbortTransactionsOnNode(repo, node);
  });
  repoAbortTransactionsOnNode(repo, transactionNode);
  treeForEachDescendant(transactionNode, function(node) {
    repoAbortTransactionsOnNode(repo, node);
  });
  return affectedPath;
}
function repoAbortTransactionsOnNode(repo, node) {
  var queue2 = treeGetValue(node);
  if (queue2) {
    var callbacks = [];
    var events = [];
    var lastSent = -1;
    for (var i = 0; i < queue2.length; i++) {
      if (queue2[i].status === 3)
        ;
      else if (queue2[i].status === 1) {
        assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
        lastSent = i;
        queue2[i].status = 3;
        queue2[i].abortReason = "set";
      } else {
        assert(queue2[i].status === 0, "Unexpected transaction status in abort");
        queue2[i].unwatcher();
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue2[i].currentWriteId, true));
        if (queue2[i].onComplete) {
          var snapshot = null;
          callbacks.push(queue2[i].onComplete.bind(null, new Error("set"), false, snapshot));
        }
      }
    }
    if (lastSent === -1) {
      treeSetValue(node, void 0);
    } else {
      queue2.length = lastSent + 1;
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
    for (var i = 0; i < callbacks.length; i++) {
      exceptionGuard(callbacks[i]);
    }
  }
}
var OnDisconnect = (
  /** @class */
  function() {
    function OnDisconnect2(repo_, path_) {
      this.repo_ = repo_;
      this.path_ = path_;
    }
    OnDisconnect2.prototype.cancel = function(onComplete) {
      validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
      validateCallback("OnDisconnect.cancel", 1, onComplete, true);
      var deferred = new Deferred();
      repoOnDisconnectCancel(this.repo_, this.path_, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    OnDisconnect2.prototype.remove = function(onComplete) {
      validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
      validateWritablePath("OnDisconnect.remove", this.path_);
      validateCallback("OnDisconnect.remove", 1, onComplete, true);
      var deferred = new Deferred();
      repoOnDisconnectSet(this.repo_, this.path_, null, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    OnDisconnect2.prototype.set = function(value, onComplete) {
      validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
      validateWritablePath("OnDisconnect.set", this.path_);
      validateFirebaseDataArg("OnDisconnect.set", 1, value, this.path_, false);
      validateCallback("OnDisconnect.set", 2, onComplete, true);
      var deferred = new Deferred();
      repoOnDisconnectSet(this.repo_, this.path_, value, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    OnDisconnect2.prototype.setWithPriority = function(value, priority, onComplete) {
      validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
      validateWritablePath("OnDisconnect.setWithPriority", this.path_);
      validateFirebaseDataArg("OnDisconnect.setWithPriority", 1, value, this.path_, false);
      validatePriority("OnDisconnect.setWithPriority", 2, priority, false);
      validateCallback("OnDisconnect.setWithPriority", 3, onComplete, true);
      var deferred = new Deferred();
      repoOnDisconnectSetWithPriority(this.repo_, this.path_, value, priority, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    OnDisconnect2.prototype.update = function(objectToMerge, onComplete) {
      validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
      validateWritablePath("OnDisconnect.update", this.path_);
      if (Array.isArray(objectToMerge)) {
        var newObjectToMerge = {};
        for (var i = 0; i < objectToMerge.length; ++i) {
          newObjectToMerge["" + i] = objectToMerge[i];
        }
        objectToMerge = newObjectToMerge;
        warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
      }
      validateFirebaseMergeDataArg("OnDisconnect.update", 1, objectToMerge, this.path_, false);
      validateCallback("OnDisconnect.update", 2, onComplete, true);
      var deferred = new Deferred();
      repoOnDisconnectUpdate(this.repo_, this.path_, objectToMerge, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    return OnDisconnect2;
  }()
);
var TransactionResult = (
  /** @class */
  function() {
    function TransactionResult2(committed, snapshot) {
      this.committed = committed;
      this.snapshot = snapshot;
    }
    TransactionResult2.prototype.toJSON = function() {
      validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
      return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult2;
  }()
);
var DataEvent = (
  /** @class */
  function() {
    function DataEvent2(eventType, eventRegistration, snapshot, prevName) {
      this.eventType = eventType;
      this.eventRegistration = eventRegistration;
      this.snapshot = snapshot;
      this.prevName = prevName;
    }
    DataEvent2.prototype.getPath = function() {
      var ref2 = this.snapshot.getRef();
      if (this.eventType === "value") {
        return ref2.path;
      } else {
        return ref2.getParent().path;
      }
    };
    DataEvent2.prototype.getEventType = function() {
      return this.eventType;
    };
    DataEvent2.prototype.getEventRunner = function() {
      return this.eventRegistration.getEventRunner(this);
    };
    DataEvent2.prototype.toString = function() {
      return this.getPath().toString() + ":" + this.eventType + ":" + stringify(this.snapshot.exportVal());
    };
    return DataEvent2;
  }()
);
var CancelEvent = (
  /** @class */
  function() {
    function CancelEvent2(eventRegistration, error2, path) {
      this.eventRegistration = eventRegistration;
      this.error = error2;
      this.path = path;
    }
    CancelEvent2.prototype.getPath = function() {
      return this.path;
    };
    CancelEvent2.prototype.getEventType = function() {
      return "cancel";
    };
    CancelEvent2.prototype.getEventRunner = function() {
      return this.eventRegistration.getEventRunner(this);
    };
    CancelEvent2.prototype.toString = function() {
      return this.path.toString() + ":cancel";
    };
    return CancelEvent2;
  }()
);
var ValueEventRegistration = (
  /** @class */
  function() {
    function ValueEventRegistration2(callback_, cancelCallback_, context_) {
      this.callback_ = callback_;
      this.cancelCallback_ = cancelCallback_;
      this.context_ = context_;
    }
    ValueEventRegistration2.prototype.respondsTo = function(eventType) {
      return eventType === "value";
    };
    ValueEventRegistration2.prototype.createEvent = function(change, query) {
      var index = query.getQueryParams().getIndex();
      return new DataEvent("value", this, new DataSnapshot(change.snapshotNode, query.getRef(), index));
    };
    ValueEventRegistration2.prototype.getEventRunner = function(eventData) {
      var ctx = this.context_;
      if (eventData.getEventType() === "cancel") {
        assert(this.cancelCallback_, "Raising a cancel event on a listener with no cancel callback");
        var cancelCB_1 = this.cancelCallback_;
        return function() {
          cancelCB_1.call(ctx, eventData.error);
        };
      } else {
        var cb_1 = this.callback_;
        return function() {
          cb_1.call(ctx, eventData.snapshot);
        };
      }
    };
    ValueEventRegistration2.prototype.createCancelEvent = function(error2, path) {
      if (this.cancelCallback_) {
        return new CancelEvent(this, error2, path);
      } else {
        return null;
      }
    };
    ValueEventRegistration2.prototype.matches = function(other) {
      if (!(other instanceof ValueEventRegistration2)) {
        return false;
      } else if (!other.callback_ || !this.callback_) {
        return true;
      } else {
        return other.callback_ === this.callback_ && other.context_ === this.context_;
      }
    };
    ValueEventRegistration2.prototype.hasAnyCallback = function() {
      return this.callback_ !== null;
    };
    return ValueEventRegistration2;
  }()
);
var ChildEventRegistration = (
  /** @class */
  function() {
    function ChildEventRegistration2(callbacks_, cancelCallback_, context_) {
      this.callbacks_ = callbacks_;
      this.cancelCallback_ = cancelCallback_;
      this.context_ = context_;
    }
    ChildEventRegistration2.prototype.respondsTo = function(eventType) {
      var eventToCheck = eventType === "children_added" ? "child_added" : eventType;
      eventToCheck = eventToCheck === "children_removed" ? "child_removed" : eventToCheck;
      return contains(this.callbacks_, eventToCheck);
    };
    ChildEventRegistration2.prototype.createCancelEvent = function(error2, path) {
      if (this.cancelCallback_) {
        return new CancelEvent(this, error2, path);
      } else {
        return null;
      }
    };
    ChildEventRegistration2.prototype.createEvent = function(change, query) {
      assert(change.childName != null, "Child events should have a childName.");
      var ref2 = query.getRef().child(change.childName);
      var index = query.getQueryParams().getIndex();
      return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, ref2, index), change.prevName);
    };
    ChildEventRegistration2.prototype.getEventRunner = function(eventData) {
      var ctx = this.context_;
      if (eventData.getEventType() === "cancel") {
        assert(this.cancelCallback_, "Raising a cancel event on a listener with no cancel callback");
        var cancelCB_2 = this.cancelCallback_;
        return function() {
          cancelCB_2.call(ctx, eventData.error);
        };
      } else {
        var cb_2 = this.callbacks_[eventData.eventType];
        return function() {
          cb_2.call(ctx, eventData.snapshot, eventData.prevName);
        };
      }
    };
    ChildEventRegistration2.prototype.matches = function(other) {
      var _this = this;
      if (other instanceof ChildEventRegistration2) {
        if (!this.callbacks_ || !other.callbacks_) {
          return true;
        } else if (this.context_ === other.context_) {
          var otherKeys = Object.keys(other.callbacks_);
          var thisKeys = Object.keys(this.callbacks_);
          var otherCount = otherKeys.length;
          var thisCount = thisKeys.length;
          if (otherCount === thisCount) {
            if (otherCount === 1) {
              var otherKey = otherKeys[0];
              var thisKey = thisKeys[0];
              return thisKey === otherKey && (!other.callbacks_[otherKey] || !this.callbacks_[thisKey] || other.callbacks_[otherKey] === this.callbacks_[thisKey]);
            } else {
              return thisKeys.every(function(eventType) {
                return other.callbacks_[eventType] === _this.callbacks_[eventType];
              });
            }
          }
        }
      }
      return false;
    };
    ChildEventRegistration2.prototype.hasAnyCallback = function() {
      return this.callbacks_ !== null;
    };
    return ChildEventRegistration2;
  }()
);
var __referenceConstructor;
var Query = (
  /** @class */
  function() {
    function Query2(repo, path, queryParams_, orderByCalled_) {
      this.repo = repo;
      this.path = path;
      this.queryParams_ = queryParams_;
      this.orderByCalled_ = orderByCalled_;
    }
    Object.defineProperty(Query2, "__referenceConstructor", {
      get: function() {
        assert(__referenceConstructor, "Reference.ts has not been loaded");
        return __referenceConstructor;
      },
      set: function(val) {
        __referenceConstructor = val;
      },
      enumerable: false,
      configurable: true
    });
    Query2.validateQueryEndpoints_ = function(params) {
      var startNode = null;
      var endNode = null;
      if (params.hasStart()) {
        startNode = params.getIndexStartValue();
      }
      if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
      }
      if (params.getIndex() === KEY_INDEX) {
        var tooManyArgsError = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().";
        var wrongArgTypeError = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
        if (params.hasStart()) {
          var startName = params.getIndexStartName();
          if (startName !== MIN_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof startNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
        if (params.hasEnd()) {
          var endName = params.getIndexEndName();
          if (endName !== MAX_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof endNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
      } else if (params.getIndex() === PRIORITY_INDEX) {
        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {
          throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
        }
      } else {
        assert(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, "unknown index type.");
        if (startNode != null && typeof startNode === "object" || endNode != null && typeof endNode === "object") {
          throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");
        }
      }
    };
    Query2.validateLimit_ = function(params) {
      if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
      }
    };
    Query2.prototype.validateNoPreviousOrderByCall_ = function(fnName) {
      if (this.orderByCalled_ === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
      }
    };
    Query2.prototype.getQueryParams = function() {
      return this.queryParams_;
    };
    Query2.prototype.getRef = function() {
      validateArgCount("Query.ref", 0, 0, arguments.length);
      return new Query2.__referenceConstructor(this.repo, this.path);
    };
    Query2.prototype.on = function(eventType, callback, cancelCallbackOrContext, context) {
      validateArgCount("Query.on", 2, 4, arguments.length);
      validateEventType("Query.on", 1, eventType, false);
      validateCallback("Query.on", 2, callback, false);
      var ret = Query2.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
      if (eventType === "value") {
        this.onValueEvent(callback, ret.cancel, ret.context);
      } else {
        var callbacks = {};
        callbacks[eventType] = callback;
        this.onChildEvent(callbacks, ret.cancel, ret.context);
      }
      return callback;
    };
    Query2.prototype.onValueEvent = function(callback, cancelCallback, context) {
      var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);
      repoAddEventCallbackForQuery(this.repo, this, container);
    };
    Query2.prototype.onChildEvent = function(callbacks, cancelCallback, context) {
      var container = new ChildEventRegistration(callbacks, cancelCallback, context);
      repoAddEventCallbackForQuery(this.repo, this, container);
    };
    Query2.prototype.off = function(eventType, callback, context) {
      validateArgCount("Query.off", 0, 3, arguments.length);
      validateEventType("Query.off", 1, eventType, true);
      validateCallback("Query.off", 2, callback, true);
      validateContextObject("Query.off", 3, context, true);
      var container = null;
      var callbacks = null;
      if (eventType === "value") {
        var valueCallback = callback || null;
        container = new ValueEventRegistration(valueCallback, null, context || null);
      } else if (eventType) {
        if (callback) {
          callbacks = {};
          callbacks[eventType] = callback;
        }
        container = new ChildEventRegistration(callbacks, null, context || null);
      }
      repoRemoveEventCallbackForQuery(this.repo, this, container);
    };
    Query2.prototype.get = function() {
      return repoGetValue(this.repo, this);
    };
    Query2.prototype.once = function(eventType, userCallback, failureCallbackOrContext, context) {
      var _this = this;
      validateArgCount("Query.once", 1, 4, arguments.length);
      validateEventType("Query.once", 1, eventType, false);
      validateCallback("Query.once", 2, userCallback, true);
      var ret = Query2.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context);
      var firstCall = true;
      var deferred = new Deferred();
      deferred.promise.catch(function() {
      });
      var onceCallback = function(snapshot) {
        if (firstCall) {
          firstCall = false;
          _this.off(eventType, onceCallback);
          if (userCallback) {
            userCallback.bind(ret.context)(snapshot);
          }
          deferred.resolve(snapshot);
        }
      };
      this.on(
        eventType,
        onceCallback,
        /*cancel=*/
        function(err) {
          _this.off(eventType, onceCallback);
          if (ret.cancel) {
            ret.cancel.bind(ret.context)(err);
          }
          deferred.reject(err);
        }
      );
      return deferred.promise;
    };
    Query2.prototype.limitToFirst = function(limit) {
      validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("Query.limitToFirst: First argument must be a positive integer.");
      }
      if (this.queryParams_.hasLimit()) {
        throw new Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
      }
      return new Query2(this.repo, this.path, queryParamsLimitToFirst(this.queryParams_, limit), this.orderByCalled_);
    };
    Query2.prototype.limitToLast = function(limit) {
      validateArgCount("Query.limitToLast", 1, 1, arguments.length);
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("Query.limitToLast: First argument must be a positive integer.");
      }
      if (this.queryParams_.hasLimit()) {
        throw new Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
      }
      return new Query2(this.repo, this.path, queryParamsLimitToLast(this.queryParams_, limit), this.orderByCalled_);
    };
    Query2.prototype.orderByChild = function(path) {
      validateArgCount("Query.orderByChild", 1, 1, arguments.length);
      if (path === "$key") {
        throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
      } else if (path === "$priority") {
        throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
      } else if (path === "$value") {
        throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
      }
      validatePathString("Query.orderByChild", 1, path, false);
      this.validateNoPreviousOrderByCall_("Query.orderByChild");
      var parsedPath = new Path(path);
      if (pathIsEmpty(parsedPath)) {
        throw new Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
      }
      var index = new PathIndex(parsedPath);
      var newParams = queryParamsOrderBy(this.queryParams_, index);
      Query2.validateQueryEndpoints_(newParams);
      return new Query2(
        this.repo,
        this.path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    Query2.prototype.orderByKey = function() {
      validateArgCount("Query.orderByKey", 0, 0, arguments.length);
      this.validateNoPreviousOrderByCall_("Query.orderByKey");
      var newParams = queryParamsOrderBy(this.queryParams_, KEY_INDEX);
      Query2.validateQueryEndpoints_(newParams);
      return new Query2(
        this.repo,
        this.path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    Query2.prototype.orderByPriority = function() {
      validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
      this.validateNoPreviousOrderByCall_("Query.orderByPriority");
      var newParams = queryParamsOrderBy(this.queryParams_, PRIORITY_INDEX);
      Query2.validateQueryEndpoints_(newParams);
      return new Query2(
        this.repo,
        this.path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    Query2.prototype.orderByValue = function() {
      validateArgCount("Query.orderByValue", 0, 0, arguments.length);
      this.validateNoPreviousOrderByCall_("Query.orderByValue");
      var newParams = queryParamsOrderBy(this.queryParams_, VALUE_INDEX);
      Query2.validateQueryEndpoints_(newParams);
      return new Query2(
        this.repo,
        this.path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    Query2.prototype.startAt = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.startAt", 0, 2, arguments.length);
      validateFirebaseDataArg("Query.startAt", 1, value, this.path, true);
      validateKey("Query.startAt", 2, name10, true);
      var newParams = queryParamsStartAt(this.queryParams_, value, name10);
      Query2.validateLimit_(newParams);
      Query2.validateQueryEndpoints_(newParams);
      if (this.queryParams_.hasStart()) {
        throw new Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");
      }
      if (value === void 0) {
        value = null;
        name10 = null;
      }
      return new Query2(this.repo, this.path, newParams, this.orderByCalled_);
    };
    Query2.prototype.startAfter = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.startAfter", 0, 2, arguments.length);
      validateFirebaseDataArg("Query.startAfter", 1, value, this.path, false);
      validateKey("Query.startAfter", 2, name10, true);
      var newParams = queryParamsStartAfter(this.queryParams_, value, name10);
      Query2.validateLimit_(newParams);
      Query2.validateQueryEndpoints_(newParams);
      if (this.queryParams_.hasStart()) {
        throw new Error("Query.startAfter: Starting point was already set (by another call to startAt, startAfter or equalTo).");
      }
      return new Query2(this.repo, this.path, newParams, this.orderByCalled_);
    };
    Query2.prototype.endAt = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.endAt", 0, 2, arguments.length);
      validateFirebaseDataArg("Query.endAt", 1, value, this.path, true);
      validateKey("Query.endAt", 2, name10, true);
      var newParams = queryParamsEndAt(this.queryParams_, value, name10);
      Query2.validateLimit_(newParams);
      Query2.validateQueryEndpoints_(newParams);
      if (this.queryParams_.hasEnd()) {
        throw new Error("Query.endAt: Ending point was already set (by another call to endAt, endBefore, or equalTo).");
      }
      return new Query2(this.repo, this.path, newParams, this.orderByCalled_);
    };
    Query2.prototype.endBefore = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.endBefore", 0, 2, arguments.length);
      validateFirebaseDataArg("Query.endBefore", 1, value, this.path, false);
      validateKey("Query.endBefore", 2, name10, true);
      var newParams = queryParamsEndBefore(this.queryParams_, value, name10);
      Query2.validateLimit_(newParams);
      Query2.validateQueryEndpoints_(newParams);
      if (this.queryParams_.hasEnd()) {
        throw new Error("Query.endBefore: Ending point was already set (by another call to endAt, endBefore, or equalTo).");
      }
      return new Query2(this.repo, this.path, newParams, this.orderByCalled_);
    };
    Query2.prototype.equalTo = function(value, name10) {
      validateArgCount("Query.equalTo", 1, 2, arguments.length);
      validateFirebaseDataArg("Query.equalTo", 1, value, this.path, false);
      validateKey("Query.equalTo", 2, name10, true);
      if (this.queryParams_.hasStart()) {
        throw new Error("Query.equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
      }
      if (this.queryParams_.hasEnd()) {
        throw new Error("Query.equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
      }
      return this.startAt(value, name10).endAt(value, name10);
    };
    Query2.prototype.toString = function() {
      validateArgCount("Query.toString", 0, 0, arguments.length);
      return this.repo.toString() + pathToUrlEncodedString(this.path);
    };
    Query2.prototype.toJSON = function() {
      validateArgCount("Query.toJSON", 0, 1, arguments.length);
      return this.toString();
    };
    Query2.prototype.queryObject = function() {
      return queryParamsGetQueryObject(this.queryParams_);
    };
    Query2.prototype.queryIdentifier = function() {
      var obj = this.queryObject();
      var id2 = ObjectToUniqueKey(obj);
      return id2 === "{}" ? "default" : id2;
    };
    Query2.prototype.isEqual = function(other) {
      validateArgCount("Query.isEqual", 1, 1, arguments.length);
      if (!(other instanceof Query2)) {
        var error2 = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
        throw new Error(error2);
      }
      var sameRepo = this.repo === other.repo;
      var samePath = pathEquals(this.path, other.path);
      var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
      return sameRepo && samePath && sameQueryIdentifier;
    };
    Query2.getCancelAndContextArgs_ = function(fnName, cancelOrContext, context) {
      var ret = { cancel: null, context: null };
      if (cancelOrContext && context) {
        ret.cancel = cancelOrContext;
        validateCallback(fnName, 3, ret.cancel, true);
        ret.context = context;
        validateContextObject(fnName, 4, ret.context, true);
      } else if (cancelOrContext) {
        if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
          ret.context = cancelOrContext;
        } else if (typeof cancelOrContext === "function") {
          ret.cancel = cancelOrContext;
        } else {
          throw new Error(errorPrefix(fnName, 3, true) + " must either be a cancel callback or a context object.");
        }
      }
      return ret;
    };
    Object.defineProperty(Query2.prototype, "ref", {
      get: function() {
        return this.getRef();
      },
      enumerable: false,
      configurable: true
    });
    return Query2;
  }()
);
var Reference = (
  /** @class */
  function(_super) {
    __extends(Reference3, _super);
    function Reference3(repo, path) {
      var _this = this;
      if (!(repo instanceof Repo)) {
        throw new Error("new Reference() no longer supported - use app.database().");
      }
      _this = _super.call(this, repo, path, new QueryParams(), false) || this;
      return _this;
    }
    Reference3.prototype.getKey = function() {
      validateArgCount("Reference.key", 0, 0, arguments.length);
      if (pathIsEmpty(this.path)) {
        return null;
      } else {
        return pathGetBack(this.path);
      }
    };
    Reference3.prototype.child = function(pathString) {
      validateArgCount("Reference.child", 1, 1, arguments.length);
      if (typeof pathString === "number") {
        pathString = String(pathString);
      } else if (!(pathString instanceof Path)) {
        if (pathGetFront(this.path) === null) {
          validateRootPathString("Reference.child", 1, pathString, false);
        } else {
          validatePathString("Reference.child", 1, pathString, false);
        }
      }
      return new Reference3(this.repo, pathChild(this.path, pathString));
    };
    Reference3.prototype.getParent = function() {
      validateArgCount("Reference.parent", 0, 0, arguments.length);
      var parentPath = pathParent(this.path);
      return parentPath === null ? null : new Reference3(this.repo, parentPath);
    };
    Reference3.prototype.getRoot = function() {
      validateArgCount("Reference.root", 0, 0, arguments.length);
      var ref2 = this;
      while (ref2.getParent() !== null) {
        ref2 = ref2.getParent();
      }
      return ref2;
    };
    Reference3.prototype.databaseProp = function() {
      return repoGetDatabase(this.repo);
    };
    Reference3.prototype.set = function(newVal, onComplete) {
      validateArgCount("Reference.set", 1, 2, arguments.length);
      validateWritablePath("Reference.set", this.path);
      validateFirebaseDataArg("Reference.set", 1, newVal, this.path, false);
      validateCallback("Reference.set", 2, onComplete, true);
      var deferred = new Deferred();
      repoSetWithPriority(
        this.repo,
        this.path,
        newVal,
        /*priority=*/
        null,
        deferred.wrapCallback(onComplete)
      );
      return deferred.promise;
    };
    Reference3.prototype.update = function(objectToMerge, onComplete) {
      validateArgCount("Reference.update", 1, 2, arguments.length);
      validateWritablePath("Reference.update", this.path);
      if (Array.isArray(objectToMerge)) {
        var newObjectToMerge = {};
        for (var i = 0; i < objectToMerge.length; ++i) {
          newObjectToMerge["" + i] = objectToMerge[i];
        }
        objectToMerge = newObjectToMerge;
        warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
      }
      validateFirebaseMergeDataArg("Reference.update", 1, objectToMerge, this.path, false);
      validateCallback("Reference.update", 2, onComplete, true);
      var deferred = new Deferred();
      repoUpdate(this.repo, this.path, objectToMerge, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    Reference3.prototype.setWithPriority = function(newVal, newPriority, onComplete) {
      validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
      validateWritablePath("Reference.setWithPriority", this.path);
      validateFirebaseDataArg("Reference.setWithPriority", 1, newVal, this.path, false);
      validatePriority("Reference.setWithPriority", 2, newPriority, false);
      validateCallback("Reference.setWithPriority", 3, onComplete, true);
      if (this.getKey() === ".length" || this.getKey() === ".keys") {
        throw "Reference.setWithPriority failed: " + this.getKey() + " is a read-only object.";
      }
      var deferred = new Deferred();
      repoSetWithPriority(this.repo, this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    Reference3.prototype.remove = function(onComplete) {
      validateArgCount("Reference.remove", 0, 1, arguments.length);
      validateWritablePath("Reference.remove", this.path);
      validateCallback("Reference.remove", 1, onComplete, true);
      return this.set(null, onComplete);
    };
    Reference3.prototype.transaction = function(transactionUpdate, onComplete, applyLocally) {
      validateArgCount("Reference.transaction", 1, 3, arguments.length);
      validateWritablePath("Reference.transaction", this.path);
      validateCallback("Reference.transaction", 1, transactionUpdate, false);
      validateCallback("Reference.transaction", 2, onComplete, true);
      validateBoolean("Reference.transaction", 3, applyLocally, true);
      if (this.getKey() === ".length" || this.getKey() === ".keys") {
        throw "Reference.transaction failed: " + this.getKey() + " is a read-only object.";
      }
      if (applyLocally === void 0) {
        applyLocally = true;
      }
      var deferred = new Deferred();
      if (typeof onComplete === "function") {
        deferred.promise.catch(function() {
        });
      }
      var promiseComplete = function(error2, committed, snapshot) {
        if (error2) {
          deferred.reject(error2);
        } else {
          deferred.resolve(new TransactionResult(committed, snapshot));
        }
        if (typeof onComplete === "function") {
          onComplete(error2, committed, snapshot);
        }
      };
      repoStartTransaction(this.repo, this.path, transactionUpdate, promiseComplete, applyLocally);
      return deferred.promise;
    };
    Reference3.prototype.setPriority = function(priority, onComplete) {
      validateArgCount("Reference.setPriority", 1, 2, arguments.length);
      validateWritablePath("Reference.setPriority", this.path);
      validatePriority("Reference.setPriority", 1, priority, false);
      validateCallback("Reference.setPriority", 2, onComplete, true);
      var deferred = new Deferred();
      repoSetWithPriority(this.repo, pathChild(this.path, ".priority"), priority, null, deferred.wrapCallback(onComplete));
      return deferred.promise;
    };
    Reference3.prototype.push = function(value, onComplete) {
      validateArgCount("Reference.push", 0, 2, arguments.length);
      validateWritablePath("Reference.push", this.path);
      validateFirebaseDataArg("Reference.push", 1, value, this.path, true);
      validateCallback("Reference.push", 2, onComplete, true);
      var now = repoServerTime(this.repo);
      var name10 = nextPushId(now);
      var thennablePushRef = this.child(name10);
      var pushRef = this.child(name10);
      var promise;
      if (value != null) {
        promise = thennablePushRef.set(value, onComplete).then(function() {
          return pushRef;
        });
      } else {
        promise = Promise.resolve(pushRef);
      }
      thennablePushRef.then = promise.then.bind(promise);
      thennablePushRef.catch = promise.then.bind(promise, void 0);
      if (typeof onComplete === "function") {
        promise.catch(function() {
        });
      }
      return thennablePushRef;
    };
    Reference3.prototype.onDisconnect = function() {
      validateWritablePath("Reference.onDisconnect", this.path);
      return new OnDisconnect(this.repo, this.path);
    };
    Object.defineProperty(Reference3.prototype, "database", {
      get: function() {
        return this.databaseProp();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "key", {
      get: function() {
        return this.getKey();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "parent", {
      get: function() {
        return this.getParent();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "root", {
      get: function() {
        return this.getRoot();
      },
      enumerable: false,
      configurable: true
    });
    return Reference3;
  }(Query)
);
Query.__referenceConstructor = Reference;
syncPointSetReferenceConstructor(Reference);
var FirebaseAuthTokenProvider = (
  /** @class */
  function() {
    function FirebaseAuthTokenProvider2(app_, authProvider_) {
      var _this = this;
      this.app_ = app_;
      this.authProvider_ = authProvider_;
      this.auth_ = null;
      this.auth_ = authProvider_.getImmediate({ optional: true });
      if (!this.auth_) {
        authProvider_.get().then(function(auth) {
          return _this.auth_ = auth;
        });
      }
    }
    FirebaseAuthTokenProvider2.prototype.getToken = function(forceRefresh) {
      if (!this.auth_) {
        return Promise.resolve(null);
      }
      return this.auth_.getToken(forceRefresh).catch(function(error2) {
        if (error2 && error2.code === "auth/token-not-initialized") {
          log("Got auth/token-not-initialized error.  Treating as null token.");
          return null;
        } else {
          return Promise.reject(error2);
        }
      });
    };
    FirebaseAuthTokenProvider2.prototype.addTokenChangeListener = function(listener) {
      if (this.auth_) {
        this.auth_.addAuthTokenListener(listener);
      } else {
        setTimeout(function() {
          return listener(null);
        }, 0);
        this.authProvider_.get().then(function(auth) {
          return auth.addAuthTokenListener(listener);
        });
      }
    };
    FirebaseAuthTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
      this.authProvider_.get().then(function(auth) {
        return auth.removeAuthTokenListener(listener);
      });
    };
    FirebaseAuthTokenProvider2.prototype.notifyForInvalidToken = function() {
      var errorMessage = 'Provided authentication credentials for the app named "' + this.app_.name + '" are invalid. This usually indicates your app was not initialized correctly. ';
      if ("credential" in this.app_.options) {
        errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
      } else if ("serviceAccount" in this.app_.options) {
        errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
      } else {
        errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
      }
      warn(errorMessage);
    };
    return FirebaseAuthTokenProvider2;
  }()
);
var EmulatorAdminTokenProvider = (
  /** @class */
  function() {
    function EmulatorAdminTokenProvider2() {
    }
    EmulatorAdminTokenProvider2.prototype.getToken = function(forceRefresh) {
      return Promise.resolve({
        accessToken: EmulatorAdminTokenProvider2.EMULATOR_AUTH_TOKEN
      });
    };
    EmulatorAdminTokenProvider2.prototype.addTokenChangeListener = function(listener) {
      listener(EmulatorAdminTokenProvider2.EMULATOR_AUTH_TOKEN);
    };
    EmulatorAdminTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
    };
    EmulatorAdminTokenProvider2.prototype.notifyForInvalidToken = function() {
    };
    EmulatorAdminTokenProvider2.EMULATOR_AUTH_TOKEN = "owner";
    return EmulatorAdminTokenProvider2;
  }()
);
var FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
var repos = {};
var useRestClient = false;
function repoManagerApplyEmulatorSettings(repo, host, port) {
  repo.repoInfo_ = new RepoInfo(
    host + ":" + port,
    /* secure= */
    false,
    repo.repoInfo_.namespace,
    repo.repoInfo_.webSocketOnly,
    repo.repoInfo_.nodeAdmin,
    repo.repoInfo_.persistenceKey,
    repo.repoInfo_.includeNamespaceInQueryParams
  );
  if (repo.repoInfo_.nodeAdmin) {
    repo.authTokenProvider_ = new EmulatorAdminTokenProvider();
  }
}
function repoManagerDatabaseFromApp(app, authProvider, url, nodeAdmin) {
  var dbUrl = url || app.options.databaseURL;
  if (dbUrl === void 0) {
    if (!app.options.projectId) {
      fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
    }
    log("Using default host for project ", app.options.projectId);
    dbUrl = app.options.projectId + "-default-rtdb.firebaseio.com";
  }
  var parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
  var repoInfo = parsedUrl.repoInfo;
  var isEmulator;
  var dbEmulatorHost = void 0;
  if (typeof process !== "undefined") {
    dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
  }
  if (dbEmulatorHost) {
    isEmulator = true;
    dbUrl = "http://" + dbEmulatorHost + "?ns=" + repoInfo.namespace;
    parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    repoInfo = parsedUrl.repoInfo;
  } else {
    isEmulator = !parsedUrl.repoInfo.secure;
  }
  var authTokenProvider = nodeAdmin && isEmulator ? new EmulatorAdminTokenProvider() : new FirebaseAuthTokenProvider(app, authProvider);
  validateUrl("Invalid Firebase Database URL", 1, parsedUrl);
  if (!pathIsEmpty(parsedUrl.path)) {
    fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
  }
  var repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider);
  return repoGetDatabase(repo);
}
function repoManagerDeleteRepo(repo) {
  var appRepos = safeGet(repos, repo.app.name);
  if (!appRepos || safeGet(appRepos, repo.key) !== repo) {
    fatal("Database " + repo.app.name + "(" + repo.repoInfo_ + ") has already been deleted.");
  }
  repoInterrupt(repo);
  delete appRepos[repo.key];
}
function repoManagerCreateRepo(repoInfo, app, authTokenProvider) {
  var appRepos = safeGet(repos, app.name);
  if (!appRepos) {
    appRepos = {};
    repos[app.name] = appRepos;
  }
  var repo = safeGet(appRepos, repoInfo.toURLString());
  if (repo) {
    fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
  }
  repo = new Repo(repoInfo, useRestClient, app, authTokenProvider);
  appRepos[repoInfo.toURLString()] = repo;
  return repo;
}
function repoManagerForceRestClient(forceRestClient2) {
  useRestClient = forceRestClient2;
}
var Database = (
  /** @class */
  function() {
    function Database2(repoInternal_) {
      var _this = this;
      this.repoInternal_ = repoInternal_;
      this.instanceStarted_ = false;
      this.INTERNAL = {
        delete: function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a9) {
              this.checkDeleted_("delete");
              repoManagerDeleteRepo(this.repo_);
              this.repoInternal_ = null;
              this.rootInternal_ = null;
              return [
                2
                /*return*/
              ];
            });
          });
        }
      };
      if (!(repoInternal_ instanceof Repo)) {
        fatal("Don't call new Database() directly - please use firebase.database().");
      }
    }
    Object.defineProperty(Database2.prototype, "repo_", {
      get: function() {
        if (!this.instanceStarted_) {
          repoStart(this.repoInternal_);
          this.instanceStarted_ = true;
        }
        return this.repoInternal_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Database2.prototype, "root_", {
      get: function() {
        if (!this.rootInternal_) {
          this.rootInternal_ = new Reference(this.repo_, newEmptyPath());
        }
        return this.rootInternal_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Database2.prototype, "app", {
      get: function() {
        return this.repo_.app;
      },
      enumerable: false,
      configurable: true
    });
    Database2.prototype.useEmulator = function(host, port) {
      this.checkDeleted_("useEmulator");
      if (this.instanceStarted_) {
        fatal("Cannot call useEmulator() after instance has already been initialized.");
        return;
      }
      repoManagerApplyEmulatorSettings(this.repoInternal_, host, port);
    };
    Database2.prototype.ref = function(path) {
      this.checkDeleted_("ref");
      validateArgCount("database.ref", 0, 1, arguments.length);
      if (path instanceof Reference) {
        return this.refFromURL(path.toString());
      }
      return path !== void 0 ? this.root_.child(path) : this.root_;
    };
    Database2.prototype.refFromURL = function(url) {
      var apiName = "database.refFromURL";
      this.checkDeleted_(apiName);
      validateArgCount(apiName, 1, 1, arguments.length);
      var parsedURL = parseRepoInfo(url, this.repo_.repoInfo_.nodeAdmin);
      validateUrl(apiName, 1, parsedURL);
      var repoInfo = parsedURL.repoInfo;
      if (!this.repo_.repoInfo_.isCustomHost() && repoInfo.host !== this.repo_.repoInfo_.host) {
        fatal(apiName + ": Host name does not match the current database: (found " + repoInfo.host + " but expected " + this.repo_.repoInfo_.host + ")");
      }
      return this.ref(parsedURL.path.toString());
    };
    Database2.prototype.checkDeleted_ = function(apiName) {
      if (this.repoInternal_ === null) {
        fatal("Cannot call " + apiName + " on a deleted database.");
      }
    };
    Database2.prototype.goOffline = function() {
      validateArgCount("database.goOffline", 0, 0, arguments.length);
      this.checkDeleted_("goOffline");
      repoInterrupt(this.repo_);
    };
    Database2.prototype.goOnline = function() {
      validateArgCount("database.goOnline", 0, 0, arguments.length);
      this.checkDeleted_("goOnline");
      repoResume(this.repo_);
    };
    Database2.ServerValue = {
      TIMESTAMP: {
        ".sv": "timestamp"
      },
      increment: function(delta) {
        return {
          ".sv": {
            "increment": delta
          }
        };
      }
    };
    return Database2;
  }()
);
var forceLongPolling = function() {
  WebSocketConnection.forceDisallow();
  BrowserPollConnection.forceAllow();
};
var forceWebSockets = function() {
  BrowserPollConnection.forceDisallow();
};
var isWebSocketsAvailable = function() {
  return WebSocketConnection["isAvailable"]();
};
var setSecurityDebugCallback = function(ref2, callback) {
  ref2.repo.persistentConnection_.securityDebugCallback_ = callback;
};
var stats = function(ref2, showDelta) {
  repoStats(ref2.repo, showDelta);
};
var statsIncrementCounter = function(ref2, metric) {
  repoStatsIncrementCounter(ref2.repo, metric);
};
var dataUpdateCount = function(ref2) {
  return ref2.repo.dataUpdateCount;
};
var interceptServerData = function(ref2, callback) {
  return repoInterceptServerData(ref2.repo, callback);
};
function initStandalone(_a9) {
  var app = _a9.app, url = _a9.url, version10 = _a9.version, customAuthImpl = _a9.customAuthImpl, namespace = _a9.namespace, _b = _a9.nodeAdmin, nodeAdmin = _b === void 0 ? false : _b;
  setSDKVersion(version10);
  var authProvider = new Provider("auth-internal", new ComponentContainer("database-standalone"));
  authProvider.setComponent(new Component(
    "auth-internal",
    function() {
      return customAuthImpl;
    },
    "PRIVATE"
    /* PRIVATE */
  ));
  return {
    instance: repoManagerDatabaseFromApp(app, authProvider, url, nodeAdmin),
    namespace
  };
}
var INTERNAL = Object.freeze({
  __proto__: null,
  forceLongPolling,
  forceWebSockets,
  isWebSocketsAvailable,
  setSecurityDebugCallback,
  stats,
  statsIncrementCounter,
  dataUpdateCount,
  interceptServerData,
  initStandalone
});
var DataConnection = PersistentConnection;
PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
  this.sendRequest("q", { p: pathString }, onComplete);
};
PersistentConnection.prototype.echo = function(data, onEcho) {
  this.sendRequest("echo", { d: data }, onEcho);
};
var RealTimeConnection = Connection;
var hijackHash = function(newHash) {
  var oldPut = PersistentConnection.prototype.put;
  PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {
    if (hash !== void 0) {
      hash = newHash();
    }
    oldPut.call(this, pathString, data, onComplete, hash);
  };
  return function() {
    PersistentConnection.prototype.put = oldPut;
  };
};
var ConnectionTarget = RepoInfo;
var queryIdentifier = function(query) {
  return query.queryIdentifier();
};
var forceRestClient = function(forceRestClient2) {
  repoManagerForceRestClient(forceRestClient2);
};
var TEST_ACCESS = Object.freeze({
  __proto__: null,
  DataConnection,
  RealTimeConnection,
  hijackHash,
  ConnectionTarget,
  queryIdentifier,
  forceRestClient
});
var name2 = "@firebase/database";
var version2 = "0.9.6";
var ServerValue = Database.ServerValue;
function registerDatabase(instance) {
  setSDKVersion(instance.SDK_VERSION);
  var namespace = instance.INTERNAL.registerComponent(new Component(
    "database",
    function(container, _a9) {
      var url = _a9.instanceIdentifier;
      var app = container.getProvider("app").getImmediate();
      var authProvider = container.getProvider("auth-internal");
      return repoManagerDatabaseFromApp(app, authProvider, url, void 0);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(
    // firebase.database namespace properties
    {
      Reference,
      Query,
      Database,
      DataSnapshot,
      enableLogging,
      INTERNAL,
      ServerValue,
      TEST_ACCESS
    }
  ).setMultipleInstances(true));
  instance.registerVersion(name2, version2);
  if (isNodeSdk()) {
    module.exports = namespace;
  }
}
registerDatabase(index_esm_default);

// node_modules/@firebase/webchannel-wrapper/dist/index.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends2(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var h;
var goog = goog || {};
var k = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = "object" != b ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return "array" == b || "object" == b && "number" == typeof a.length;
}
function n(a) {
  var b = typeof a;
  return "object" == b && null != a || "function" == b;
}
function ca(a) {
  return Object.prototype.hasOwnProperty.call(a, da) && a[da] || (a[da] = ++ea);
}
var da = "closure_uid_" + (1e9 * Math.random() >>> 0);
var ea = 0;
function fa(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ha(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function p(a, b, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? p = fa : p = ha;
  return p.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function q() {
  return Date.now();
}
function r(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.X = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Kb = function(d, e, f) {
    for (var g = Array(arguments.length - 2), m = 2; m < arguments.length; m++)
      g[m - 2] = arguments[m];
    return b.prototype[e].apply(d, g);
  };
}
function t() {
  this.j = this.j;
  this.i = this.i;
}
var ka = 0;
t.prototype.j = false;
t.prototype.ja = function() {
  if (!this.j && (this.j = true, this.G(), 0 != ka)) {
    var a = ca(this);
  }
};
t.prototype.G = function() {
  if (this.i)
    for (; this.i.length; )
      this.i.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if ("string" === typeof a)
    return "string" !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  for (var d = a.length, e = "string" === typeof a ? a.split("") : a, f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    for (var c = a.length, d = "string" === typeof a ? a.split("") : a, e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : "string" === typeof a ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  var b = a.length;
  if (0 < b) {
    for (var c = Array(b), d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function v(a, b) {
  return -1 != a.indexOf(b);
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var w;
a: {
  va2 = k.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      w = wa2;
      break a;
    }
  }
  w = "";
}
var va2;
var wa2;
function za(a, b, c) {
  for (var d in a)
    b.call(c, a[d], d, a);
}
function Aa(a) {
  var b = {};
  for (var c in a)
    b[c] = a[c];
  return b;
}
var Ba = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Ca(a, b) {
  var c, d;
  for (var e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (var f = 0; f < Ba.length; f++)
      c = Ba[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Da(a) {
  Da[" "](a);
  return a;
}
Da[" "] = aa;
function Ea(a, b) {
  var c = Fa;
  return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
}
var Ga = v(w, "Opera");
var x = v(w, "Trident") || v(w, "MSIE");
var Ha = v(w, "Edge");
var Ia = Ha || x;
var Ja = v(w, "Gecko") && !(v(w.toLowerCase(), "webkit") && !v(w, "Edge")) && !(v(w, "Trident") || v(w, "MSIE")) && !v(w, "Edge");
var Ka = v(w.toLowerCase(), "webkit") && !v(w, "Edge");
function La() {
  var a = k.document;
  return a ? a.documentMode : void 0;
}
var Ma;
a: {
  Na2 = "", Oa2 = function() {
    var a = w;
    if (Ja)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ha)
      return /Edge\/([\d\.]+)/.exec(a);
    if (x)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (Ka)
      return /WebKit\/(\S+)/.exec(a);
    if (Ga)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Oa2 && (Na2 = Oa2 ? Oa2[1] : "");
  if (x) {
    Pa2 = La();
    if (null != Pa2 && Pa2 > parseFloat(Na2)) {
      Ma = String(Pa2);
      break a;
    }
  }
  Ma = Na2;
}
var Na2;
var Oa2;
var Pa2;
var Fa = {};
function Qa(a) {
  return Ea(a, function() {
    {
      var b = 0;
      var e = ta(String(Ma)).split("."), f = ta(String(a)).split("."), g = Math.max(e.length, f.length);
      for (var m = 0; 0 == b && m < g; m++) {
        var c = e[m] || "", d = f[m] || "";
        do {
          c = /(\d*)(\D*)(.*)/.exec(c) || ["", "", "", ""];
          d = /(\d*)(\D*)(.*)/.exec(d) || ["", "", "", ""];
          if (0 == c[0].length && 0 == d[0].length)
            break;
          b = ua(0 == c[1].length ? 0 : parseInt(c[1], 10), 0 == d[1].length ? 0 : parseInt(d[1], 10)) || ua(0 == c[2].length, 0 == d[2].length) || ua(c[2], d[2]);
          c = c[3];
          d = d[3];
        } while (0 == b);
      }
    }
    return 0 <= b;
  });
}
var Ra;
if (k.document && x) {
  Sa2 = La();
  Ra = Sa2 ? Sa2 : parseInt(Ma, 10) || void 0;
} else
  Ra = void 0;
var Sa2;
var Ta = Ra;
var Ua = !x || 9 <= Number(Ta);
var Va = x && !Qa("9");
var Wa = function() {
  if (!k.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    k.addEventListener("test", aa, b), k.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function y(a, b) {
  this.type = a;
  this.a = this.target = b;
  this.defaultPrevented = false;
}
y.prototype.b = function() {
  this.defaultPrevented = true;
};
function z(a, b) {
  y.call(this, a ? a.type : "");
  this.relatedTarget = this.a = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.pointerId = 0;
  this.pointerType = "";
  this.c = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.a = b;
    if (b = a.relatedTarget) {
      if (Ja) {
        a: {
          try {
            Da(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Xa[a.pointerType] || "";
    this.c = a;
    a.defaultPrevented && this.b();
  }
}
r(z, y);
var Xa = { 2: "touch", 3: "pen", 4: "mouse" };
z.prototype.b = function() {
  z.X.b.call(this);
  var a = this.c;
  if (a.preventDefault)
    a.preventDefault();
  else if (a.returnValue = false, Va)
    try {
      if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
        a.keyCode = -1;
    } catch (b) {
    }
};
var A = "closure_listenable_" + (1e6 * Math.random() | 0);
var Ya = 0;
function Za(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ca = e;
  this.key = ++Ya;
  this.Y = this.Z = false;
}
function $a(a) {
  a.Y = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ca = null;
}
function ab(a) {
  this.src = a;
  this.a = {};
  this.b = 0;
}
ab.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.a[f];
  a || (a = this.a[f] = [], this.b++);
  var g = bb(a, b, d, e);
  -1 < g ? (b = a[g], c || (b.Z = false)) : (b = new Za(b, this.src, f, !!d, e), b.Z = c, a.push(b));
  return b;
};
function cb(a, b) {
  var c = b.type;
  if (c in a.a) {
    var d = a.a[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && ($a(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
  }
}
function bb(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.Y && f.listener == b && f.capture == !!c && f.ca == d)
      return e;
  }
  return -1;
}
var db = "closure_lm_" + (1e6 * Math.random() | 0);
var eb = {};
function gb(a, b, c, d, e) {
  if (d && d.once)
    return hb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = ib(c);
  return a && a[A] ? a.va(b, c, n(d) ? !!d.capture : !!d, e) : jb(a, b, c, false, d, e);
}
function jb(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var g = n(e) ? !!e.capture : !!e;
  if (g && !Ua)
    return null;
  var m = kb(a);
  m || (a[db] = m = new ab(a));
  c = m.add(b, c, d, g, f);
  if (c.proxy)
    return c;
  d = lb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Wa || (e = g), void 0 === e && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(mb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function lb() {
  var a = nb, b = Ua ? function(c) {
    return a.call(b.src, b.listener, c);
  } : function(c) {
    c = a.call(b.src, b.listener, c);
    if (!c)
      return c;
  };
  return b;
}
function hb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      hb(a, b[f], c, d, e);
    return null;
  }
  c = ib(c);
  return a && a[A] ? a.wa(b, c, n(d) ? !!d.capture : !!d, e) : jb(a, b, c, true, d, e);
}
function ob(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      ob(a, b[f], c, d, e);
  else
    (d = n(d) ? !!d.capture : !!d, c = ib(c), a && a[A]) ? (a = a.c, b = String(b).toString(), b in a.a && (f = a.a[b], c = bb(f, c, d, e), -1 < c && ($a(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], a.b--)))) : a && (a = kb(a)) && (b = a.a[b.toString()], a = -1, b && (a = bb(b, c, d, e)), (c = -1 < a ? b[a] : null) && pb(c));
}
function pb(a) {
  if ("number" !== typeof a && a && !a.Y) {
    var b = a.src;
    if (b && b[A])
      cb(b.c, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(mb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = kb(b)) ? (cb(c, a), 0 == c.b && (c.src = null, b[db] = null)) : $a(a);
    }
  }
}
function mb(a) {
  return a in eb ? eb[a] : eb[a] = "on" + a;
}
function qb(a, b) {
  var c = a.listener, d = a.ca || a.src;
  a.Z && pb(a);
  return c.call(d, b);
}
function nb(a, b) {
  if (a.Y)
    return true;
  if (!Ua) {
    if (!b)
      a: {
        b = ["window", "event"];
        for (var c = k, d = 0; d < b.length; d++)
          if (c = c[b[d]], null == c) {
            b = null;
            break a;
          }
        b = c;
      }
    b = new z(b, this);
    return qb(a, b);
  }
  return qb(a, new z(b, this));
}
function kb(a) {
  a = a[db];
  return a instanceof ab ? a : null;
}
var sb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function ib(a) {
  if ("function" === typeof a)
    return a;
  a[sb] || (a[sb] = function(b) {
    return a.handleEvent(b);
  });
  return a[sb];
}
function D() {
  t.call(this);
  this.c = new ab(this);
  this.J = this;
  this.C = null;
}
r(D, t);
D.prototype[A] = true;
h = D.prototype;
h.addEventListener = function(a, b, c, d) {
  gb(this, a, b, c, d);
};
h.removeEventListener = function(a, b, c, d) {
  ob(this, a, b, c, d);
};
function E(a, b) {
  var c, d = a.C;
  if (d)
    for (c = []; d; d = d.C)
      c.push(d);
  a = a.J;
  d = b.type || b;
  if ("string" === typeof b)
    b = new y(b, a);
  else if (b instanceof y)
    b.target = b.target || a;
  else {
    var e = b;
    b = new y(d, a);
    Ca(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var g = b.a = c[f];
      e = tb(g, d, true, b) && e;
    }
  g = b.a = a;
  e = tb(g, d, true, b) && e;
  e = tb(g, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      g = b.a = c[f], e = tb(g, d, false, b) && e;
}
h.G = function() {
  D.X.G.call(this);
  if (this.c) {
    var a = this.c, c;
    for (c in a.a) {
      for (var d = a.a[c], e = 0; e < d.length; e++)
        $a(d[e]);
      delete a.a[c];
      a.b--;
    }
  }
  this.C = null;
};
h.va = function(a, b, c, d) {
  return this.c.add(String(a), b, false, c, d);
};
h.wa = function(a, b, c, d) {
  return this.c.add(String(a), b, true, c, d);
};
function tb(a, b, c, d) {
  b = a.c.a[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var g = b[f];
    if (g && !g.Y && g.capture == c) {
      var m = g.listener, l = g.ca || g.src;
      g.Z && cb(a.c, g);
      e = false !== m.call(l, d) && e;
    }
  }
  return e && !d.defaultPrevented;
}
var ub = k.JSON.stringify;
function vb() {
  this.b = this.a = null;
}
var xb = new /** @class */
(function() {
  function class_1(a, b) {
    this.c = a;
    this.f = b;
    this.b = 0;
    this.a = null;
  }
  class_1.prototype.get = function() {
    var a;
    0 < this.b ? (this.b--, a = this.a, this.a = a.next, a.next = null) : a = this.c();
    return a;
  };
  return class_1;
}())(function() {
  return new wb();
}, function(a) {
  a.reset();
});
vb.prototype.add = function(a, b) {
  var c = xb.get();
  c.set(a, b);
  this.b ? this.b.next = c : this.a = c;
  this.b = c;
};
function yb() {
  var a = zb, b = null;
  a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);
  return b;
}
function wb() {
  this.next = this.b = this.a = null;
}
wb.prototype.set = function(a, b) {
  this.a = a;
  this.b = b;
  this.next = null;
};
wb.prototype.reset = function() {
  this.next = this.b = this.a = null;
};
function Ab(a) {
  k.setTimeout(function() {
    throw a;
  }, 0);
}
function Bb(a, b) {
  Cb || Db();
  Eb || (Cb(), Eb = true);
  zb.add(a, b);
}
var Cb;
function Db() {
  var a = k.Promise.resolve(void 0);
  Cb = function() {
    a.then(Fb);
  };
}
var Eb = false;
var zb = new vb();
function Fb() {
  for (var a; a = yb(); ) {
    try {
      a.a.call(a.b);
    } catch (c) {
      Ab(c);
    }
    var b = xb;
    b.f(a);
    100 > b.b && (b.b++, a.next = b.a, b.a = a);
  }
  Eb = false;
}
function Gb(a, b) {
  D.call(this);
  this.b = a || 1;
  this.a = b || k;
  this.f = p(this.Za, this);
  this.g = q();
}
r(Gb, D);
h = Gb.prototype;
h.aa = false;
h.M = null;
h.Za = function() {
  if (this.aa) {
    var a = q() - this.g;
    0 < a && a < 0.8 * this.b ? this.M = this.a.setTimeout(this.f, this.b - a) : (this.M && (this.a.clearTimeout(this.M), this.M = null), E(this, "tick"), this.aa && (Hb(this), this.start()));
  }
};
h.start = function() {
  this.aa = true;
  this.M || (this.M = this.a.setTimeout(this.f, this.b), this.g = q());
};
function Hb(a) {
  a.aa = false;
  a.M && (a.a.clearTimeout(a.M), a.M = null);
}
h.G = function() {
  Gb.X.G.call(this);
  Hb(this);
  delete this.a;
};
function Ib(a, b, c) {
  if ("function" === typeof a)
    c && (a = p(a, c));
  else if (a && "function" == typeof a.handleEvent)
    a = p(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : k.setTimeout(a, b || 0);
}
function Jb(a) {
  a.a = Ib(function() {
    a.a = null;
    a.c && (a.c = false, Jb(a));
  }, a.h);
  var b = a.b;
  a.b = null;
  a.g.apply(null, b);
}
var Kb = (
  /** @class */
  function(_super) {
    __extends2(Kb2, _super);
    function Kb2(a, b) {
      var _this = _super.call(this) || this;
      _this.g = a;
      _this.h = b;
      _this.b = null;
      _this.c = false;
      _this.a = null;
      return _this;
    }
    Kb2.prototype.f = function(a) {
      this.b = arguments;
      this.a ? this.c = true : Jb(this);
    };
    Kb2.prototype.G = function() {
      _super.prototype.G.call(this);
      this.a && (k.clearTimeout(this.a), this.a = null, this.c = false, this.b = null);
    };
    return Kb2;
  }(t)
);
function F(a) {
  t.call(this);
  this.b = a;
  this.a = {};
}
r(F, t);
var Lb = [];
function Mb(a, b, c, d) {
  Array.isArray(c) || (c && (Lb[0] = c.toString()), c = Lb);
  for (var e = 0; e < c.length; e++) {
    var f = gb(b, c[e], d || a.handleEvent, false, a.b || a);
    if (!f)
      break;
    a.a[f.key] = f;
  }
}
function Nb(a) {
  za(a.a, function(b, c) {
    this.a.hasOwnProperty(c) && pb(b);
  }, a);
  a.a = {};
}
F.prototype.G = function() {
  F.X.G.call(this);
  Nb(this);
};
F.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Ob() {
  this.a = true;
}
function Pb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.a)
      if (f) {
        var g = "";
        for (var m = f.split("&"), l = 0; l < m.length; l++) {
          var u = m[l].split("=");
          if (1 < u.length) {
            var C2 = u[0];
            u = u[1];
            var B2 = C2.split("_");
            g = 2 <= B2.length && "type" == B2[1] ? g + (C2 + "=" + u + "&") : g + (C2 + "=redacted&");
          }
        }
      } else
        g = null;
    else
      g = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + g;
  });
}
function Qb(a, b, c, d, e, f, g) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + g;
  });
}
function G(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Rb(a, c) + (d ? " " + d : "");
  });
}
function Sb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Ob.prototype.info = function() {
};
function Rb(a, b) {
  if (!a.a)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if ("noop" != f && "stop" != f && "close" != f)
                for (var g = 1; g < e.length; g++)
                  e[g] = "";
            }
          }
        }
    }
    return ub(c);
  } catch (m) {
    return b;
  }
}
var H = {};
var Tb = null;
function Ub() {
  return Tb = Tb || new D();
}
H.Fa = "serverreachability";
function Vb(a) {
  y.call(this, H.Fa, a);
}
r(Vb, y);
function I(a) {
  var b = Ub();
  E(b, new Vb(b, a));
}
H.STAT_EVENT = "statevent";
function Wb(a, b) {
  y.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
r(Wb, y);
function J(a) {
  var b = Ub();
  E(b, new Wb(b, a));
}
H.Ga = "timingevent";
function Xb(a) {
  y.call(this, H.Ga, a);
}
r(Xb, y);
function K(a, b) {
  if ("function" !== typeof a)
    throw Error("Fn must not be null and must be a function");
  return k.setTimeout(function() {
    a();
  }, b);
}
var Yb = { NO_ERROR: 0, $a: 1, nb: 2, mb: 3, hb: 4, lb: 5, ob: 6, Da: 7, TIMEOUT: 8, rb: 9 };
var Zb = { fb: "complete", Bb: "success", Ea: "error", Da: "abort", tb: "ready", ub: "readystatechange", TIMEOUT: "timeout", pb: "incrementaldata", sb: "progress", ib: "downloadprogress", Jb: "uploadprogress" };
function $b() {
}
$b.prototype.a = null;
function ac(a) {
  var b;
  (b = a.a) || (b = a.a = {});
  return b;
}
function bc() {
}
var L = { OPEN: "a", eb: "b", Ea: "c", qb: "d" };
function cc() {
  y.call(this, "d");
}
r(cc, y);
function dc() {
  y.call(this, "c");
}
r(dc, y);
var ec;
function fc() {
}
r(fc, $b);
ec = new fc();
function M(a, b, c, d) {
  this.g = a;
  this.c = b;
  this.f = c;
  this.S = d || 1;
  this.J = new F(this);
  this.P = gc;
  a = Ia ? 125 : void 0;
  this.R = new Gb(a);
  this.B = null;
  this.b = false;
  this.j = this.l = this.i = this.H = this.u = this.T = this.o = null;
  this.s = [];
  this.a = null;
  this.D = 0;
  this.h = this.m = null;
  this.N = -1;
  this.A = false;
  this.O = 0;
  this.F = null;
  this.V = this.C = this.U = this.I = false;
}
var gc = 45e3;
var hc = {};
var ic = {};
h = M.prototype;
h.setTimeout = function(a) {
  this.P = a;
};
function jc(a, b, c) {
  a.H = 1;
  a.i = kc(N(b));
  a.j = c;
  a.I = true;
  lc(a, null);
}
function lc(a, b) {
  a.u = q();
  mc(a);
  a.l = N(a.i);
  var c = a.l, d = a.S;
  Array.isArray(d) || (d = [String(d)]);
  nc(c.b, "t", d);
  a.D = 0;
  a.a = oc(a.g, a.g.C ? b : null);
  0 < a.O && (a.F = new Kb(p(a.Ca, a, a.a), a.O));
  Mb(a.J, a.a, "readystatechange", a.Xa);
  b = a.B ? Aa(a.B) : {};
  a.j ? (a.m || (a.m = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.a.ba(a.l, a.m, a.j, b)) : (a.m = "GET", a.a.ba(a.l, a.m, null, b));
  I(1);
  Pb(a.c, a.m, a.l, a.f, a.S, a.j);
}
h.Xa = function(a) {
  a = a.target;
  var b = this.F;
  b && 3 == O(a) ? b.f() : this.Ca(a);
};
h.Ca = function(a) {
  try {
    if (a == this.a)
      a: {
        var b = O(this.a), c = this.a.ua(), d = this.a.W();
        if (!(3 > b || 3 == b && !Ia && !this.a.$())) {
          this.A || 4 != b || 7 == c || (8 == c || 0 >= d ? I(3) : I(2));
          pc(this);
          var e = this.a.W();
          this.N = e;
          var f = this.a.$();
          this.b = 200 == e;
          Qb(this.c, this.m, this.l, this.f, this.S, b, e);
          if (this.b) {
            if (this.U && !this.C) {
              b: {
                if (this.a) {
                  var g, m = this.a;
                  if ((g = m.a ? m.a.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(g)) {
                    var l = g;
                    break b;
                  }
                }
                l = null;
              }
              if (l)
                G(this.c, this.f, l, "Initial handshake response via X-HTTP-Initial-Response"), this.C = true, qc(this, l);
              else {
                this.b = false;
                this.h = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.I ? (sc(this, b, f), Ia && this.b && 3 == b && (Mb(this.J, this.R, "tick", this.Wa), this.R.start())) : (G(this.c, this.f, f, null), qc(this, f));
            4 == b && P(this);
            this.b && !this.A && (4 == b ? uc(this.g, this) : (this.b = false, mc(this)));
          } else
            400 == e && 0 < f.indexOf("Unknown SID") ? (this.h = 3, J(12)) : (this.h = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (u) {
  } finally {
  }
};
function sc(a, b, c) {
  for (var d = true; !a.A && a.D < c.length; ) {
    var e = vc(a, c);
    if (e == ic) {
      4 == b && (a.h = 4, J(14), d = false);
      G(a.c, a.f, null, "[Incomplete Response]");
      break;
    } else if (e == hc) {
      a.h = 4;
      J(15);
      G(a.c, a.f, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      G(a.c, a.f, e, null), qc(a, e);
  }
  4 == b && 0 == c.length && (a.h = 1, J(16), d = false);
  a.b = a.b && d;
  d ? 0 < c.length && !a.V && (a.V = true, b = a.g, b.a == a && b.U && !b.F && (b.c.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.F = true, J(11))) : (G(a.c, a.f, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
h.Wa = function() {
  if (this.a) {
    var a = O(this.a), b = this.a.$();
    this.D < b.length && (pc(this), sc(this, a, b), this.b && 4 != a && mc(this));
  }
};
function vc(a, b) {
  var c = a.D, d = b.indexOf("\n", c);
  if (-1 == d)
    return ic;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return hc;
  d += 1;
  if (d + c > b.length)
    return ic;
  b = b.substr(d, c);
  a.D = d + c;
  return b;
}
h.cancel = function() {
  this.A = true;
  P(this);
};
function mc(a) {
  a.T = q() + a.P;
  yc(a, a.P);
}
function yc(a, b) {
  if (null != a.o)
    throw Error("WatchDog timer not null");
  a.o = K(p(a.Va, a), b);
}
function pc(a) {
  a.o && (k.clearTimeout(a.o), a.o = null);
}
h.Va = function() {
  this.o = null;
  var a = q();
  0 <= a - this.T ? (Sb(this.c, this.l), 2 != this.H && (I(3), J(17)), P(this), this.h = 2, rc(this)) : yc(this, this.T - a);
};
function rc(a) {
  0 == a.g.v || a.A || uc(a.g, a);
}
function P(a) {
  pc(a);
  var b = a.F;
  b && "function" == typeof b.ja && b.ja();
  a.F = null;
  Hb(a.R);
  Nb(a.J);
  a.a && (b = a.a, a.a = null, b.abort(), b.ja());
}
function qc(a, b) {
  try {
    var c = a.g;
    if (0 != c.v && (c.a == a || zc(c.b, a))) {
      if (c.I = a.N, !a.C && zc(c.b, a) && 3 == c.v) {
        try {
          var d = c.ka.a.parse(b);
        } catch (tc2) {
          d = null;
        }
        if (Array.isArray(d) && 3 == d.length) {
          var e = d;
          if (0 == e[0])
            a: {
              if (!c.j) {
                if (c.a)
                  if (c.a.u + 3e3 < a.u)
                    Ac(c), Bc(c);
                  else
                    break a;
                Cc(c);
                J(18);
              }
            }
          else
            c.oa = e[1], 0 < c.oa - c.P && 37500 > e[2] && c.H && 0 == c.o && !c.m && (c.m = K(p(c.Sa, c), 6e3));
          if (1 >= Dc(c.b) && c.ea) {
            try {
              c.ea();
            } catch (tc2) {
            }
            c.ea = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.C || c.a == a) && Ac(c), !sa(b))
        for (b = d = c.ka.a.parse(b), d = 0; d < b.length; d++)
          if (e = b[d], c.P = e[0], e = e[1], 2 == c.v)
            if ("c" == e[0]) {
              c.J = e[1];
              c.ga = e[2];
              var f = e[3];
              null != f && (c.ha = f, c.c.info("VER=" + c.ha));
              var g = e[4];
              null != g && (c.pa = g, c.c.info("SVER=" + c.pa));
              var m = e[5];
              if (null != m && "number" === typeof m && 0 < m) {
                var l = 1.5 * m;
                c.D = l;
                c.c.info("backChannelRequestTimeoutMs_=" + l);
              }
              l = c;
              var u = a.a;
              if (u) {
                var C2 = u.a ? u.a.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (C2) {
                  var B2 = l.b;
                  !B2.a && (v(C2, "spdy") || v(C2, "quic") || v(C2, "h2")) && (B2.f = B2.g, B2.a = /* @__PURE__ */ new Set(), B2.b && (Ec(B2, B2.b), B2.b = null));
                }
                if (l.A) {
                  var rb = u.a ? u.a.getResponseHeader("X-HTTP-Session-Id") : null;
                  rb && (l.na = rb, R(l.B, l.A, rb));
                }
              }
              c.v = 3;
              c.f && c.f.ta();
              c.U && (c.N = q() - a.u, c.c.info("Handshake RTT: " + c.N + "ms"));
              l = c;
              var xa2 = a;
              l.la = Fc(l, l.C ? l.ga : null, l.fa);
              if (xa2.C) {
                Gc(l.b, xa2);
                var ya2 = xa2, xc2 = l.D;
                xc2 && ya2.setTimeout(xc2);
                ya2.o && (pc(ya2), mc(ya2));
                l.a = xa2;
              } else
                Hc(l);
              0 < c.g.length && Ic(c);
            } else
              "stop" != e[0] && "close" != e[0] || Q(c, 7);
          else
            3 == c.v && ("stop" == e[0] || "close" == e[0] ? "stop" == e[0] ? Q(c, 7) : Jc(c) : "noop" != e[0] && c.f && c.f.sa(e), c.o = 0);
    }
    I(4);
  } catch (tc2) {
  }
}
function Kc(a) {
  if (a.K && "function" == typeof a.K)
    return a.K();
  if ("string" === typeof a)
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return a = b;
}
function Lc(a, b) {
  if (a.forEach && "function" == typeof a.forEach)
    a.forEach(b, void 0);
  else if (ba(a) || "string" === typeof a)
    na(a, b, void 0);
  else {
    if (a.L && "function" == typeof a.L)
      var c = a.L();
    else if (a.K && "function" == typeof a.K)
      c = void 0;
    else if (ba(a) || "string" === typeof a) {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Kc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.b = {};
  this.a = [];
  this.c = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.L(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
h = S.prototype;
h.K = function() {
  Mc(this);
  for (var a = [], b = 0; b < this.a.length; b++)
    a.push(this.b[this.a[b]]);
  return a;
};
h.L = function() {
  Mc(this);
  return this.a.concat();
};
function Mc(a) {
  if (a.c != a.a.length) {
    for (var b = 0, c = 0; b < a.a.length; ) {
      var d = a.a[b];
      T(a.b, d) && (a.a[c++] = d);
      b++;
    }
    a.a.length = c;
  }
  if (a.c != a.a.length) {
    var e = {};
    for (c = b = 0; b < a.a.length; )
      d = a.a[b], T(e, d) || (a.a[c++] = d, e[d] = 1), b++;
    a.a.length = c;
  }
}
h.get = function(a, b) {
  return T(this.b, a) ? this.b[a] : b;
};
h.set = function(a, b) {
  T(this.b, a) || (this.c++, this.a.push(a));
  this.b[a] = b;
};
h.forEach = function(a, b) {
  for (var c = this.L(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Nc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Oc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.c = this.j = this.f = "";
  this.h = null;
  this.i = this.g = "";
  this.a = false;
  if (a instanceof U) {
    this.a = void 0 !== b ? b : a.a;
    Pc(this, a.f);
    this.j = a.j;
    Qc(this, a.c);
    Rc(this, a.h);
    this.g = a.g;
    b = a.b;
    var c = new Sc();
    c.c = b.c;
    b.a && (c.a = new S(b.a), c.b = b.b);
    Tc(this, c);
    this.i = a.i;
  } else
    a && (c = String(a).match(Nc)) ? (this.a = !!b, Pc(this, c[1] || "", true), this.j = Uc(c[2] || ""), Qc(this, c[3] || "", true), Rc(this, c[4]), this.g = Uc(c[5] || "", true), Tc(this, c[6] || "", true), this.i = Uc(c[7] || "")) : (this.a = !!b, this.b = new Sc(null, this.a));
}
U.prototype.toString = function() {
  var a = [], b = this.f;
  b && a.push(Vc(b, Wc, true), ":");
  var c = this.c;
  if (c || "file" == b)
    a.push("//"), (b = this.j) && a.push(Vc(b, Wc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.h, null != c && a.push(":", String(c));
  if (c = this.g)
    this.c && "/" != c.charAt(0) && a.push("/"), a.push(Vc(c, "/" == c.charAt(0) ? Xc : Yc, true));
  (c = this.b.toString()) && a.push("?", c);
  (c = this.i) && a.push("#", Vc(c, Zc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Pc(a, b, c) {
  a.f = c ? Uc(b, true) : b;
  a.f && (a.f = a.f.replace(/:$/, ""));
}
function Qc(a, b, c) {
  a.c = c ? Uc(b, true) : b;
}
function Rc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.h = b;
  } else
    a.h = null;
}
function Tc(a, b, c) {
  b instanceof Sc ? (a.b = b, $c(a.b, a.a)) : (c || (b = Vc(b, ad)), a.b = new Sc(b, a.a));
}
function R(a, b, c) {
  a.b.set(b, c);
}
function kc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ q()).toString(36));
  return a;
}
function bd(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function cd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Pc(e, a);
  b && Qc(e, b);
  c && Rc(e, c);
  d && (e.g = d);
  return e;
}
function Uc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Vc(a, b, c) {
  return "string" === typeof a ? (a = encodeURI(a).replace(b, dd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function dd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Wc = /[#\/\?@]/g;
var Yc = /[#\?:]/g;
var Xc = /[#\?]/g;
var ad = /[#\?@]/g;
var Zc = /#/g;
function Sc(a, b) {
  this.b = this.a = null;
  this.c = a || null;
  this.f = !!b;
}
function V(a) {
  a.a || (a.a = new S(), a.b = 0, a.c && Oc(a.c, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
h = Sc.prototype;
h.add = function(a, b) {
  V(this);
  this.c = null;
  a = W(this, a);
  var c = this.a.get(a);
  c || this.a.set(a, c = []);
  c.push(b);
  this.b += 1;
  return this;
};
function ed(a, b) {
  V(a);
  b = W(a, b);
  T(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, a = a.a, T(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && Mc(a)));
}
function fd(a, b) {
  V(a);
  b = W(a, b);
  return T(a.a.b, b);
}
h.forEach = function(a, b) {
  V(this);
  this.a.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
h.L = function() {
  V(this);
  for (var a = this.a.K(), b = this.a.L(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
h.K = function(a) {
  V(this);
  var b = [];
  if ("string" === typeof a)
    fd(this, a) && (b = qa(b, this.a.get(W(this, a))));
  else {
    a = this.a.K();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
h.set = function(a, b) {
  V(this);
  this.c = null;
  a = W(this, a);
  fd(this, a) && (this.b -= this.a.get(a).length);
  this.a.set(a, [b]);
  this.b += 1;
  return this;
};
h.get = function(a, b) {
  if (!a)
    return b;
  a = this.K(a);
  return 0 < a.length ? String(a[0]) : b;
};
function nc(a, b, c) {
  ed(a, b);
  0 < c.length && (a.c = null, a.a.set(W(a, b), ra(c)), a.b += c.length);
}
h.toString = function() {
  if (this.c)
    return this.c;
  if (!this.a)
    return "";
  for (var a = [], b = this.a.L(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.K(d);
    for (var f = 0; f < d.length; f++) {
      var g = e;
      "" !== d[f] && (g += "=" + encodeURIComponent(String(d[f])));
      a.push(g);
    }
  }
  return this.c = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.f && (b = b.toLowerCase());
  return b;
}
function $c(a, b) {
  b && !a.f && (V(a), a.c = null, a.a.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (ed(this, d), nc(this, e, c));
  }, a));
  a.f = b;
}
var gd = (
  /** @class */
  /* @__PURE__ */ function() {
    function gd2(a, b) {
      this.b = a;
      this.a = b;
    }
    return gd2;
  }()
);
function hd(a) {
  this.g = a || id;
  k.PerformanceNavigationTiming ? (a = k.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(k.ia && k.ia.ya && k.ia.ya() && k.ia.ya().Lb);
  this.f = a ? this.g : 1;
  this.a = null;
  1 < this.f && (this.a = /* @__PURE__ */ new Set());
  this.b = null;
  this.c = [];
}
var id = 10;
function jd(a) {
  return a.b ? true : a.a ? a.a.size >= a.f : false;
}
function Dc(a) {
  return a.b ? 1 : a.a ? a.a.size : 0;
}
function zc(a, b) {
  return a.b ? a.b == b : a.a ? a.a.has(b) : false;
}
function Ec(a, b) {
  a.a ? a.a.add(b) : a.b = b;
}
function Gc(a, b) {
  a.b && a.b == b ? a.b = null : a.a && a.a.has(b) && a.a.delete(b);
}
hd.prototype.cancel = function() {
  var e_1, _a9;
  this.c = kd(this);
  if (this.b)
    this.b.cancel(), this.b = null;
  else if (this.a && 0 !== this.a.size) {
    try {
      for (var _b = __values2(this.a.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var a = _c2.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a9 = _b.return))
          _a9.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.a.clear();
  }
};
function kd(a) {
  var e_2, _a9;
  if (null != a.b)
    return a.c.concat(a.b.s);
  if (null != a.a && 0 !== a.a.size) {
    var b = a.c;
    try {
      for (var _b = __values2(a.a.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var c = _c2.value;
        b = b.concat(c.s);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a9 = _b.return))
          _a9.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b;
  }
  return ra(a.c);
}
function ld() {
}
ld.prototype.stringify = function(a) {
  return k.JSON.stringify(a, void 0);
};
ld.prototype.parse = function(a) {
  return k.JSON.parse(a, void 0);
};
function md() {
  this.a = new ld();
}
function nd(a, b, c) {
  var d = c || "";
  try {
    Lc(a, function(e, f) {
      var g = e;
      n(e) && (g = ub(e));
      b.push(d + f + "=" + encodeURIComponent(g));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function od(a, b) {
  var c = new Ob();
  if (k.Image) {
    var d = new Image();
    d.onload = ja(pd, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(pd, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(pd, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(pd, c, d, "TestLoadImage: timeout", false, b);
    k.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function pd(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
var qd = k.JSON.parse;
function X(a) {
  D.call(this);
  this.headers = new S();
  this.H = a || null;
  this.b = false;
  this.s = this.a = null;
  this.B = "";
  this.h = 0;
  this.f = "";
  this.g = this.A = this.l = this.u = false;
  this.o = 0;
  this.m = null;
  this.I = rd;
  this.D = this.F = false;
}
r(X, D);
var rd = "";
var sd = /^https?$/i;
var td = ["POST", "PUT"];
h = X.prototype;
h.ba = function(a, b, c, d) {
  if (this.a)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.B + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.B = a;
  this.f = "";
  this.h = 0;
  this.u = false;
  this.b = true;
  this.a = new XMLHttpRequest();
  this.s = this.H ? ac(this.H) : ac(ec);
  this.a.onreadystatechange = p(this.za, this);
  try {
    this.A = true, this.a.open(b, String(a), true), this.A = false;
  } catch (f) {
    ud(this, f);
    return;
  }
  a = c || "";
  var e = new S(this.headers);
  d && Lc(d, function(f, g) {
    e.set(g, f);
  });
  d = oa(e.L());
  c = k.FormData && a instanceof k.FormData;
  !(0 <= ma(td, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, g) {
    this.a.setRequestHeader(g, f);
  }, this);
  this.I && (this.a.responseType = this.I);
  "withCredentials" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);
  try {
    vd(this), 0 < this.o && ((this.D = wd(this.a)) ? (this.a.timeout = this.o, this.a.ontimeout = p(this.xa, this)) : this.m = Ib(this.xa, this.o, this)), this.l = true, this.a.send(a), this.l = false;
  } catch (f) {
    ud(this, f);
  }
};
function wd(a) {
  return x && Qa(9) && "number" === typeof a.timeout && void 0 !== a.ontimeout;
}
function pa(a) {
  return "content-type" == a.toLowerCase();
}
h.xa = function() {
  "undefined" != typeof goog && this.a && (this.f = "Timed out after " + this.o + "ms, aborting", this.h = 8, E(this, "timeout"), this.abort(8));
};
function ud(a, b) {
  a.b = false;
  a.a && (a.g = true, a.a.abort(), a.g = false);
  a.f = b;
  a.h = 5;
  xd(a);
  yd(a);
}
function xd(a) {
  a.u || (a.u = true, E(a, "complete"), E(a, "error"));
}
h.abort = function(a) {
  this.a && this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false, this.h = a || 7, E(this, "complete"), E(this, "abort"), yd(this));
};
h.G = function() {
  this.a && (this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false), yd(this, true));
  X.X.G.call(this);
};
h.za = function() {
  this.j || (this.A || this.l || this.g ? zd(this) : this.Ua());
};
h.Ua = function() {
  zd(this);
};
function zd(a) {
  if (a.b && "undefined" != typeof goog && (!a.s[1] || 4 != O(a) || 2 != a.W())) {
    if (a.l && 4 == O(a))
      Ib(a.za, 0, a);
    else if (E(a, "readystatechange"), 4 == O(a)) {
      a.b = false;
      try {
        {
          var l = a.W();
          a:
            switch (l) {
              case 200:
              case 201:
              case 202:
              case 204:
              case 206:
              case 304:
              case 1223:
                var b = true;
                break a;
              default:
                b = false;
            }
          var c;
          if (!(c = b)) {
            var d;
            if (d = 0 === l) {
              var e = String(a.B).match(Nc)[1] || null;
              if (!e && k.self && k.self.location) {
                var f = k.self.location.protocol;
                e = f.substr(0, f.length - 1);
              }
              d = !sd.test(e ? e.toLowerCase() : "");
            }
            c = d;
          }
          var g = c;
        }
        if (g)
          E(a, "complete"), E(a, "success");
        else {
          a.h = 6;
          try {
            var m = 2 < O(a) ? a.a.statusText : "";
          } catch (l2) {
            m = "";
          }
          a.f = m + " [" + a.W() + "]";
          xd(a);
        }
      } finally {
        yd(a);
      }
    }
  }
}
function yd(a, b) {
  if (a.a) {
    vd(a);
    var c = a.a, d = a.s[0] ? aa : null;
    a.a = null;
    a.s = null;
    b || E(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function vd(a) {
  a.a && a.D && (a.a.ontimeout = null);
  a.m && (k.clearTimeout(a.m), a.m = null);
}
function O(a) {
  return a.a ? a.a.readyState : 0;
}
h.W = function() {
  try {
    return 2 < O(this) ? this.a.status : -1;
  } catch (a) {
    return -1;
  }
};
h.$ = function() {
  try {
    return this.a ? this.a.responseText : "";
  } catch (a) {
    return "";
  }
};
h.Pa = function(a) {
  if (this.a) {
    var b = this.a.responseText;
    a && 0 == b.indexOf(a) && (b = b.substring(a.length));
    return qd(b);
  }
};
h.ua = function() {
  return this.h;
};
h.Qa = function() {
  return "string" === typeof this.f ? this.f : String(this.f);
};
function Ad(a) {
  var b = "";
  za(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Bd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Ad(c), "string" === typeof a ? null != c && encodeURIComponent(String(c)) : R(a, b, c));
}
function Cd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Dd(a) {
  this.pa = 0;
  this.g = [];
  this.c = new Ob();
  this.ga = this.la = this.B = this.fa = this.a = this.na = this.A = this.V = this.i = this.O = this.l = null;
  this.Oa = this.R = 0;
  this.La = Cd("failFast", false, a);
  this.H = this.m = this.j = this.h = this.f = null;
  this.S = true;
  this.I = this.oa = this.P = -1;
  this.T = this.o = this.u = 0;
  this.Ha = Cd("baseRetryDelayMs", 5e3, a);
  this.Ra = Cd("retryDelaySeedMs", 1e4, a);
  this.Ma = Cd("forwardChannelMaxRetries", 2, a);
  this.ma = Cd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.Na = a && a.g || void 0;
  this.D = void 0;
  this.C = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.b = new hd(a && a.concurrentRequestLimit);
  this.ka = new md();
  this.da = a && a.fastHandshake || false;
  this.Ia = a && a.b || false;
  a && a.f && (this.c.a = false);
  a && a.forceLongPolling && (this.S = false);
  this.U = !this.da && this.S && a && a.detectBufferingProxy || false;
  this.ea = void 0;
  this.N = 0;
  this.F = false;
  this.s = null;
  (this.Ka = a && a.c || false) && this.c.info("Opt-in to enable Chrome Origin Trials.");
}
h = Dd.prototype;
h.ha = 8;
h.v = 1;
function Jc(a) {
  Ed(a);
  if (3 == a.v) {
    var b = a.R++, c = N(a.B);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Fd(a, c);
    b = new M(a, a.c, b, void 0);
    b.H = 2;
    b.i = kc(N(c));
    c = false;
    k.navigator && k.navigator.sendBeacon && (c = k.navigator.sendBeacon(b.i.toString(), ""));
    !c && k.Image && (new Image().src = b.i, c = true);
    c || (b.a = oc(b.g, null), b.a.ba(b.i));
    b.u = q();
    mc(b);
  }
  Gd(a);
}
function Bc(a) {
  a.a && (wc(a), a.a.cancel(), a.a = null);
}
function Ed(a) {
  Bc(a);
  a.j && (k.clearTimeout(a.j), a.j = null);
  Ac(a);
  a.b.cancel();
  a.h && ("number" === typeof a.h && k.clearTimeout(a.h), a.h = null);
}
function Hd(a, b) {
  a.g.push(new gd(a.Oa++, b));
  3 == a.v && Ic(a);
}
function Ic(a) {
  jd(a.b) || a.h || (a.h = true, Bb(a.Ba, a), a.u = 0);
}
function Id(a, b) {
  if (Dc(a.b) >= a.b.f - (a.h ? 1 : 0))
    return false;
  if (a.h)
    return a.g = b.s.concat(a.g), true;
  if (1 == a.v || 2 == a.v || a.u >= (a.La ? 0 : a.Ma))
    return false;
  a.h = K(p(a.Ba, a, b), Jd(a, a.u));
  a.u++;
  return true;
}
h.Ba = function(a) {
  if (this.h)
    if (this.h = null, 1 == this.v) {
      if (!a) {
        this.R = Math.floor(1e5 * Math.random());
        a = this.R++;
        var b = new M(this, this.c, a, void 0), c = this.l;
        this.O && (c ? (c = Aa(c), Ca(c, this.O)) : c = this.O);
        null === this.i && (b.B = c);
        var d;
        if (this.da)
          a: {
            for (var e = d = 0; e < this.g.length; e++) {
              b: {
                var f = this.g[e];
                if ("__data__" in f.a && (f = f.a.__data__, "string" === typeof f)) {
                  f = f.length;
                  break b;
                }
                f = void 0;
              }
              if (void 0 === f)
                break;
              d += f;
              if (4096 < d) {
                d = e;
                break a;
              }
              if (4096 === d || e === this.g.length - 1) {
                d = e + 1;
                break a;
              }
            }
            d = 1e3;
          }
        else
          d = 1e3;
        d = Kd(this, b, d);
        e = N(this.B);
        R(e, "RID", a);
        R(e, "CVER", 22);
        this.A && R(e, "X-HTTP-Session-Id", this.A);
        Fd(this, e);
        this.i && c && Bd(e, this.i, c);
        Ec(this.b, b);
        this.Ia && R(e, "TYPE", "init");
        this.da ? (R(e, "$req", d), R(e, "SID", "null"), b.U = true, jc(b, e, null)) : jc(b, e, d);
        this.v = 2;
      }
    } else
      3 == this.v && (a ? Ld(this, a) : 0 == this.g.length || jd(this.b) || Ld(this));
};
function Ld(a, b) {
  var c;
  b ? c = b.f : c = a.R++;
  var d = N(a.B);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.P);
  Fd(a, d);
  a.i && a.l && Bd(d, a.i, a.l);
  c = new M(a, a.c, c, a.u + 1);
  null === a.i && (c.B = a.l);
  b && (a.g = b.s.concat(a.g));
  b = Kd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ma) + Math.round(0.5 * a.ma * Math.random()));
  Ec(a.b, c);
  jc(c, d, b);
}
function Fd(a, b) {
  a.f && Lc({}, function(c, d) {
    R(b, d, c);
  });
}
function Kd(a, b, c) {
  c = Math.min(a.g.length, c);
  var d = a.f ? p(a.f.Ja, a.f, a) : null;
  a:
    for (var e = a.g, f = -1; ; ) {
      var g = ["count=" + c];
      -1 == f ? 0 < c ? (f = e[0].b, g.push("ofs=" + f)) : f = 0 : g.push("ofs=" + f);
      for (var m = true, l = 0; l < c; l++) {
        var u = e[l].b, C2 = e[l].a;
        u -= f;
        if (0 > u)
          f = Math.max(0, e[l].b - 100), m = false;
        else
          try {
            nd(C2, g, "req" + u + "_");
          } catch (B2) {
            d && d(C2);
          }
      }
      if (m) {
        d = g.join("&");
        break a;
      }
    }
  a = a.g.splice(0, c);
  b.s = a;
  return d;
}
function Hc(a) {
  a.a || a.j || (a.T = 1, Bb(a.Aa, a), a.o = 0);
}
function Cc(a) {
  if (a.a || a.j || 3 <= a.o)
    return false;
  a.T++;
  a.j = K(p(a.Aa, a), Jd(a, a.o));
  a.o++;
  return true;
}
h.Aa = function() {
  this.j = null;
  Md(this);
  if (this.U && !(this.F || null == this.a || 0 >= this.N)) {
    var a = 2 * this.N;
    this.c.info("BP detection timer enabled: " + a);
    this.s = K(p(this.Ta, this), a);
  }
};
h.Ta = function() {
  this.s && (this.s = null, this.c.info("BP detection timeout reached."), this.c.info("Buffering proxy detected and switch to long-polling!"), this.H = false, this.F = true, J(10), Bc(this), Md(this));
};
function wc(a) {
  null != a.s && (k.clearTimeout(a.s), a.s = null);
}
function Md(a) {
  a.a = new M(a, a.c, "rpc", a.T);
  null === a.i && (a.a.B = a.l);
  a.a.O = 0;
  var b = N(a.la);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.H ? "0" : "1");
  R(b, "AID", a.P);
  Fd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.i && a.l && Bd(b, a.i, a.l);
  a.D && a.a.setTimeout(a.D);
  var c = a.a;
  a = a.ga;
  c.H = 1;
  c.i = kc(N(b));
  c.j = null;
  c.I = true;
  lc(c, a);
}
h.Sa = function() {
  null != this.m && (this.m = null, Bc(this), Cc(this), J(19));
};
function Ac(a) {
  null != a.m && (k.clearTimeout(a.m), a.m = null);
}
function uc(a, b) {
  var c = null;
  if (a.a == b) {
    Ac(a);
    wc(a);
    a.a = null;
    var d = 2;
  } else if (zc(a.b, b))
    c = b.s, Gc(a.b, b), d = 1;
  else
    return;
  a.I = b.N;
  if (0 != a.v) {
    if (b.b)
      if (1 == d) {
        c = b.j ? b.j.length : 0;
        b = q() - b.u;
        var e = a.u;
        d = Ub();
        E(d, new Xb(d, c, b, e));
        Ic(a);
      } else
        Hc(a);
    else if (e = b.h, 3 == e || 0 == e && 0 < a.I || !(1 == d && Id(a, b) || 2 == d && Cc(a)))
      switch (c && 0 < c.length && (b = a.b, b.c = b.c.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Jd(a, b) {
  var c = a.Ha + Math.floor(Math.random() * a.Ra);
  a.f || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.c.info("Error code " + b);
  if (2 == b) {
    var c = null;
    a.f && (c = null);
    var d = p(a.Ya, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), k.location && "http" == k.location.protocol || Pc(c, "https"), kc(c));
    od(c.toString(), d);
  } else
    J(2);
  a.v = 0;
  a.f && a.f.ra(b);
  Gd(a);
  Ed(a);
}
h.Ya = function(a) {
  a ? (this.c.info("Successfully pinged google.com"), J(2)) : (this.c.info("Failed to ping google.com"), J(1));
};
function Gd(a) {
  a.v = 0;
  a.I = -1;
  if (a.f) {
    if (0 != kd(a.b).length || 0 != a.g.length)
      a.b.c.length = 0, ra(a.g), a.g.length = 0;
    a.f.qa();
  }
}
function Fc(a, b, c) {
  var d = bd(c);
  if ("" != d.c)
    b && Qc(d, b + "." + d.c), Rc(d, d.h);
  else {
    var e = k.location;
    d = cd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.V && za(a.V, function(f, g) {
    R(d, g, f);
  });
  b = a.A;
  c = a.na;
  b && c && R(d, b, c);
  R(d, "VER", a.ha);
  Fd(a, d);
  return d;
}
function oc(a, b) {
  if (b && !a.C)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = new X(a.Na);
  b.F = a.C;
  return b;
}
function Nd() {
}
h = Nd.prototype;
h.ta = function() {
};
h.sa = function() {
};
h.ra = function() {
};
h.qa = function() {
};
h.Ja = function() {
};
function Od() {
  if (x && !(10 <= Number(Ta)))
    throw Error("Environmental error: no available transport.");
}
Od.prototype.a = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  D.call(this);
  this.a = new Dd(b);
  this.o = a;
  this.b = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.a.l = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.a && (a ? a["X-WebChannel-Client-Profile"] = b.a : a = { "X-WebChannel-Client-Profile": b.a });
  this.a.O = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.a.i = a);
  this.m = b && b.supportsCrossDomainXhr || false;
  this.l = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.a.A = b, a = this.b, null !== a && b in a && (a = this.b, b in a && delete a[b]));
  this.f = new Z(this);
}
r(Y, D);
Y.prototype.g = function() {
  this.a.f = this.f;
  this.m && (this.a.C = true);
  var a = this.a, b = this.o, c = this.b || void 0;
  J(0);
  a.fa = b;
  a.V = c || {};
  a.H = a.S;
  a.B = Fc(a, null, a.fa);
  Ic(a);
};
Y.prototype.close = function() {
  Jc(this.a);
};
Y.prototype.h = function(a) {
  if ("string" === typeof a) {
    var b = {};
    b.__data__ = a;
    Hd(this.a, b);
  } else
    this.l ? (b = {}, b.__data__ = ub(a), Hd(this.a, b)) : Hd(this.a, a);
};
Y.prototype.G = function() {
  this.a.f = null;
  delete this.f;
  Jc(this.a);
  delete this.a;
  Y.X.G.call(this);
};
function Pd(a) {
  cc.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (var c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    (this.c = a) ? (a = this.c, this.data = null !== b && a in b ? b[a] : void 0) : this.data = b;
  } else
    this.data = a;
}
r(Pd, cc);
function Qd() {
  dc.call(this);
  this.status = 1;
}
r(Qd, dc);
function Z(a) {
  this.a = a;
}
r(Z, Nd);
Z.prototype.ta = function() {
  E(this.a, "a");
};
Z.prototype.sa = function(a) {
  E(this.a, new Pd(a));
};
Z.prototype.ra = function(a) {
  E(this.a, new Qd(a));
};
Z.prototype.qa = function() {
  E(this.a, "b");
};
Od.prototype.createWebChannel = Od.prototype.a;
Y.prototype.send = Y.prototype.h;
Y.prototype.open = Y.prototype.g;
Y.prototype.close = Y.prototype.close;
Yb.NO_ERROR = 0;
Yb.TIMEOUT = 8;
Yb.HTTP_ERROR = 6;
Zb.COMPLETE = "complete";
bc.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
D.prototype.listen = D.prototype.va;
X.prototype.listenOnce = X.prototype.wa;
X.prototype.getLastError = X.prototype.Qa;
X.prototype.getLastErrorCode = X.prototype.ua;
X.prototype.getStatus = X.prototype.W;
X.prototype.getResponseJson = X.prototype.Pa;
X.prototype.getResponseText = X.prototype.$;
X.prototype.send = X.prototype.ba;
var createWebChannelTransport = function() {
  return new Od();
};
var getStatEventTarget = function() {
  return Ub();
};
var ErrorCode = Yb;
var EventType = Zb;
var Event = H;
var Stat = { gb: 0, jb: 1, kb: 2, Db: 3, Ib: 4, Fb: 5, Gb: 6, Eb: 7, Cb: 8, Hb: 9, PROXY: 10, NOPROXY: 11, Ab: 12, wb: 13, xb: 14, vb: 15, yb: 16, zb: 17, bb: 18, ab: 19, cb: 20 };
var WebChannel = bc;
var XhrIo = X;

// node_modules/@firebase/firestore/dist/esm5/prebuilt-7525c6cb-cb60b4b9.js
var I2 = (
  /** @class */
  function() {
    function t3(t4, e) {
      var n2 = this;
      this.previousValue = t4, e && (e.sequenceNumberHandler = function(t5) {
        return n2.t(t5);
      }, this.i = function(t5) {
        return e.writeSequenceNumber(t5);
      });
    }
    return t3.prototype.t = function(t4) {
      return this.previousValue = Math.max(t4, this.previousValue), this.previousValue;
    }, t3.prototype.next = function() {
      var t4 = ++this.previousValue;
      return this.i && this.i(t4), t4;
    }, t3;
  }()
);
I2.o = -1;
var E2 = new Logger("@firebase/firestore");
function T2() {
  return E2.logLevel;
}
function _(t3) {
  for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
    n2[r2 - 1] = arguments[r2];
  if (E2.logLevel <= LogLevel.DEBUG) {
    var i = n2.map(N2);
    E2.debug.apply(E2, __spreadArray(["Firestore (8.3.1): " + t3], i));
  }
}
function S2(t3) {
  for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
    n2[r2 - 1] = arguments[r2];
  if (E2.logLevel <= LogLevel.ERROR) {
    var i = n2.map(N2);
    E2.error.apply(E2, __spreadArray(["Firestore (8.3.1): " + t3], i));
  }
}
function D2(t3) {
  for (var n2 = [], r2 = 1; r2 < arguments.length; r2++)
    n2[r2 - 1] = arguments[r2];
  if (E2.logLevel <= LogLevel.WARN) {
    var i = n2.map(N2);
    E2.warn.apply(E2, __spreadArray(["Firestore (8.3.1): " + t3], i));
  }
}
function N2(t3) {
  if ("string" == typeof t3)
    return t3;
  try {
    return e = t3, JSON.stringify(e);
  } catch (e2) {
    return t3;
  }
  var e;
}
function A2(t3) {
  void 0 === t3 && (t3 = "Unexpected state");
  var e = "FIRESTORE (8.3.1) INTERNAL ASSERTION FAILED: " + t3;
  throw S2(e), new Error(e);
}
function k2(t3, e) {
  t3 || A2();
}
function C(t3, e) {
  return t3;
}
function x2(t3) {
  var e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "undefined" != typeof self && (self.crypto || self.msCrypto)
  ), n2 = new Uint8Array(t3);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n2);
  else
    for (var r2 = 0; r2 < t3; r2++)
      n2[r2] = Math.floor(256 * Math.random());
  return n2;
}
var L2 = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.u = function() {
      for (var t4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t4.length) * t4.length, n2 = ""; n2.length < 20; )
        for (var r2 = x2(40), i = 0; i < r2.length; ++i)
          n2.length < 20 && r2[i] < e && (n2 += t4.charAt(r2[i] % t4.length));
      return n2;
    }, t3;
  }()
);
function R2(t3, e) {
  return t3 < e ? -1 : t3 > e ? 1 : 0;
}
function O2(t3, e, n2) {
  return t3.length === e.length && t3.every(function(t4, r2) {
    return n2(t4, e[r2]);
  });
}
function P2(t3) {
  return t3 + "\0";
}
function M2(t3) {
  var e = 0;
  for (var n2 in t3)
    Object.prototype.hasOwnProperty.call(t3, n2) && e++;
  return e;
}
function F2(t3, e) {
  for (var n2 in t3)
    Object.prototype.hasOwnProperty.call(t3, n2) && e(n2, t3[n2]);
}
function q2(t3) {
  for (var e in t3)
    if (Object.prototype.hasOwnProperty.call(t3, e))
      return false;
  return true;
}
function V2(t3) {
  return null == t3;
}
function U2(t3) {
  return 0 === t3 && 1 / t3 == -1 / 0;
}
function B(t3) {
  return "number" == typeof t3 && Number.isInteger(t3) && !U2(t3) && t3 <= Number.MAX_SAFE_INTEGER && t3 >= Number.MIN_SAFE_INTEGER;
}
var j = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller can not be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
var G2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this).code = e2, r2.message = n2, r2.name = "FirebaseError", // HACK: We write a toString property directly because Error is not a real
      // class and so inheritance does not work correctly. We could alternatively
      // do the same "back-door inheritance" trick that FirebaseError does.
      r2.toString = function() {
        return r2.name + ": [code=" + r2.code + "]: " + r2.message;
      }, r2;
    }
    return __extends(e, t3), e;
  }(Error)
);
var K2 = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      void 0 === e ? e = 0 : e > t4.length && A2(), void 0 === n2 ? n2 = t4.length - e : n2 > t4.length - e && A2(), this.segments = t4, this.offset = e, this.len = n2;
    }
    return Object.defineProperty(t3.prototype, "length", {
      get: function() {
        return this.len;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.isEqual = function(e) {
      return 0 === t3.comparator(this, e);
    }, t3.prototype.child = function(e) {
      var n2 = this.segments.slice(this.offset, this.limit());
      return e instanceof t3 ? e.forEach(function(t4) {
        n2.push(t4);
      }) : n2.push(e), this.construct(n2);
    }, /** The index of one past the last segment of the path. */
    t3.prototype.limit = function() {
      return this.offset + this.length;
    }, t3.prototype.popFirst = function(t4) {
      return t4 = void 0 === t4 ? 1 : t4, this.construct(this.segments, this.offset + t4, this.length - t4);
    }, t3.prototype.popLast = function() {
      return this.construct(this.segments, this.offset, this.length - 1);
    }, t3.prototype.firstSegment = function() {
      return this.segments[this.offset];
    }, t3.prototype.lastSegment = function() {
      return this.get(this.length - 1);
    }, t3.prototype.get = function(t4) {
      return this.segments[this.offset + t4];
    }, t3.prototype.isEmpty = function() {
      return 0 === this.length;
    }, t3.prototype.isPrefixOf = function(t4) {
      if (t4.length < this.length)
        return false;
      for (var e = 0; e < this.length; e++)
        if (this.get(e) !== t4.get(e))
          return false;
      return true;
    }, t3.prototype.isImmediateParentOf = function(t4) {
      if (this.length + 1 !== t4.length)
        return false;
      for (var e = 0; e < this.length; e++)
        if (this.get(e) !== t4.get(e))
          return false;
      return true;
    }, t3.prototype.forEach = function(t4) {
      for (var e = this.offset, n2 = this.limit(); e < n2; e++)
        t4(this.segments[e]);
    }, t3.prototype.toArray = function() {
      return this.segments.slice(this.offset, this.limit());
    }, t3.comparator = function(t4, e) {
      for (var n2 = Math.min(t4.length, e.length), r2 = 0; r2 < n2; r2++) {
        var i = t4.get(r2), o = e.get(r2);
        if (i < o)
          return -1;
        if (i > o)
          return 1;
      }
      return t4.length < e.length ? -1 : t4.length > e.length ? 1 : 0;
    }, t3;
  }()
);
var z2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.construct = function(t4, n2, r2) {
      return new e(t4, n2, r2);
    }, e.prototype.canonicalString = function() {
      return this.toArray().join("/");
    }, e.prototype.toString = function() {
      return this.canonicalString();
    }, /**
     * Creates a resource path from the given slash-delimited string. If multiple
     * arguments are provided, all components are combined. Leading and trailing
     * slashes from all components are ignored.
     */
    e.fromString = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      for (var r2 = [], i = 0, o = t4; i < o.length; i++) {
        var s = o[i];
        if (s.indexOf("//") >= 0)
          throw new G2(j.INVALID_ARGUMENT, "Invalid segment (" + s + "). Paths must not contain // in them.");
        r2.push.apply(r2, s.split("/").filter(function(t5) {
          return t5.length > 0;
        }));
      }
      return new e(r2);
    }, e.emptyPath = function() {
      return new e([]);
    }, e;
  }(K2)
);
var Q2 = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var W2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.construct = function(t4, n2, r2) {
      return new e(t4, n2, r2);
    }, /**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */
    e.isValidIdentifier = function(t4) {
      return Q2.test(t4);
    }, e.prototype.canonicalString = function() {
      return this.toArray().map(function(t4) {
        return t4 = t4.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), e.isValidIdentifier(t4) || (t4 = "`" + t4 + "`"), t4;
      }).join(".");
    }, e.prototype.toString = function() {
      return this.canonicalString();
    }, /**
     * Returns true if this field references the key of a document.
     */
    e.prototype.isKeyField = function() {
      return 1 === this.length && "__name__" === this.get(0);
    }, /**
     * The field designating the key of a document.
     */
    e.keyField = function() {
      return new e(["__name__"]);
    }, /**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */
    e.fromServerFormat = function(t4) {
      for (var n2 = [], r2 = "", i = 0, o = function() {
        if (0 === r2.length)
          throw new G2(j.INVALID_ARGUMENT, "Invalid field path (" + t4 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
        n2.push(r2), r2 = "";
      }, s = false; i < t4.length; ) {
        var u = t4[i];
        if ("\\" === u) {
          if (i + 1 === t4.length)
            throw new G2(j.INVALID_ARGUMENT, "Path has trailing escape character: " + t4);
          var a = t4[i + 1];
          if ("\\" !== a && "." !== a && "`" !== a)
            throw new G2(j.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t4);
          r2 += a, i += 2;
        } else
          "`" === u ? (s = !s, i++) : "." !== u || s ? (r2 += u, i++) : (o(), i++);
      }
      if (o(), s)
        throw new G2(j.INVALID_ARGUMENT, "Unterminated ` in path: " + t4);
      return new e(n2);
    }, e.emptyPath = function() {
      return new e([]);
    }, e;
  }(K2)
);
var H2 = (
  /** @class */
  function() {
    function t3(t4) {
      this.path = t4;
    }
    return t3.fromPath = function(e) {
      return new t3(z2.fromString(e));
    }, t3.fromName = function(e) {
      return new t3(z2.fromString(e).popFirst(5));
    }, /** Returns true if the document is in the specified collectionId. */
    t3.prototype.hasCollectionId = function(t4) {
      return this.path.length >= 2 && this.path.get(this.path.length - 2) === t4;
    }, t3.prototype.isEqual = function(t4) {
      return null !== t4 && 0 === z2.comparator(this.path, t4.path);
    }, t3.prototype.toString = function() {
      return this.path.toString();
    }, t3.comparator = function(t4, e) {
      return z2.comparator(t4.path, e.path);
    }, t3.isDocumentKey = function(t4) {
      return t4.length % 2 == 0;
    }, /**
     * Creates and returns a new document key with the given segments.
     *
     * @param segments - The segments of the path to the document
     * @returns A new instance of DocumentKey
     */
    t3.fromSegments = function(e) {
      return new t3(new z2(e.slice()));
    }, t3;
  }()
);
var Y2 = (
  /** @class */
  function() {
    function t3(t4) {
      this.binaryString = t4;
    }
    return t3.fromBase64String = function(e) {
      return new t3(atob(e));
    }, t3.fromUint8Array = function(e) {
      return new t3(
        /**
        * Helper function to convert an Uint8array to a binary string.
        */
        function(t4) {
          for (var e2 = "", n2 = 0; n2 < t4.length; ++n2)
            e2 += String.fromCharCode(t4[n2]);
          return e2;
        }(e)
      );
    }, t3.prototype.toBase64 = function() {
      return t4 = this.binaryString, btoa(t4);
      var t4;
    }, t3.prototype.toUint8Array = function() {
      return function(t4) {
        for (var e = new Uint8Array(t4.length), n2 = 0; n2 < t4.length; n2++)
          e[n2] = t4.charCodeAt(n2);
        return e;
      }(this.binaryString);
    }, t3.prototype.approximateByteSize = function() {
      return 2 * this.binaryString.length;
    }, t3.prototype.compareTo = function(t4) {
      return R2(this.binaryString, t4.binaryString);
    }, t3.prototype.isEqual = function(t4) {
      return this.binaryString === t4.binaryString;
    }, t3;
  }()
);
Y2.EMPTY_BYTE_STRING = new Y2("");
var J2 = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function X2(t3) {
  if (k2(!!t3), "string" == typeof t3) {
    var e = 0, n2 = J2.exec(t3);
    if (k2(!!n2), n2[1]) {
      var r2 = n2[1];
      r2 = (r2 + "000000000").substr(0, 9), e = Number(r2);
    }
    var i = new Date(t3);
    return {
      seconds: Math.floor(i.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: $(t3.seconds),
    nanos: $(t3.nanos)
  };
}
function $(t3) {
  return "number" == typeof t3 ? t3 : "string" == typeof t3 ? Number(t3) : 0;
}
function Z2(t3) {
  return "string" == typeof t3 ? Y2.fromBase64String(t3) : Y2.fromUint8Array(t3);
}
var tt = (
  /** @class */
  function() {
    function t3(t4, e) {
      if (this.seconds = t4, this.nanoseconds = e, e < 0)
        throw new G2(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
      if (e >= 1e9)
        throw new G2(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
      if (t4 < -62135596800)
        throw new G2(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t4);
      if (t4 >= 253402300800)
        throw new G2(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t4);
    }
    return t3.now = function() {
      return t3.fromMillis(Date.now());
    }, /**
     * Creates a new timestamp from the given date.
     *
     * @param date - The date to initialize the `Timestamp` from.
     * @returns A new `Timestamp` representing the same point in time as the given
     *     date.
     */
    t3.fromDate = function(e) {
      return t3.fromMillis(e.getTime());
    }, /**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @param milliseconds - Number of milliseconds since Unix epoch
     *     1970-01-01T00:00:00Z.
     * @returns A new `Timestamp` representing the same point in time as the given
     *     number of milliseconds.
     */
    t3.fromMillis = function(e) {
      var n2 = Math.floor(e / 1e3);
      return new t3(n2, 1e6 * (e - 1e3 * n2));
    }, /**
     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion causes
     * a loss of precision since `Date` objects only support millisecond precision.
     *
     * @returns JavaScript `Date` object representing the same point in time as
     *     this `Timestamp`, with millisecond precision.
     */
    t3.prototype.toDate = function() {
      return new Date(this.toMillis());
    }, /**
     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
     * epoch). This operation causes a loss of precision.
     *
     * @returns The point in time corresponding to this timestamp, represented as
     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     */
    t3.prototype.toMillis = function() {
      return 1e3 * this.seconds + this.nanoseconds / 1e6;
    }, t3.prototype._compareTo = function(t4) {
      return this.seconds === t4.seconds ? R2(this.nanoseconds, t4.nanoseconds) : R2(this.seconds, t4.seconds);
    }, /**
     * Returns true if this `Timestamp` is equal to the provided one.
     *
     * @param other - The `Timestamp` to compare against.
     * @returns true if this `Timestamp` is equal to the provided one.
     */
    t3.prototype.isEqual = function(t4) {
      return t4.seconds === this.seconds && t4.nanoseconds === this.nanoseconds;
    }, t3.prototype.toString = function() {
      return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
    }, t3.prototype.toJSON = function() {
      return {
        seconds: this.seconds,
        nanoseconds: this.nanoseconds
      };
    }, /**
     * Converts this object to a primitive string, which allows Timestamp objects to be compared
     * using the `>`, `<=`, `>=` and `>` operators.
     */
    t3.prototype.valueOf = function() {
      var t4 = this.seconds - -62135596800;
      return String(t4).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
    }, t3;
  }()
);
function et(t3) {
  var e, n2;
  return "server_timestamp" === (null === (n2 = ((null === (e = null == t3 ? void 0 : t3.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n2 ? void 0 : n2.stringValue);
}
function nt(t3) {
  var e = t3.mapValue.fields.__previous_value__;
  return et(e) ? nt(e) : e;
}
function rt(t3) {
  var e = X2(t3.mapValue.fields.__local_write_time__.timestampValue);
  return new tt(e.seconds, e.nanos);
}
function it(t3) {
  return "nullValue" in t3 ? 0 : "booleanValue" in t3 ? 1 : "integerValue" in t3 || "doubleValue" in t3 ? 2 : "timestampValue" in t3 ? 3 : "stringValue" in t3 ? 5 : "bytesValue" in t3 ? 6 : "referenceValue" in t3 ? 7 : "geoPointValue" in t3 ? 8 : "arrayValue" in t3 ? 9 : "mapValue" in t3 ? et(t3) ? 4 : 10 : A2();
}
function ot(t3, e) {
  var n2 = it(t3);
  if (n2 !== it(e))
    return false;
  switch (n2) {
    case 0:
      return true;
    case 1:
      return t3.booleanValue === e.booleanValue;
    case 4:
      return rt(t3).isEqual(rt(e));
    case 3:
      return function(t4, e2) {
        if ("string" == typeof t4.timestampValue && "string" == typeof e2.timestampValue && t4.timestampValue.length === e2.timestampValue.length)
          return t4.timestampValue === e2.timestampValue;
        var n3 = X2(t4.timestampValue), r2 = X2(e2.timestampValue);
        return n3.seconds === r2.seconds && n3.nanos === r2.nanos;
      }(t3, e);
    case 5:
      return t3.stringValue === e.stringValue;
    case 6:
      return function(t4, e2) {
        return Z2(t4.bytesValue).isEqual(Z2(e2.bytesValue));
      }(t3, e);
    case 7:
      return t3.referenceValue === e.referenceValue;
    case 8:
      return function(t4, e2) {
        return $(t4.geoPointValue.latitude) === $(e2.geoPointValue.latitude) && $(t4.geoPointValue.longitude) === $(e2.geoPointValue.longitude);
      }(t3, e);
    case 2:
      return function(t4, e2) {
        if ("integerValue" in t4 && "integerValue" in e2)
          return $(t4.integerValue) === $(e2.integerValue);
        if ("doubleValue" in t4 && "doubleValue" in e2) {
          var n3 = $(t4.doubleValue), r2 = $(e2.doubleValue);
          return n3 === r2 ? U2(n3) === U2(r2) : isNaN(n3) && isNaN(r2);
        }
        return false;
      }(t3, e);
    case 9:
      return O2(t3.arrayValue.values || [], e.arrayValue.values || [], ot);
    case 10:
      return function(t4, e2) {
        var n3 = t4.mapValue.fields || {}, r2 = e2.mapValue.fields || {};
        if (M2(n3) !== M2(r2))
          return false;
        for (var i in n3)
          if (n3.hasOwnProperty(i) && (void 0 === r2[i] || !ot(n3[i], r2[i])))
            return false;
        return true;
      }(t3, e);
    default:
      return A2();
  }
}
function st(t3, e) {
  return void 0 !== (t3.values || []).find(function(t4) {
    return ot(t4, e);
  });
}
function ut(t3, e) {
  var n2 = it(t3), r2 = it(e);
  if (n2 !== r2)
    return R2(n2, r2);
  switch (n2) {
    case 0:
      return 0;
    case 1:
      return R2(t3.booleanValue, e.booleanValue);
    case 2:
      return function(t4, e2) {
        var n3 = $(t4.integerValue || t4.doubleValue), r3 = $(e2.integerValue || e2.doubleValue);
        return n3 < r3 ? -1 : n3 > r3 ? 1 : n3 === r3 ? 0 : (
          // one or both are NaN.
          isNaN(n3) ? isNaN(r3) ? 0 : -1 : 1
        );
      }(t3, e);
    case 3:
      return at(t3.timestampValue, e.timestampValue);
    case 4:
      return at(rt(t3), rt(e));
    case 5:
      return R2(t3.stringValue, e.stringValue);
    case 6:
      return function(t4, e2) {
        var n3 = Z2(t4), r3 = Z2(e2);
        return n3.compareTo(r3);
      }(t3.bytesValue, e.bytesValue);
    case 7:
      return function(t4, e2) {
        for (var n3 = t4.split("/"), r3 = e2.split("/"), i = 0; i < n3.length && i < r3.length; i++) {
          var o = R2(n3[i], r3[i]);
          if (0 !== o)
            return o;
        }
        return R2(n3.length, r3.length);
      }(t3.referenceValue, e.referenceValue);
    case 8:
      return function(t4, e2) {
        var n3 = R2($(t4.latitude), $(e2.latitude));
        return 0 !== n3 ? n3 : R2($(t4.longitude), $(e2.longitude));
      }(t3.geoPointValue, e.geoPointValue);
    case 9:
      return function(t4, e2) {
        for (var n3 = t4.values || [], r3 = e2.values || [], i = 0; i < n3.length && i < r3.length; ++i) {
          var o = ut(n3[i], r3[i]);
          if (o)
            return o;
        }
        return R2(n3.length, r3.length);
      }(t3.arrayValue, e.arrayValue);
    case 10:
      return function(t4, e2) {
        var n3 = t4.fields || {}, r3 = Object.keys(n3), i = e2.fields || {}, o = Object.keys(i);
        r3.sort(), o.sort();
        for (var s = 0; s < r3.length && s < o.length; ++s) {
          var u = R2(r3[s], o[s]);
          if (0 !== u)
            return u;
          var a = ut(n3[r3[s]], i[o[s]]);
          if (0 !== a)
            return a;
        }
        return R2(r3.length, o.length);
      }(t3.mapValue, e.mapValue);
    default:
      throw A2();
  }
}
function at(t3, e) {
  if ("string" == typeof t3 && "string" == typeof e && t3.length === e.length)
    return R2(t3, e);
  var n2 = X2(t3), r2 = X2(e), i = R2(n2.seconds, r2.seconds);
  return 0 !== i ? i : R2(n2.nanos, r2.nanos);
}
function ct(t3) {
  return ht(t3);
}
function ht(t3) {
  return "nullValue" in t3 ? "null" : "booleanValue" in t3 ? "" + t3.booleanValue : "integerValue" in t3 ? "" + t3.integerValue : "doubleValue" in t3 ? "" + t3.doubleValue : "timestampValue" in t3 ? function(t4) {
    var e2 = X2(t4);
    return "time(" + e2.seconds + "," + e2.nanos + ")";
  }(t3.timestampValue) : "stringValue" in t3 ? t3.stringValue : "bytesValue" in t3 ? Z2(t3.bytesValue).toBase64() : "referenceValue" in t3 ? (n2 = t3.referenceValue, H2.fromName(n2).toString()) : "geoPointValue" in t3 ? "geo(" + (e = t3.geoPointValue).latitude + "," + e.longitude + ")" : "arrayValue" in t3 ? function(t4) {
    for (var e2 = "[", n3 = true, r2 = 0, i = t4.values || []; r2 < i.length; r2++) {
      n3 ? n3 = false : e2 += ",", e2 += ht(i[r2]);
    }
    return e2 + "]";
  }(t3.arrayValue) : "mapValue" in t3 ? function(t4) {
    for (var e2 = "{", n3 = true, r2 = 0, i = Object.keys(t4.fields || {}).sort(); r2 < i.length; r2++) {
      var o = i[r2];
      n3 ? n3 = false : e2 += ",", e2 += o + ":" + ht(t4.fields[o]);
    }
    return e2 + "}";
  }(t3.mapValue) : A2();
  var e, n2;
}
function ft(t3, e) {
  return {
    referenceValue: "projects/" + t3.projectId + "/databases/" + t3.database + "/documents/" + e.path.canonicalString()
  };
}
function lt(t3) {
  return !!t3 && "integerValue" in t3;
}
function dt(t3) {
  return !!t3 && "arrayValue" in t3;
}
function pt(t3) {
  return !!t3 && "nullValue" in t3;
}
function yt(t3) {
  return !!t3 && "doubleValue" in t3 && isNaN(Number(t3.doubleValue));
}
function vt(t3) {
  return !!t3 && "mapValue" in t3;
}
var mt = function(t3, e) {
  this.key = t3, this.version = e;
};
var gt = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i) {
      var o = this;
      return (o = t3.call(this, e2, n2) || this).objectValue = r2, o.hasLocalMutations = !!i.hasLocalMutations, o.hasCommittedMutations = !!i.hasCommittedMutations, o;
    }
    return __extends(e, t3), e.prototype.field = function(t4) {
      return this.objectValue.field(t4);
    }, e.prototype.data = function() {
      return this.objectValue;
    }, e.prototype.toProto = function() {
      return this.objectValue.proto;
    }, e.prototype.isEqual = function(t4) {
      return t4 instanceof e && this.key.isEqual(t4.key) && this.version.isEqual(t4.version) && this.hasLocalMutations === t4.hasLocalMutations && this.hasCommittedMutations === t4.hasCommittedMutations && this.objectValue.isEqual(t4.objectValue);
    }, e.prototype.toString = function() {
      return "Document(" + this.key + ", " + this.version + ", " + this.objectValue.toString() + ", {hasLocalMutations: " + this.hasLocalMutations + "}), {hasCommittedMutations: " + this.hasCommittedMutations + "})";
    }, Object.defineProperty(e.prototype, "hasPendingWrites", {
      get: function() {
        return this.hasLocalMutations || this.hasCommittedMutations;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(mt)
);
var wt = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this, e2, n2) || this).hasCommittedMutations = !(!r2 || !r2.hasCommittedMutations), i;
    }
    return __extends(e, t3), e.prototype.toString = function() {
      return "NoDocument(" + this.key + ", " + this.version + ")";
    }, Object.defineProperty(e.prototype, "hasPendingWrites", {
      get: function() {
        return this.hasCommittedMutations;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.isEqual = function(t4) {
      return t4 instanceof e && t4.hasCommittedMutations === this.hasCommittedMutations && t4.version.isEqual(this.version) && t4.key.isEqual(this.key);
    }, e;
  }(mt)
);
var bt = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.toString = function() {
      return "UnknownDocument(" + this.key + ", " + this.version + ")";
    }, Object.defineProperty(e.prototype, "hasPendingWrites", {
      get: function() {
        return true;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.isEqual = function(t4) {
      return t4 instanceof e && t4.version.isEqual(this.version) && t4.key.isEqual(this.key);
    }, e;
  }(mt)
);
var It = function(t3, e, n2, r2, i, o, s) {
  void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = null), this.path = t3, this.collectionGroup = e, this.orderBy = n2, this.filters = r2, this.limit = i, this.startAt = o, this.endAt = s, this.h = null;
};
function Et(t3, e, n2, r2, i, o, s) {
  return void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = null), new It(t3, e, n2, r2, i, o, s);
}
function Tt(t3) {
  var e = C(t3);
  if (null === e.h) {
    var n2 = e.path.canonicalString();
    null !== e.collectionGroup && (n2 += "|cg:" + e.collectionGroup), n2 += "|f:", n2 += e.filters.map(function(t4) {
      return function(t5) {
        return t5.field.canonicalString() + t5.op.toString() + ct(t5.value);
      }(t4);
    }).join(","), n2 += "|ob:", n2 += e.orderBy.map(function(t4) {
      return function(t5) {
        return t5.field.canonicalString() + t5.dir;
      }(t4);
    }).join(","), V2(e.limit) || (n2 += "|l:", n2 += e.limit), e.startAt && (n2 += "|lb:", n2 += Mt(e.startAt)), e.endAt && (n2 += "|ub:", n2 += Mt(e.endAt)), e.h = n2;
  }
  return e.h;
}
function _t(t3, e) {
  if (t3.limit !== e.limit)
    return false;
  if (t3.orderBy.length !== e.orderBy.length)
    return false;
  for (var n2 = 0; n2 < t3.orderBy.length; n2++)
    if (!qt(t3.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t3.filters.length !== e.filters.length)
    return false;
  for (var r2 = 0; r2 < t3.filters.length; r2++)
    if (i = t3.filters[r2], o = e.filters[r2], i.op !== o.op || !i.field.isEqual(o.field) || !ot(i.value, o.value))
      return false;
  var i, o;
  return t3.collectionGroup === e.collectionGroup && !!t3.path.isEqual(e.path) && !!Ut(t3.startAt, e.startAt) && Ut(t3.endAt, e.endAt);
}
function St(t3) {
  return H2.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
}
var Dt = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).field = e2, i.op = n2, i.value = r2, i;
    }
    return __extends(e, t3), e.create = function(t4, n2, r2) {
      return t4.isKeyField() ? "in" === n2 || "not-in" === n2 ? this.l(t4, n2, r2) : new Nt(t4, n2, r2) : "array-contains" === n2 ? new xt(t4, r2) : "in" === n2 ? new Lt(t4, r2) : "not-in" === n2 ? new Rt(t4, r2) : "array-contains-any" === n2 ? new Ot(t4, r2) : new e(t4, n2, r2);
    }, e.l = function(t4, e2, n2) {
      return "in" === e2 ? new At(t4, n2) : new kt(t4, n2);
    }, e.prototype.matches = function(t4) {
      var e2 = t4.field(this.field);
      return "!=" === this.op ? null !== e2 && this.m(ut(e2, this.value)) : null !== e2 && it(this.value) === it(e2) && this.m(ut(e2, this.value));
    }, e.prototype.m = function(t4) {
      switch (this.op) {
        case "<":
          return t4 < 0;
        case "<=":
          return t4 <= 0;
        case "==":
          return 0 === t4;
        case "!=":
          return 0 !== t4;
        case ">":
          return t4 > 0;
        case ">=":
          return t4 >= 0;
        default:
          return A2();
      }
    }, e.prototype.g = function() {
      return [
        "<",
        "<=",
        ">",
        ">=",
        "!=",
        "not-in"
        /* NOT_IN */
      ].indexOf(this.op) >= 0;
    }, e;
  }(function() {
  })
);
var Nt = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this, e2, n2, r2) || this).key = H2.fromName(r2.referenceValue), i;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      var e2 = H2.comparator(t4.key, this.key);
      return this.m(e2);
    }, e;
  }(Dt)
);
var At = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2, "in", n2) || this).keys = Ct("in", n2), r2;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      return this.keys.some(function(e2) {
        return e2.isEqual(t4.key);
      });
    }, e;
  }(Dt)
);
var kt = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2, "not-in", n2) || this).keys = Ct("not-in", n2), r2;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      return !this.keys.some(function(e2) {
        return e2.isEqual(t4.key);
      });
    }, e;
  }(Dt)
);
function Ct(t3, e) {
  var n2;
  return ((null === (n2 = e.arrayValue) || void 0 === n2 ? void 0 : n2.values) || []).map(function(t4) {
    return H2.fromName(t4.referenceValue);
  });
}
var xt = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      return t3.call(this, e2, "array-contains", n2) || this;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      var e2 = t4.field(this.field);
      return dt(e2) && st(e2.arrayValue, this.value);
    }, e;
  }(Dt)
);
var Lt = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      return t3.call(this, e2, "in", n2) || this;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      var e2 = t4.field(this.field);
      return null !== e2 && st(this.value.arrayValue, e2);
    }, e;
  }(Dt)
);
var Rt = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      return t3.call(this, e2, "not-in", n2) || this;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      if (st(this.value.arrayValue, {
        nullValue: "NULL_VALUE"
      }))
        return false;
      var e2 = t4.field(this.field);
      return null !== e2 && !st(this.value.arrayValue, e2);
    }, e;
  }(Dt)
);
var Ot = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      return t3.call(this, e2, "array-contains-any", n2) || this;
    }
    return __extends(e, t3), e.prototype.matches = function(t4) {
      var e2 = this, n2 = t4.field(this.field);
      return !(!dt(n2) || !n2.arrayValue.values) && n2.arrayValue.values.some(function(t5) {
        return st(e2.value.arrayValue, t5);
      });
    }, e;
  }(Dt)
);
var Pt = function(t3, e) {
  this.position = t3, this.before = e;
};
function Mt(t3) {
  return (t3.before ? "b" : "a") + ":" + t3.position.map(function(t4) {
    return ct(t4);
  }).join(",");
}
var Ft = function(t3, e) {
  void 0 === e && (e = "asc"), this.field = t3, this.dir = e;
};
function qt(t3, e) {
  return t3.dir === e.dir && t3.field.isEqual(e.field);
}
function Vt(t3, e, n2) {
  for (var r2 = 0, i = 0; i < t3.position.length; i++) {
    var o = e[i], s = t3.position[i];
    if (r2 = o.field.isKeyField() ? H2.comparator(H2.fromName(s.referenceValue), n2.key) : ut(s, n2.field(o.field)), "desc" === o.dir && (r2 *= -1), 0 !== r2)
      break;
  }
  return t3.before ? r2 <= 0 : r2 < 0;
}
function Ut(t3, e) {
  if (null === t3)
    return null === e;
  if (null === e)
    return false;
  if (t3.before !== e.before || t3.position.length !== e.position.length)
    return false;
  for (var n2 = 0; n2 < t3.position.length; n2++)
    if (!ot(t3.position[n2], e.position[n2]))
      return false;
  return true;
}
var Bt = (
  /**
       * Initializes a Query with a path and optional additional query constraints.
       * Path must currently be empty if this is a collection group query.
       */
  function(t3, e, n2, r2, i, o, s, u) {
    void 0 === e && (e = null), void 0 === n2 && (n2 = []), void 0 === r2 && (r2 = []), void 0 === i && (i = null), void 0 === o && (o = "F"), void 0 === s && (s = null), void 0 === u && (u = null), this.path = t3, this.collectionGroup = e, this.explicitOrderBy = n2, this.filters = r2, this.limit = i, this.limitType = o, this.startAt = s, this.endAt = u, this.p = null, // The corresponding `Target` of this `Query` instance.
    this.T = null, this.startAt, this.endAt;
  }
);
function jt(t3, e, n2, r2, i, o, s, u) {
  return new Bt(t3, e, n2, r2, i, o, s, u);
}
function Gt(t3) {
  return new Bt(t3);
}
function Kt(t3) {
  return !V2(t3.limit) && "F" === t3.limitType;
}
function zt(t3) {
  return !V2(t3.limit) && "L" === t3.limitType;
}
function Qt(t3) {
  return t3.explicitOrderBy.length > 0 ? t3.explicitOrderBy[0].field : null;
}
function Wt(t3) {
  for (var e = 0, n2 = t3.filters; e < n2.length; e++) {
    var r2 = n2[e];
    if (r2.g())
      return r2.field;
  }
  return null;
}
function Ht(t3) {
  return null !== t3.collectionGroup;
}
function Yt(t3) {
  var e = C(t3);
  if (null === e.p) {
    e.p = [];
    var n2 = Wt(e), r2 = Qt(e);
    if (null !== n2 && null === r2)
      n2.isKeyField() || e.p.push(new Ft(n2)), e.p.push(new Ft(
        W2.keyField(),
        "asc"
        /* ASCENDING */
      ));
    else {
      for (var i = false, o = 0, s = e.explicitOrderBy; o < s.length; o++) {
        var u = s[o];
        e.p.push(u), u.field.isKeyField() && (i = true);
      }
      if (!i) {
        var a = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.p.push(new Ft(W2.keyField(), a));
      }
    }
  }
  return e.p;
}
function Jt(t3) {
  var e = C(t3);
  if (!e.T)
    if ("F" === e.limitType)
      e.T = Et(e.path, e.collectionGroup, Yt(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      for (var n2 = [], r2 = 0, i = Yt(e); r2 < i.length; r2++) {
        var o = i[r2], s = "desc" === o.dir ? "asc" : "desc";
        n2.push(new Ft(o.field, s));
      }
      var u = e.endAt ? new Pt(e.endAt.position, !e.endAt.before) : null, a = e.startAt ? new Pt(e.startAt.position, !e.startAt.before) : null;
      e.T = Et(e.path, e.collectionGroup, n2, e.filters, e.limit, u, a);
    }
  return e.T;
}
function Xt(t3, e, n2) {
  return new Bt(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), e, n2, t3.startAt, t3.endAt);
}
function $t(t3, e) {
  return _t(Jt(t3), Jt(e)) && t3.limitType === e.limitType;
}
function Zt(t3) {
  return Tt(Jt(t3)) + "|lt:" + t3.limitType;
}
function te(t3) {
  return "Query(target=" + function(t4) {
    var e = t4.path.canonicalString();
    return null !== t4.collectionGroup && (e += " collectionGroup=" + t4.collectionGroup), t4.filters.length > 0 && (e += ", filters: [" + t4.filters.map(function(t5) {
      return (e2 = t5).field.canonicalString() + " " + e2.op + " " + ct(e2.value);
      var e2;
    }).join(", ") + "]"), V2(t4.limit) || (e += ", limit: " + t4.limit), t4.orderBy.length > 0 && (e += ", orderBy: [" + t4.orderBy.map(function(t5) {
      return function(t6) {
        return t6.field.canonicalString() + " (" + t6.dir + ")";
      }(t5);
    }).join(", ") + "]"), t4.startAt && (e += ", startAt: " + Mt(t4.startAt)), t4.endAt && (e += ", endAt: " + Mt(t4.endAt)), "Target(" + e + ")";
  }(Jt(t3)) + "; limitType=" + t3.limitType + ")";
}
function ee(t3, e) {
  return function(t4, e2) {
    var n2 = e2.key.path;
    return null !== t4.collectionGroup ? e2.key.hasCollectionId(t4.collectionGroup) && t4.path.isPrefixOf(n2) : H2.isDocumentKey(t4.path) ? t4.path.isEqual(n2) : t4.path.isImmediateParentOf(n2);
  }(t3, e) && function(t4, e2) {
    for (var n2 = 0, r2 = t4.explicitOrderBy; n2 < r2.length; n2++) {
      var i = r2[n2];
      if (!i.field.isKeyField() && null === e2.field(i.field))
        return false;
    }
    return true;
  }(t3, e) && function(t4, e2) {
    for (var n2 = 0, r2 = t4.filters; n2 < r2.length; n2++) {
      if (!r2[n2].matches(e2))
        return false;
    }
    return true;
  }(t3, e) && function(t4, e2) {
    return !(t4.startAt && !Vt(t4.startAt, Yt(t4), e2)) && (!t4.endAt || !Vt(t4.endAt, Yt(t4), e2));
  }(t3, e);
}
function ne(t3) {
  return function(e, n2) {
    for (var r2 = false, i = 0, o = Yt(t3); i < o.length; i++) {
      var s = o[i], u = re(s, e, n2);
      if (0 !== u)
        return u;
      r2 = r2 || s.field.isKeyField();
    }
    return 0;
  };
}
function re(t3, e, n2) {
  var r2 = t3.field.isKeyField() ? H2.comparator(e.key, n2.key) : function(t4, e2, n3) {
    var r3 = e2.field(t4), i = n3.field(t4);
    return null !== r3 && null !== i ? ut(r3, i) : A2();
  }(t3.field, e, n2);
  switch (t3.dir) {
    case "asc":
      return r2;
    case "desc":
      return -1 * r2;
    default:
      return A2();
  }
}
var ie = (
  /** @class */
  function() {
    function t3(t4) {
      this.timestamp = t4;
    }
    return t3.fromTimestamp = function(e) {
      return new t3(e);
    }, t3.min = function() {
      return new t3(new tt(0, 0));
    }, t3.prototype.compareTo = function(t4) {
      return this.timestamp._compareTo(t4.timestamp);
    }, t3.prototype.isEqual = function(t4) {
      return this.timestamp.isEqual(t4.timestamp);
    }, /** Returns a number representation of the version for use in spec tests. */
    t3.prototype.toMicroseconds = function() {
      return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
    }, t3.prototype.toString = function() {
      return "SnapshotVersion(" + this.timestamp.toString() + ")";
    }, t3.prototype.toTimestamp = function() {
      return this.timestamp;
    }, t3;
  }()
);
var oe = (
  /** @class */
  function() {
    function t3(t4) {
      this.fields = t4, // TODO(dimond): validation of FieldMask
      // Sort the field mask to support `FieldMask.isEqual()` and assert below.
      t4.sort(W2.comparator);
    }
    return t3.prototype.covers = function(t4) {
      for (var e = 0, n2 = this.fields; e < n2.length; e++) {
        if (n2[e].isPrefixOf(t4))
          return true;
      }
      return false;
    }, t3.prototype.isEqual = function(t4) {
      return O2(this.fields, t4.fields, function(t5, e) {
        return t5.isEqual(e);
      });
    }, t3;
  }()
);
var se = (
  /** @class */
  function() {
    function t3(t4) {
      this.proto = t4;
    }
    return t3.empty = function() {
      return new t3({
        mapValue: {}
      });
    }, /**
     * Returns the value at the given path or null.
     *
     * @param path - the path to search
     * @returns The value at the path or if there it doesn't exist.
     */
    t3.prototype.field = function(t4) {
      if (t4.isEmpty())
        return this.proto;
      for (var e = this.proto, n2 = 0; n2 < t4.length - 1; ++n2) {
        if (!e.mapValue.fields)
          return null;
        if (!vt(e = e.mapValue.fields[t4.get(n2)]))
          return null;
      }
      return (e = (e.mapValue.fields || {})[t4.lastSegment()]) || null;
    }, t3.prototype.isEqual = function(t4) {
      return ot(this.proto, t4.proto);
    }, t3;
  }()
);
var ue = (
  /** @class */
  function() {
    function t3(t4) {
      void 0 === t4 && (t4 = se.empty()), this.I = t4, /** A map that contains the accumulated changes in this builder. */
      this.A = /* @__PURE__ */ new Map();
    }
    return t3.prototype.set = function(t4, e) {
      return this.R(t4, e), this;
    }, /**
     * Removes the field at the specified path. If there is no field at the
     * specified path, nothing is changed.
     *
     * @param path - The field path to remove.
     * @returns The current Builder instance.
     */
    t3.prototype.delete = function(t4) {
      return this.R(t4, null), this;
    }, /**
     * Adds `value` to the overlay map at `path`. Creates nested map entries if
     * needed.
     */
    t3.prototype.R = function(t4, e) {
      for (var n2 = this.A, r2 = 0; r2 < t4.length - 1; ++r2) {
        var i = t4.get(r2), o = n2.get(i);
        o instanceof Map ? (
          // Re-use a previously created map
          n2 = o
        ) : o && 10 === it(o) ? (
          // Convert the existing Protobuf MapValue into a map
          (o = new Map(Object.entries(o.mapValue.fields || {})), n2.set(i, o), n2 = o)
        ) : (
          // Create an empty map to represent the current nesting level
          (o = /* @__PURE__ */ new Map(), n2.set(i, o), n2 = o)
        );
      }
      n2.set(t4.lastSegment(), e);
    }, /** Returns an ObjectValue with all mutations applied. */
    t3.prototype.v = function() {
      var t4 = this.P(W2.emptyPath(), this.A);
      return null != t4 ? new se(t4) : this.I;
    }, /**
     * Applies any overlays from `currentOverlays` that exist at `currentPath`
     * and returns the merged data at `currentPath` (or null if there were no
     * changes).
     *
     * @param currentPath - The path at the current nesting level. Can be set to
     * FieldValue.emptyPath() to represent the root.
     * @param currentOverlays - The overlays at the current nesting level in the
     * same format as `overlayMap`.
     * @returns The merged data at `currentPath` or null if no modifications
     * were applied.
     */
    t3.prototype.P = function(t4, e) {
      var n2 = this, r2 = false, i = this.I.field(t4), o = vt(i) ? (
        // If there is already data at the current path, base our
        Object.assign({}, i.mapValue.fields)
      ) : {};
      return e.forEach(function(e2, i2) {
        if (e2 instanceof Map) {
          var s = n2.P(t4.child(i2), e2);
          null != s && (o[i2] = s, r2 = true);
        } else
          null !== e2 ? (o[i2] = e2, r2 = true) : o.hasOwnProperty(i2) && (delete o[i2], r2 = true);
      }), r2 ? {
        mapValue: {
          fields: o
        }
      } : null;
    }, t3;
  }()
);
function ae(t3) {
  var e = [];
  return F2(t3.fields || {}, function(t4, n2) {
    var r2 = new W2([t4]);
    if (vt(n2)) {
      var i = ae(n2.mapValue).fields;
      if (0 === i.length)
        e.push(r2);
      else
        for (var o = 0, s = i; o < s.length; o++) {
          var u = s[o];
          e.push(r2.child(u));
        }
    } else
      e.push(r2);
  }), new oe(e);
}
function ce(t3, e) {
  if (t3.V) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: U2(e) ? "-0" : e
  };
}
function he(t3) {
  return {
    integerValue: "" + t3
  };
}
function fe(t3, e) {
  return B(e) ? he(e) : ce(t3, e);
}
var le = function() {
  this._ = void 0;
};
function de(t3, e, n2) {
  return t3 instanceof ve ? function(t4, e2) {
    var n3 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t4.seconds,
            nanos: t4.nanoseconds
          }
        }
      }
    };
    return e2 && (n3.fields.__previous_value__ = e2), {
      mapValue: n3
    };
  }(n2, e) : t3 instanceof me ? ge(t3, e) : t3 instanceof we ? be(t3, e) : function(t4, e2) {
    var n3 = ye(t4, e2), r2 = Ee(n3) + Ee(t4.S);
    return lt(n3) && lt(t4.S) ? he(r2) : ce(t4.D, r2);
  }(t3, e);
}
function pe(t3, e, n2) {
  return t3 instanceof me ? ge(t3, e) : t3 instanceof we ? be(t3, e) : n2;
}
function ye(t3, e) {
  return t3 instanceof Ie ? lt(n2 = e) || function(t4) {
    return !!t4 && "doubleValue" in t4;
  }(n2) ? e : {
    integerValue: 0
  } : null;
  var n2;
}
var ve = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e;
  }(le)
);
var me = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).elements = e2, n2;
    }
    return __extends(e, t3), e;
  }(le)
);
function ge(t3, e) {
  for (var n2 = Te(e), r2 = function(t4) {
    n2.some(function(e2) {
      return ot(e2, t4);
    }) || n2.push(t4);
  }, i = 0, o = t3.elements; i < o.length; i++) {
    r2(o[i]);
  }
  return {
    arrayValue: {
      values: n2
    }
  };
}
var we = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).elements = e2, n2;
    }
    return __extends(e, t3), e;
  }(le)
);
function be(t3, e) {
  for (var n2 = Te(e), r2 = function(t4) {
    n2 = n2.filter(function(e2) {
      return !ot(e2, t4);
    });
  }, i = 0, o = t3.elements; i < o.length; i++) {
    r2(o[i]);
  }
  return {
    arrayValue: {
      values: n2
    }
  };
}
var Ie = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).D = e2, r2.S = n2, r2;
    }
    return __extends(e, t3), e;
  }(le)
);
function Ee(t3) {
  return $(t3.integerValue || t3.doubleValue);
}
function Te(t3) {
  return dt(t3) && t3.arrayValue.values ? t3.arrayValue.values.slice() : [];
}
var _e = function(t3, e) {
  this.field = t3, this.transform = e;
};
var Se = function(t3, e) {
  this.version = t3, this.transformResults = e;
};
var De = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.updateTime = t4, this.exists = e;
    }
    return t3.none = function() {
      return new t3();
    }, /** Creates a new Precondition with an exists flag. */
    t3.exists = function(e) {
      return new t3(void 0, e);
    }, /** Creates a new Precondition based on a version a document exists at. */
    t3.updateTime = function(e) {
      return new t3(e);
    }, Object.defineProperty(t3.prototype, "isNone", {
      /** Returns whether this Precondition is empty. */
      get: function() {
        return void 0 === this.updateTime && void 0 === this.exists;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.isEqual = function(t4) {
      return this.exists === t4.exists && (this.updateTime ? !!t4.updateTime && this.updateTime.isEqual(t4.updateTime) : !t4.updateTime);
    }, t3;
  }()
);
function Ne(t3, e) {
  return void 0 !== t3.updateTime ? e instanceof gt && e.version.isEqual(t3.updateTime) : void 0 === t3.exists || t3.exists === e instanceof gt;
}
var Ae = function() {
};
function ke(t3, e, n2) {
  return t3 instanceof Oe ? function(t4, e2, n3) {
    var r2 = t4.value, i = Fe(t4.fieldTransforms, e2, n3.transformResults);
    return r2 = Ve(t4.fieldTransforms, r2, i), new gt(t4.key, n3.version, r2, {
      hasCommittedMutations: true
    });
  }(t3, e, n2) : t3 instanceof Pe ? function(t4, e2, n3) {
    if (!Ne(t4.precondition, e2))
      return new bt(t4.key, n3.version);
    var r2 = Me(t4, e2, Fe(t4.fieldTransforms, e2, n3.transformResults));
    return new gt(t4.key, n3.version, r2, {
      hasCommittedMutations: true
    });
  }(t3, e, n2) : function(t4, e2, n3) {
    return new wt(t4.key, n3.version, {
      hasCommittedMutations: true
    });
  }(t3, 0, n2);
}
function Ce(t3, e, n2) {
  return t3 instanceof Oe ? function(t4, e2, n3) {
    if (!Ne(t4.precondition, e2))
      return e2;
    var r2 = t4.value, i = qe(t4.fieldTransforms, n3, e2);
    r2 = Ve(t4.fieldTransforms, r2, i);
    var o = Re(e2);
    return new gt(t4.key, o, r2, {
      hasLocalMutations: true
    });
  }(t3, e, n2) : t3 instanceof Pe ? function(t4, e2, n3) {
    if (!Ne(t4.precondition, e2))
      return e2;
    var r2 = Re(e2), i = Me(t4, e2, qe(t4.fieldTransforms, n3, e2));
    return new gt(t4.key, r2, i, {
      hasLocalMutations: true
    });
  }(t3, e, n2) : function(t4, e2) {
    return Ne(t4.precondition, e2) ? new wt(t4.key, ie.min()) : e2;
  }(t3, e);
}
function xe(t3, e) {
  return function(t4, e2) {
    for (var n2 = null, r2 = 0, i = t4; r2 < i.length; r2++) {
      var o = i[r2], s = e2 instanceof gt ? e2.field(o.field) : void 0, u = ye(o.transform, s || null);
      null != u && (n2 = null == n2 ? new ue().set(o.field, u) : n2.set(o.field, u));
    }
    return n2 ? n2.v() : null;
  }(t3.fieldTransforms, e);
}
function Le(t3, e) {
  return t3.type === e.type && !!t3.key.isEqual(e.key) && !!t3.precondition.isEqual(e.precondition) && !!function(t4, e2) {
    return void 0 === t4 && void 0 === e2 || !(!t4 || !e2) && O2(t4, e2, function(t5, e3) {
      return function(t6, e4) {
        return t6.field.isEqual(e4.field) && function(t7, e5) {
          return t7 instanceof me && e5 instanceof me || t7 instanceof we && e5 instanceof we ? O2(t7.elements, e5.elements, ot) : t7 instanceof Ie && e5 instanceof Ie ? ot(t7.S, e5.S) : t7 instanceof ve && e5 instanceof ve;
        }(t6.transform, e4.transform);
      }(t5, e3);
    });
  }(t3.fieldTransforms, e.fieldTransforms) && (0 === t3.type ? t3.value.isEqual(e.value) : 1 !== t3.type || t3.data.isEqual(e.data) && t3.fieldMask.isEqual(e.fieldMask));
}
function Re(t3) {
  return t3 instanceof gt ? t3.version : ie.min();
}
var Oe = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i) {
      void 0 === i && (i = []);
      var o = this;
      return (o = t3.call(this) || this).key = e2, o.value = n2, o.precondition = r2, o.fieldTransforms = i, o.type = 0, o;
    }
    return __extends(e, t3), e;
  }(Ae)
);
var Pe = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i, o) {
      void 0 === o && (o = []);
      var s = this;
      return (s = t3.call(this) || this).key = e2, s.data = n2, s.fieldMask = r2, s.precondition = i, s.fieldTransforms = o, s.type = 1, s;
    }
    return __extends(e, t3), e;
  }(Ae)
);
function Me(t3, e, n2) {
  var r2;
  return r2 = function(t4, e2) {
    var n3 = new ue(e2);
    return t4.fieldMask.fields.forEach(function(e3) {
      if (!e3.isEmpty()) {
        var r3 = t4.data.field(e3);
        null !== r3 ? n3.set(e3, r3) : n3.delete(e3);
      }
    }), n3.v();
  }(t3, r2 = e instanceof gt ? e.data() : se.empty()), r2 = Ve(t3.fieldTransforms, r2, n2);
}
function Fe(t3, e, n2) {
  var r2 = [];
  k2(t3.length === n2.length);
  for (var i = 0; i < n2.length; i++) {
    var o = t3[i], s = o.transform, u = null;
    e instanceof gt && (u = e.field(o.field)), r2.push(pe(s, u, n2[i]));
  }
  return r2;
}
function qe(t3, e, n2) {
  for (var r2 = [], i = 0, o = t3; i < o.length; i++) {
    var s = o[i], u = s.transform, a = null;
    n2 instanceof gt && (a = n2.field(s.field)), r2.push(de(u, a, e));
  }
  return r2;
}
function Ve(t3, e, n2) {
  for (var r2 = new ue(e), i = 0; i < t3.length; i++) {
    var o = t3[i];
    r2.set(o.field, n2[i]);
  }
  return r2.v();
}
var Ue;
var Be;
var je = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).key = e2, r2.precondition = n2, r2.type = 2, r2.fieldTransforms = [], r2;
    }
    return __extends(e, t3), e;
  }(Ae)
);
var Ge = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).key = e2, r2.precondition = n2, r2.type = 3, r2.fieldTransforms = [], r2;
    }
    return __extends(e, t3), e;
  }(Ae)
);
var Ke = (
  // TODO(b/33078163): just use simplest form of existence filter for now
  function(t3) {
    this.count = t3;
  }
);
function ze(t3) {
  switch (t3) {
    case j.OK:
      return A2();
    case j.CANCELLED:
    case j.UNKNOWN:
    case j.DEADLINE_EXCEEDED:
    case j.RESOURCE_EXHAUSTED:
    case j.INTERNAL:
    case j.UNAVAILABLE:
    case j.UNAUTHENTICATED:
      return false;
    case j.INVALID_ARGUMENT:
    case j.NOT_FOUND:
    case j.ALREADY_EXISTS:
    case j.PERMISSION_DENIED:
    case j.FAILED_PRECONDITION:
    case j.ABORTED:
    case j.OUT_OF_RANGE:
    case j.UNIMPLEMENTED:
    case j.DATA_LOSS:
      return true;
    default:
      return A2();
  }
}
function Qe(t3) {
  if (void 0 === t3)
    return S2("GRPC error has no .code"), j.UNKNOWN;
  switch (t3) {
    case Ue.OK:
      return j.OK;
    case Ue.CANCELLED:
      return j.CANCELLED;
    case Ue.UNKNOWN:
      return j.UNKNOWN;
    case Ue.DEADLINE_EXCEEDED:
      return j.DEADLINE_EXCEEDED;
    case Ue.RESOURCE_EXHAUSTED:
      return j.RESOURCE_EXHAUSTED;
    case Ue.INTERNAL:
      return j.INTERNAL;
    case Ue.UNAVAILABLE:
      return j.UNAVAILABLE;
    case Ue.UNAUTHENTICATED:
      return j.UNAUTHENTICATED;
    case Ue.INVALID_ARGUMENT:
      return j.INVALID_ARGUMENT;
    case Ue.NOT_FOUND:
      return j.NOT_FOUND;
    case Ue.ALREADY_EXISTS:
      return j.ALREADY_EXISTS;
    case Ue.PERMISSION_DENIED:
      return j.PERMISSION_DENIED;
    case Ue.FAILED_PRECONDITION:
      return j.FAILED_PRECONDITION;
    case Ue.ABORTED:
      return j.ABORTED;
    case Ue.OUT_OF_RANGE:
      return j.OUT_OF_RANGE;
    case Ue.UNIMPLEMENTED:
      return j.UNIMPLEMENTED;
    case Ue.DATA_LOSS:
      return j.DATA_LOSS;
    default:
      return A2();
  }
}
(Be = Ue || (Ue = {}))[Be.OK = 0] = "OK", Be[Be.CANCELLED = 1] = "CANCELLED", Be[Be.UNKNOWN = 2] = "UNKNOWN", Be[Be.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Be[Be.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Be[Be.NOT_FOUND = 5] = "NOT_FOUND", Be[Be.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Be[Be.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Be[Be.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Be[Be.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Be[Be.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Be[Be.ABORTED = 10] = "ABORTED", Be[Be.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Be[Be.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Be[Be.INTERNAL = 13] = "INTERNAL", Be[Be.UNAVAILABLE = 14] = "UNAVAILABLE", Be[Be.DATA_LOSS = 15] = "DATA_LOSS";
var We = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.comparator = t4, this.root = e || Ye.EMPTY;
    }
    return t3.prototype.insert = function(e, n2) {
      return new t3(this.comparator, this.root.insert(e, n2, this.comparator).copy(null, null, Ye.BLACK, null, null));
    }, // Returns a copy of the map, with the specified key removed.
    t3.prototype.remove = function(e) {
      return new t3(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Ye.BLACK, null, null));
    }, // Returns the value of the node with the given key, or null.
    t3.prototype.get = function(t4) {
      for (var e = this.root; !e.isEmpty(); ) {
        var n2 = this.comparator(t4, e.key);
        if (0 === n2)
          return e.value;
        n2 < 0 ? e = e.left : n2 > 0 && (e = e.right);
      }
      return null;
    }, // Returns the index of the element in this sorted map, or -1 if it doesn't
    // exist.
    t3.prototype.indexOf = function(t4) {
      for (var e = 0, n2 = this.root; !n2.isEmpty(); ) {
        var r2 = this.comparator(t4, n2.key);
        if (0 === r2)
          return e + n2.left.size;
        r2 < 0 ? n2 = n2.left : (
          // Count all nodes left of the node plus the node itself
          (e += n2.left.size + 1, n2 = n2.right)
        );
      }
      return -1;
    }, t3.prototype.isEmpty = function() {
      return this.root.isEmpty();
    }, Object.defineProperty(t3.prototype, "size", {
      // Returns the total number of nodes in the map.
      get: function() {
        return this.root.size;
      },
      enumerable: false,
      configurable: true
    }), // Returns the minimum key in the map.
    t3.prototype.minKey = function() {
      return this.root.minKey();
    }, // Returns the maximum key in the map.
    t3.prototype.maxKey = function() {
      return this.root.maxKey();
    }, // Traverses the map in key order and calls the specified action function
    // for each key/value pair. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t3.prototype.inorderTraversal = function(t4) {
      return this.root.inorderTraversal(t4);
    }, t3.prototype.forEach = function(t4) {
      this.inorderTraversal(function(e, n2) {
        return t4(e, n2), false;
      });
    }, t3.prototype.toString = function() {
      var t4 = [];
      return this.inorderTraversal(function(e, n2) {
        return t4.push(e + ":" + n2), false;
      }), "{" + t4.join(", ") + "}";
    }, // Traverses the map in reverse key order and calls the specified action
    // function for each key/value pair. If action returns true, traversal is
    // aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t3.prototype.reverseTraversal = function(t4) {
      return this.root.reverseTraversal(t4);
    }, // Returns an iterator over the SortedMap.
    t3.prototype.getIterator = function() {
      return new He(this.root, null, this.comparator, false);
    }, t3.prototype.getIteratorFrom = function(t4) {
      return new He(this.root, t4, this.comparator, false);
    }, t3.prototype.getReverseIterator = function() {
      return new He(this.root, null, this.comparator, true);
    }, t3.prototype.getReverseIteratorFrom = function(t4) {
      return new He(this.root, t4, this.comparator, true);
    }, t3;
  }()
);
var He = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.isReverse = r2, this.nodeStack = [];
      for (var i = 1; !t4.isEmpty(); )
        if (i = e ? n2(t4.key, e) : 1, // flip the comparison if we're going in reverse
        r2 && (i *= -1), i < 0)
          t4 = this.isReverse ? t4.left : t4.right;
        else {
          if (0 === i) {
            this.nodeStack.push(t4);
            break;
          }
          this.nodeStack.push(t4), t4 = this.isReverse ? t4.right : t4.left;
        }
    }
    return t3.prototype.getNext = function() {
      var t4 = this.nodeStack.pop(), e = {
        key: t4.key,
        value: t4.value
      };
      if (this.isReverse)
        for (t4 = t4.left; !t4.isEmpty(); )
          this.nodeStack.push(t4), t4 = t4.right;
      else
        for (t4 = t4.right; !t4.isEmpty(); )
          this.nodeStack.push(t4), t4 = t4.left;
      return e;
    }, t3.prototype.hasNext = function() {
      return this.nodeStack.length > 0;
    }, t3.prototype.peek = function() {
      if (0 === this.nodeStack.length)
        return null;
      var t4 = this.nodeStack[this.nodeStack.length - 1];
      return {
        key: t4.key,
        value: t4.value
      };
    }, t3;
  }()
);
var Ye = (
  /** @class */
  function() {
    function t3(e, n2, r2, i, o) {
      this.key = e, this.value = n2, this.color = null != r2 ? r2 : t3.RED, this.left = null != i ? i : t3.EMPTY, this.right = null != o ? o : t3.EMPTY, this.size = this.left.size + 1 + this.right.size;
    }
    return t3.prototype.copy = function(e, n2, r2, i, o) {
      return new t3(null != e ? e : this.key, null != n2 ? n2 : this.value, null != r2 ? r2 : this.color, null != i ? i : this.left, null != o ? o : this.right);
    }, t3.prototype.isEmpty = function() {
      return false;
    }, // Traverses the tree in key order and calls the specified action function
    // for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t3.prototype.inorderTraversal = function(t4) {
      return this.left.inorderTraversal(t4) || t4(this.key, this.value) || this.right.inorderTraversal(t4);
    }, // Traverses the tree in reverse key order and calls the specified action
    // function for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    t3.prototype.reverseTraversal = function(t4) {
      return this.right.reverseTraversal(t4) || t4(this.key, this.value) || this.left.reverseTraversal(t4);
    }, // Returns the minimum node in the tree.
    t3.prototype.min = function() {
      return this.left.isEmpty() ? this : this.left.min();
    }, // Returns the maximum key in the tree.
    t3.prototype.minKey = function() {
      return this.min().key;
    }, // Returns the maximum key in the tree.
    t3.prototype.maxKey = function() {
      return this.right.isEmpty() ? this.key : this.right.maxKey();
    }, // Returns new tree, with the key/value added.
    t3.prototype.insert = function(t4, e, n2) {
      var r2 = this, i = n2(t4, r2.key);
      return (r2 = i < 0 ? r2.copy(null, null, null, r2.left.insert(t4, e, n2), null) : 0 === i ? r2.copy(null, e, null, null, null) : r2.copy(null, null, null, null, r2.right.insert(t4, e, n2))).fixUp();
    }, t3.prototype.removeMin = function() {
      if (this.left.isEmpty())
        return t3.EMPTY;
      var e = this;
      return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)).fixUp();
    }, // Returns new tree, with the specified item removed.
    t3.prototype.remove = function(e, n2) {
      var r2, i = this;
      if (n2(e, i.key) < 0)
        i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, n2), null);
      else {
        if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), 0 === n2(e, i.key)) {
          if (i.right.isEmpty())
            return t3.EMPTY;
          r2 = i.right.min(), i = i.copy(r2.key, r2.value, null, null, i.right.removeMin());
        }
        i = i.copy(null, null, null, null, i.right.remove(e, n2));
      }
      return i.fixUp();
    }, t3.prototype.isRed = function() {
      return this.color;
    }, // Returns new tree after performing any needed rotations.
    t3.prototype.fixUp = function() {
      var t4 = this;
      return t4.right.isRed() && !t4.left.isRed() && (t4 = t4.rotateLeft()), t4.left.isRed() && t4.left.left.isRed() && (t4 = t4.rotateRight()), t4.left.isRed() && t4.right.isRed() && (t4 = t4.colorFlip()), t4;
    }, t3.prototype.moveRedLeft = function() {
      var t4 = this.colorFlip();
      return t4.right.left.isRed() && (t4 = (t4 = (t4 = t4.copy(null, null, null, null, t4.right.rotateRight())).rotateLeft()).colorFlip()), t4;
    }, t3.prototype.moveRedRight = function() {
      var t4 = this.colorFlip();
      return t4.left.left.isRed() && (t4 = (t4 = t4.rotateRight()).colorFlip()), t4;
    }, t3.prototype.rotateLeft = function() {
      var e = this.copy(null, null, t3.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, e, null);
    }, t3.prototype.rotateRight = function() {
      var e = this.copy(null, null, t3.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, e);
    }, t3.prototype.colorFlip = function() {
      var t4 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, t4, e);
    }, // For testing.
    t3.prototype.checkMaxDepth = function() {
      var t4 = this.check();
      return Math.pow(2, t4) <= this.size + 1;
    }, // In a balanced RB tree, the black-depth (number of black nodes) from root to
    // leaves is equal on both sides.  This function verifies that or asserts.
    t3.prototype.check = function() {
      if (this.isRed() && this.left.isRed())
        throw A2();
      if (this.right.isRed())
        throw A2();
      var t4 = this.left.check();
      if (t4 !== this.right.check())
        throw A2();
      return t4 + (this.isRed() ? 0 : 1);
    }, t3;
  }()
);
Ye.EMPTY = null, Ye.RED = true, Ye.BLACK = false, // end LLRBEmptyNode
Ye.EMPTY = new /** @class */
(function() {
  function t3() {
    this.size = 0;
  }
  return Object.defineProperty(t3.prototype, "key", {
    get: function() {
      throw A2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t3.prototype, "value", {
    get: function() {
      throw A2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t3.prototype, "color", {
    get: function() {
      throw A2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t3.prototype, "left", {
    get: function() {
      throw A2();
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(t3.prototype, "right", {
    get: function() {
      throw A2();
    },
    enumerable: false,
    configurable: true
  }), // Returns a copy of the current node.
  t3.prototype.copy = function(t4, e, n2, r2, i) {
    return this;
  }, // Returns a copy of the tree, with the specified key/value added.
  t3.prototype.insert = function(t4, e, n2) {
    return new Ye(t4, e);
  }, // Returns a copy of the tree, with the specified key removed.
  t3.prototype.remove = function(t4, e) {
    return this;
  }, t3.prototype.isEmpty = function() {
    return true;
  }, t3.prototype.inorderTraversal = function(t4) {
    return false;
  }, t3.prototype.reverseTraversal = function(t4) {
    return false;
  }, t3.prototype.minKey = function() {
    return null;
  }, t3.prototype.maxKey = function() {
    return null;
  }, t3.prototype.isRed = function() {
    return false;
  }, // For testing.
  t3.prototype.checkMaxDepth = function() {
    return true;
  }, t3.prototype.check = function() {
    return 0;
  }, t3;
}())();
var Je = (
  /** @class */
  function() {
    function t3(t4) {
      this.comparator = t4, this.data = new We(this.comparator);
    }
    return t3.prototype.has = function(t4) {
      return null !== this.data.get(t4);
    }, t3.prototype.first = function() {
      return this.data.minKey();
    }, t3.prototype.last = function() {
      return this.data.maxKey();
    }, Object.defineProperty(t3.prototype, "size", {
      get: function() {
        return this.data.size;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.indexOf = function(t4) {
      return this.data.indexOf(t4);
    }, /** Iterates elements in order defined by "comparator" */
    t3.prototype.forEach = function(t4) {
      this.data.inorderTraversal(function(e, n2) {
        return t4(e), false;
      });
    }, /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
    t3.prototype.forEachInRange = function(t4, e) {
      for (var n2 = this.data.getIteratorFrom(t4[0]); n2.hasNext(); ) {
        var r2 = n2.getNext();
        if (this.comparator(r2.key, t4[1]) >= 0)
          return;
        e(r2.key);
      }
    }, /**
     * Iterates over `elem`s such that: start &lt;= elem until false is returned.
     */
    t3.prototype.forEachWhile = function(t4, e) {
      var n2;
      for (n2 = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n2.hasNext(); )
        if (!t4(n2.getNext().key))
          return;
    }, /** Finds the least element greater than or equal to `elem`. */
    t3.prototype.firstAfterOrEqual = function(t4) {
      var e = this.data.getIteratorFrom(t4);
      return e.hasNext() ? e.getNext().key : null;
    }, t3.prototype.getIterator = function() {
      return new Xe(this.data.getIterator());
    }, t3.prototype.getIteratorFrom = function(t4) {
      return new Xe(this.data.getIteratorFrom(t4));
    }, /** Inserts or updates an element */
    t3.prototype.add = function(t4) {
      return this.copy(this.data.remove(t4).insert(t4, true));
    }, /** Deletes an element */
    t3.prototype.delete = function(t4) {
      return this.has(t4) ? this.copy(this.data.remove(t4)) : this;
    }, t3.prototype.isEmpty = function() {
      return this.data.isEmpty();
    }, t3.prototype.unionWith = function(t4) {
      var e = this;
      return e.size < t4.size && (e = t4, t4 = this), t4.forEach(function(t5) {
        e = e.add(t5);
      }), e;
    }, t3.prototype.isEqual = function(e) {
      if (!(e instanceof t3))
        return false;
      if (this.size !== e.size)
        return false;
      for (var n2 = this.data.getIterator(), r2 = e.data.getIterator(); n2.hasNext(); ) {
        var i = n2.getNext().key, o = r2.getNext().key;
        if (0 !== this.comparator(i, o))
          return false;
      }
      return true;
    }, t3.prototype.toArray = function() {
      var t4 = [];
      return this.forEach(function(e) {
        t4.push(e);
      }), t4;
    }, t3.prototype.toString = function() {
      var t4 = [];
      return this.forEach(function(e) {
        return t4.push(e);
      }), "SortedSet(" + t4.toString() + ")";
    }, t3.prototype.copy = function(e) {
      var n2 = new t3(this.comparator);
      return n2.data = e, n2;
    }, t3;
  }()
);
var Xe = (
  /** @class */
  function() {
    function t3(t4) {
      this.iter = t4;
    }
    return t3.prototype.getNext = function() {
      return this.iter.getNext().key;
    }, t3.prototype.hasNext = function() {
      return this.iter.hasNext();
    }, t3;
  }()
);
var $e = new We(H2.comparator);
function Ze() {
  return $e;
}
function tn() {
  return Ze();
}
var en = new We(H2.comparator);
function nn() {
  return en;
}
var rn = new We(H2.comparator);
function on() {
  return rn;
}
var sn = new Je(H2.comparator);
function un() {
  for (var t3 = [], e = 0; e < arguments.length; e++)
    t3[e] = arguments[e];
  for (var n2 = sn, r2 = 0, i = t3; r2 < i.length; r2++) {
    var o = i[r2];
    n2 = n2.add(o);
  }
  return n2;
}
var an = new Je(R2);
function cn() {
  return an;
}
var hn = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      this.snapshotVersion = t4, this.targetChanges = e, this.targetMismatches = n2, this.documentUpdates = r2, this.resolvedLimboDocuments = i;
    }
    return t3.createSynthesizedRemoteEventForCurrentChange = function(e, n2) {
      var r2 = /* @__PURE__ */ new Map();
      return r2.set(e, fn.createSynthesizedTargetChangeForCurrentChange(e, n2)), new t3(ie.min(), r2, cn(), Ze(), un());
    }, t3;
  }()
);
var fn = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      this.resumeToken = t4, this.current = e, this.addedDocuments = n2, this.modifiedDocuments = r2, this.removedDocuments = i;
    }
    return t3.createSynthesizedTargetChangeForCurrentChange = function(e, n2) {
      return new t3(Y2.EMPTY_BYTE_STRING, n2, un(), un(), un());
    }, t3;
  }()
);
var ln = function(t3, e, n2, r2) {
  this.C = t3, this.removedTargetIds = e, this.key = n2, this.N = r2;
};
var dn = function(t3, e) {
  this.targetId = t3, this.$ = e;
};
var pn = function(t3, e, n2, r2) {
  void 0 === n2 && (n2 = Y2.EMPTY_BYTE_STRING), void 0 === r2 && (r2 = null), this.state = t3, this.targetIds = e, this.resumeToken = n2, this.cause = r2;
};
var yn = (
  /** @class */
  function() {
    function t3() {
      this.F = 0, /**
           * Keeps track of the document changes since the last raised snapshot.
           *
           * These changes are continuously updated as we receive document updates and
           * always reflect the current set of changes against the last issued snapshot.
           */
      this.O = gn(), /** See public getters for explanations of these fields. */
      this.k = Y2.EMPTY_BYTE_STRING, this.M = false, /**
           * Whether this target state should be included in the next snapshot. We
           * initialize to true so that newly-added targets are included in the next
           * RemoteEvent.
           */
      this.L = true;
    }
    return Object.defineProperty(t3.prototype, "current", {
      /**
       * Whether this target has been marked 'current'.
       *
       * 'Current' has special meaning in the RPC protocol: It implies that the
       * Watch backend has sent us all changes up to the point at which the target
       * was added and that the target is consistent with the rest of the watch
       * stream.
       */
      get: function() {
        return this.M;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "resumeToken", {
      /** The last resume token sent to us for this target. */
      get: function() {
        return this.k;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "B", {
      /** Whether this target has pending target adds or target removes. */
      get: function() {
        return 0 !== this.F;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "q", {
      /** Whether we have modified any state that should trigger a snapshot. */
      get: function() {
        return this.L;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Applies the resume token to the TargetChange, but only when it has a new
     * value. Empty resumeTokens are discarded.
     */
    t3.prototype.U = function(t4) {
      t4.approximateByteSize() > 0 && (this.L = true, this.k = t4);
    }, /**
     * Creates a target change from the current set of changes.
     *
     * To reset the document changes after raising this snapshot, call
     * `clearPendingChanges()`.
     */
    t3.prototype.K = function() {
      var t4 = un(), e = un(), n2 = un();
      return this.O.forEach(function(r2, i) {
        switch (i) {
          case 0:
            t4 = t4.add(r2);
            break;
          case 2:
            e = e.add(r2);
            break;
          case 1:
            n2 = n2.add(r2);
            break;
          default:
            A2();
        }
      }), new fn(this.k, this.M, t4, e, n2);
    }, /**
     * Resets the document changes and sets `hasPendingChanges` to false.
     */
    t3.prototype.W = function() {
      this.L = false, this.O = gn();
    }, t3.prototype.j = function(t4, e) {
      this.L = true, this.O = this.O.insert(t4, e);
    }, t3.prototype.G = function(t4) {
      this.L = true, this.O = this.O.remove(t4);
    }, t3.prototype.H = function() {
      this.F += 1;
    }, t3.prototype.J = function() {
      this.F -= 1;
    }, t3.prototype.Y = function() {
      this.L = true, this.M = true;
    }, t3;
  }()
);
var vn = (
  /** @class */
  function() {
    function t3(t4) {
      this.X = t4, /** The internal state of all tracked targets. */
      this.Z = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
      this.tt = Ze(), /** A mapping of document keys to their set of target IDs. */
      this.et = mn(), /**
           * A list of targets with existence filter mismatches. These targets are
           * known to be inconsistent and their listens needs to be re-established by
           * RemoteStore.
           */
      this.nt = new Je(R2);
    }
    return t3.prototype.st = function(t4) {
      for (var e = 0, n2 = t4.C; e < n2.length; e++) {
        var r2 = n2[e];
        t4.N instanceof gt ? this.it(r2, t4.N) : t4.N instanceof wt && this.rt(r2, t4.key, t4.N);
      }
      for (var i = 0, o = t4.removedTargetIds; i < o.length; i++) {
        r2 = o[i];
        this.rt(r2, t4.key, t4.N);
      }
    }, /** Processes and adds the WatchTargetChange to the current set of changes. */
    t3.prototype.ot = function(t4) {
      var e = this;
      this.forEachTarget(t4, function(n2) {
        var r2 = e.ct(n2);
        switch (t4.state) {
          case 0:
            e.at(n2) && r2.U(t4.resumeToken);
            break;
          case 1:
            r2.J(), r2.B || // We have a freshly added target, so we need to reset any state
            // that we had previously. This can happen e.g. when remove and add
            // back a target for existence filter mismatches.
            r2.W(), r2.U(t4.resumeToken);
            break;
          case 2:
            r2.J(), r2.B || e.removeTarget(n2);
            break;
          case 3:
            e.at(n2) && (r2.Y(), r2.U(t4.resumeToken));
            break;
          case 4:
            e.at(n2) && // Reset the target and synthesizes removes for all existing
            // documents. The backend will re-add any documents that still
            // match the target before it sends the next global snapshot.
            (e.ut(n2), r2.U(t4.resumeToken));
            break;
          default:
            A2();
        }
      });
    }, /**
     * Iterates over all targetIds that the watch change applies to: either the
     * targetIds explicitly listed in the change or the targetIds of all currently
     * active targets.
     */
    t3.prototype.forEachTarget = function(t4, e) {
      var n2 = this;
      t4.targetIds.length > 0 ? t4.targetIds.forEach(e) : this.Z.forEach(function(t5, r2) {
        n2.at(r2) && e(r2);
      });
    }, /**
     * Handles existence filters and synthesizes deletes for filter mismatches.
     * Targets that are invalidated by filter mismatches are added to
     * `pendingTargetResets`.
     */
    t3.prototype.ht = function(t4) {
      var e = t4.targetId, n2 = t4.$.count, r2 = this.lt(e);
      if (r2) {
        var i = r2.target;
        if (St(i))
          if (0 === n2) {
            var o = new H2(i.path);
            this.rt(e, o, new wt(o, ie.min()));
          } else
            k2(1 === n2);
        else
          this.ft(e) !== n2 && // Existence filter mismatch: We reset the mapping and raise a new
          // snapshot with `isFromCache:true`.
          (this.ut(e), this.nt = this.nt.add(e));
      }
    }, /**
     * Converts the currently accumulated state into a remote event at the
     * provided snapshot version. Resets the accumulated changes before returning.
     */
    t3.prototype.dt = function(t4) {
      var e = this, n2 = /* @__PURE__ */ new Map();
      this.Z.forEach(function(r3, i2) {
        var o = e.lt(i2);
        if (o) {
          if (r3.current && St(o.target)) {
            var s = new H2(o.target.path);
            null !== e.tt.get(s) || e.wt(i2, s) || e.rt(i2, s, new wt(s, t4));
          }
          r3.q && (n2.set(i2, r3.K()), r3.W());
        }
      });
      var r2 = un();
      this.et.forEach(function(t5, n3) {
        var i2 = true;
        n3.forEachWhile(function(t6) {
          var n4 = e.lt(t6);
          return !n4 || 2 === n4.purpose || (i2 = false, false);
        }), i2 && (r2 = r2.add(t5));
      });
      var i = new hn(t4, n2, this.nt, this.tt, r2);
      return this.tt = Ze(), this.et = mn(), this.nt = new Je(R2), i;
    }, /**
     * Adds the provided document to the internal list of document updates and
     * its document key to the given target's mapping.
     */
    // Visible for testing.
    t3.prototype.it = function(t4, e) {
      if (this.at(t4)) {
        var n2 = this.wt(t4, e.key) ? 2 : 0;
        this.ct(t4).j(e.key, n2), this.tt = this.tt.insert(e.key, e), this.et = this.et.insert(e.key, this._t(e.key).add(t4));
      }
    }, /**
     * Removes the provided document from the target mapping. If the
     * document no longer matches the target, but the document's state is still
     * known (e.g. we know that the document was deleted or we received the change
     * that caused the filter mismatch), the new document can be provided
     * to update the remote document cache.
     */
    // Visible for testing.
    t3.prototype.rt = function(t4, e, n2) {
      if (this.at(t4)) {
        var r2 = this.ct(t4);
        this.wt(t4, e) ? r2.j(
          e,
          1
          /* Removed */
        ) : (
          // The document may have entered and left the target before we raised a
          // snapshot, so we can just ignore the change.
          r2.G(e)
        ), this.et = this.et.insert(e, this._t(e).delete(t4)), n2 && (this.tt = this.tt.insert(e, n2));
      }
    }, t3.prototype.removeTarget = function(t4) {
      this.Z.delete(t4);
    }, /**
     * Returns the current count of documents in the target. This includes both
     * the number of documents that the LocalStore considers to be part of the
     * target as well as any accumulated changes.
     */
    t3.prototype.ft = function(t4) {
      var e = this.ct(t4).K();
      return this.X.getRemoteKeysForTarget(t4).size + e.addedDocuments.size - e.removedDocuments.size;
    }, /**
     * Increment the number of acks needed from watch before we can consider the
     * server to be 'in-sync' with the client's active targets.
     */
    t3.prototype.H = function(t4) {
      this.ct(t4).H();
    }, t3.prototype.ct = function(t4) {
      var e = this.Z.get(t4);
      return e || (e = new yn(), this.Z.set(t4, e)), e;
    }, t3.prototype._t = function(t4) {
      var e = this.et.get(t4);
      return e || (e = new Je(R2), this.et = this.et.insert(t4, e)), e;
    }, /**
     * Verifies that the user is still interested in this target (by calling
     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
     * from watch.
     */
    t3.prototype.at = function(t4) {
      var e = null !== this.lt(t4);
      return e || _("WatchChangeAggregator", "Detected inactive target", t4), e;
    }, /**
     * Returns the TargetData for an active target (i.e. a target that the user
     * is still interested in that has no outstanding target change requests).
     */
    t3.prototype.lt = function(t4) {
      var e = this.Z.get(t4);
      return e && e.B ? null : this.X.yt(t4);
    }, /**
     * Resets the state of a Watch target to its initial state (e.g. sets
     * 'current' to false, clears the resume token and removes its target mapping
     * from all documents).
     */
    t3.prototype.ut = function(t4) {
      var e = this;
      this.Z.set(t4, new yn()), this.X.getRemoteKeysForTarget(t4).forEach(function(n2) {
        e.rt(
          t4,
          n2,
          /*updatedDocument=*/
          null
        );
      });
    }, /**
     * Returns whether the LocalStore considers the document to be part of the
     * specified target.
     */
    t3.prototype.wt = function(t4, e) {
      return this.X.getRemoteKeysForTarget(t4).has(e);
    }, t3;
  }()
);
function mn() {
  return new We(H2.comparator);
}
function gn() {
  return new We(H2.comparator);
}
var wn = {
  asc: "ASCENDING",
  desc: "DESCENDING"
};
var bn = {
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
};
var In = function(t3, e) {
  this.databaseId = t3, this.V = e;
};
function En(t3, e) {
  return t3.V ? new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "") + "." + ("000000000" + e.nanoseconds).slice(-9) + "Z" : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Tn(t3, e) {
  return t3.V ? e.toBase64() : e.toUint8Array();
}
function _n(t3, e) {
  return En(t3, e.toTimestamp());
}
function Sn(t3) {
  return k2(!!t3), ie.fromTimestamp(function(t4) {
    var e = X2(t4);
    return new tt(e.seconds, e.nanos);
  }(t3));
}
function Dn(t3, e) {
  return function(t4) {
    return new z2(["projects", t4.projectId, "databases", t4.database]);
  }(t3).child("documents").child(e).canonicalString();
}
function Nn(t3) {
  var e = z2.fromString(t3);
  return k2(Xn(e)), e;
}
function An(t3, e) {
  return Dn(t3.databaseId, e.path);
}
function kn(t3, e) {
  var n2 = Nn(e);
  if (n2.get(1) !== t3.databaseId.projectId)
    throw new G2(j.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n2.get(1) + " vs " + t3.databaseId.projectId);
  if (n2.get(3) !== t3.databaseId.database)
    throw new G2(j.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n2.get(3) + " vs " + t3.databaseId.database);
  return new H2(Rn(n2));
}
function Cn(t3, e) {
  return Dn(t3.databaseId, e);
}
function xn(t3) {
  var e = Nn(t3);
  return 4 === e.length ? z2.emptyPath() : Rn(e);
}
function Ln(t3) {
  return new z2(["projects", t3.databaseId.projectId, "databases", t3.databaseId.database]).canonicalString();
}
function Rn(t3) {
  return k2(t3.length > 4 && "documents" === t3.get(4)), t3.popFirst(5);
}
function On(t3, e, n2) {
  return {
    name: An(t3, e),
    fields: n2.proto.mapValue.fields
  };
}
function Pn(t3, e, n2) {
  var r2 = kn(t3, e.name), i = Sn(e.updateTime), o = new se({
    mapValue: {
      fields: e.fields
    }
  });
  return new gt(r2, i, o, {
    hasCommittedMutations: !!n2
  });
}
function Mn(t3, e) {
  var n2;
  if (e instanceof Oe)
    n2 = {
      update: On(t3, e.key, e.value)
    };
  else if (e instanceof je)
    n2 = {
      delete: An(t3, e.key)
    };
  else if (e instanceof Pe)
    n2 = {
      update: On(t3, e.key, e.data),
      updateMask: Jn(e.fieldMask)
    };
  else {
    if (!(e instanceof Ge))
      return A2();
    n2 = {
      verify: An(t3, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n2.updateTransforms = e.fieldTransforms.map(function(t4) {
    return function(t5, e2) {
      var n3 = e2.transform;
      if (n3 instanceof ve)
        return {
          fieldPath: e2.field.canonicalString(),
          setToServerValue: "REQUEST_TIME"
        };
      if (n3 instanceof me)
        return {
          fieldPath: e2.field.canonicalString(),
          appendMissingElements: {
            values: n3.elements
          }
        };
      if (n3 instanceof we)
        return {
          fieldPath: e2.field.canonicalString(),
          removeAllFromArray: {
            values: n3.elements
          }
        };
      if (n3 instanceof Ie)
        return {
          fieldPath: e2.field.canonicalString(),
          increment: n3.S
        };
      throw A2();
    }(0, t4);
  })), e.precondition.isNone || (n2.currentDocument = function(t4, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: _n(t4, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : A2();
  }(t3, e.precondition)), n2;
}
function Fn(t3, e) {
  var n2 = e.currentDocument ? function(t4) {
    return void 0 !== t4.updateTime ? De.updateTime(Sn(t4.updateTime)) : void 0 !== t4.exists ? De.exists(t4.exists) : De.none();
  }(e.currentDocument) : De.none(), r2 = e.updateTransforms ? e.updateTransforms.map(function(e2) {
    return function(t4, e3) {
      var n3 = null;
      if ("setToServerValue" in e3)
        k2("REQUEST_TIME" === e3.setToServerValue), n3 = new ve();
      else if ("appendMissingElements" in e3) {
        var r3 = e3.appendMissingElements.values || [];
        n3 = new me(r3);
      } else if ("removeAllFromArray" in e3) {
        var i2 = e3.removeAllFromArray.values || [];
        n3 = new we(i2);
      } else
        "increment" in e3 ? n3 = new Ie(t4, e3.increment) : A2();
      var o2 = W2.fromServerFormat(e3.fieldPath);
      return new _e(o2, n3);
    }(t3, e2);
  }) : [];
  if (e.update) {
    e.update.name;
    var i = kn(t3, e.update.name), o = new se({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      var s = function(t4) {
        var e2 = t4.fieldPaths || [];
        return new oe(e2.map(function(t5) {
          return W2.fromServerFormat(t5);
        }));
      }(e.updateMask);
      return new Pe(i, o, s, n2, r2);
    }
    return new Oe(i, o, n2, r2);
  }
  if (e.delete) {
    var u = kn(t3, e.delete);
    return new je(u, n2);
  }
  if (e.verify) {
    var a = kn(t3, e.verify);
    return new Ge(a, n2);
  }
  return A2();
}
function qn(t3, e) {
  return {
    documents: [Cn(t3, e.path)]
  };
}
function Vn(t3, e) {
  var n2 = {
    structuredQuery: {}
  }, r2 = e.path;
  null !== e.collectionGroup ? (n2.parent = Cn(t3, r2), n2.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n2.parent = Cn(t3, r2.popLast()), n2.structuredQuery.from = [{
    collectionId: r2.lastSegment()
  }]);
  var i = function(t4) {
    if (0 !== t4.length) {
      var e2 = t4.map(function(t5) {
        return function(t6) {
          if ("==" === t6.op) {
            if (yt(t6.value))
              return {
                unaryFilter: {
                  field: Qn(t6.field),
                  op: "IS_NAN"
                }
              };
            if (pt(t6.value))
              return {
                unaryFilter: {
                  field: Qn(t6.field),
                  op: "IS_NULL"
                }
              };
          } else if ("!=" === t6.op) {
            if (yt(t6.value))
              return {
                unaryFilter: {
                  field: Qn(t6.field),
                  op: "IS_NOT_NAN"
                }
              };
            if (pt(t6.value))
              return {
                unaryFilter: {
                  field: Qn(t6.field),
                  op: "IS_NOT_NULL"
                }
              };
          }
          return {
            fieldFilter: {
              field: Qn(t6.field),
              op: zn(t6.op),
              value: t6.value
            }
          };
        }(t5);
      });
      return 1 === e2.length ? e2[0] : {
        compositeFilter: {
          op: "AND",
          filters: e2
        }
      };
    }
  }(e.filters);
  i && (n2.structuredQuery.where = i);
  var o = function(t4) {
    if (0 !== t4.length)
      return t4.map(function(t5) {
        return function(t6) {
          return {
            field: Qn(t6.field),
            direction: Kn(t6.dir)
          };
        }(t5);
      });
  }(e.orderBy);
  o && (n2.structuredQuery.orderBy = o);
  var s = function(t4, e2) {
    return t4.V || V2(e2) ? e2 : {
      value: e2
    };
  }(t3, e.limit);
  return null !== s && (n2.structuredQuery.limit = s), e.startAt && (n2.structuredQuery.startAt = jn(e.startAt)), e.endAt && (n2.structuredQuery.endAt = jn(e.endAt)), n2;
}
function Un(t3) {
  var e = xn(t3.parent), n2 = t3.structuredQuery, r2 = n2.from ? n2.from.length : 0, i = null;
  if (r2 > 0) {
    k2(1 === r2);
    var o = n2.from[0];
    o.allDescendants ? i = o.collectionId : e = e.child(o.collectionId);
  }
  var s = [];
  n2.where && (s = Bn(n2.where));
  var u = [];
  n2.orderBy && (u = n2.orderBy.map(function(t4) {
    return function(t5) {
      return new Ft(
        Wn(t5.field),
        // visible for testing
        function(t6) {
          switch (t6) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(t5.direction)
      );
    }(t4);
  }));
  var a = null;
  n2.limit && (a = function(t4) {
    var e2;
    return V2(e2 = "object" == typeof t4 ? t4.value : t4) ? null : e2;
  }(n2.limit));
  var c = null;
  n2.startAt && (c = Gn(n2.startAt));
  var h2 = null;
  return n2.endAt && (h2 = Gn(n2.endAt)), jt(e, i, u, s, a, "F", c, h2);
}
function Bn(t3) {
  return t3 ? void 0 !== t3.unaryFilter ? [Yn(t3)] : void 0 !== t3.fieldFilter ? [Hn(t3)] : void 0 !== t3.compositeFilter ? t3.compositeFilter.filters.map(function(t4) {
    return Bn(t4);
  }).reduce(function(t4, e) {
    return t4.concat(e);
  }) : A2() : [];
}
function jn(t3) {
  return {
    before: t3.before,
    values: t3.position
  };
}
function Gn(t3) {
  var e = !!t3.before, n2 = t3.values || [];
  return new Pt(n2, e);
}
function Kn(t3) {
  return wn[t3];
}
function zn(t3) {
  return bn[t3];
}
function Qn(t3) {
  return {
    fieldPath: t3.canonicalString()
  };
}
function Wn(t3) {
  return W2.fromServerFormat(t3.fieldPath);
}
function Hn(t3) {
  return Dt.create(Wn(t3.fieldFilter.field), function(t4) {
    switch (t4) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return A2();
    }
  }(t3.fieldFilter.op), t3.fieldFilter.value);
}
function Yn(t3) {
  switch (t3.unaryFilter.op) {
    case "IS_NAN":
      var e = Wn(t3.unaryFilter.field);
      return Dt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      var n2 = Wn(t3.unaryFilter.field);
      return Dt.create(n2, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      var r2 = Wn(t3.unaryFilter.field);
      return Dt.create(r2, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      var i = Wn(t3.unaryFilter.field);
      return Dt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return A2();
  }
}
function Jn(t3) {
  var e = [];
  return t3.fields.forEach(function(t4) {
    return e.push(t4.canonicalString());
  }), {
    fieldPaths: e
  };
}
function Xn(t3) {
  return t3.length >= 4 && "projects" === t3.get(0) && "databases" === t3.get(2);
}
function $n(t3) {
  for (var e = "", n2 = 0; n2 < t3.length; n2++)
    e.length > 0 && (e = tr(e)), e = Zn(t3.get(n2), e);
  return tr(e);
}
function Zn(t3, e) {
  for (var n2 = e, r2 = t3.length, i = 0; i < r2; i++) {
    var o = t3.charAt(i);
    switch (o) {
      case "\0":
        n2 += "";
        break;
      case "":
        n2 += "";
        break;
      default:
        n2 += o;
    }
  }
  return n2;
}
function tr(t3) {
  return t3 + "";
}
function er(t3) {
  var e = t3.length;
  if (k2(e >= 2), 2 === e)
    return k2("" === t3.charAt(0) && "" === t3.charAt(1)), z2.emptyPath();
  for (var n2 = e - 2, r2 = [], i = "", o = 0; o < e; ) {
    var s = t3.indexOf("", o);
    switch ((s < 0 || s > n2) && A2(), t3.charAt(s + 1)) {
      case "":
        var u = t3.substring(o, s), a = void 0;
        0 === i.length ? (
          // Avoid copying for the common case of a segment that excludes \0
          // and \001
          a = u
        ) : (a = i += u, i = ""), r2.push(a);
        break;
      case "":
        i += t3.substring(o, s), i += "\0";
        break;
      case "":
        i += t3.substring(o, s + 1);
        break;
      default:
        A2();
    }
    o = s + 2;
  }
  return new z2(r2);
}
var nr = function(t3, e) {
  this.seconds = t3, this.nanoseconds = e;
};
var rr = function(t3, e, n2) {
  this.ownerId = t3, this.allowTabSynchronization = e, this.leaseTimestampMs = n2;
};
rr.store = "owner", /**
     * The key string used for the single object that exists in the
     * DbPrimaryClient store.
     */
rr.key = "owner";
var ir = function(t3, e, n2) {
  this.userId = t3, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n2;
};
ir.store = "mutationQueues", /** Keys are automatically assigned via the userId property. */
ir.keyPath = "userId";
var or = function(t3, e, n2, r2, i) {
  this.userId = t3, this.batchId = e, this.localWriteTimeMs = n2, this.baseMutations = r2, this.mutations = i;
};
or.store = "mutations", /** Keys are automatically assigned via the userId, batchId properties. */
or.keyPath = "batchId", /** The index name for lookup of mutations by user. */
or.userMutationsIndex = "userMutationsIndex", /** The user mutations index is keyed by [userId, batchId] pairs. */
or.userMutationsKeyPath = ["userId", "batchId"];
var sr = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prefixForUser = function(t4) {
      return [t4];
    }, /**
     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations
     * index to iterate over all at document mutations for a given path or lower.
     */
    t3.prefixForPath = function(t4, e) {
      return [t4, $n(e)];
    }, /**
     * Creates a full index key of [userId, encodedPath, batchId] for inserting
     * and deleting into the DbDocumentMutations index.
     */
    t3.key = function(t4, e, n2) {
      return [t4, $n(e), n2];
    }, t3;
  }()
);
sr.store = "documentMutations", /**
     * Because we store all the useful information for this store in the key,
     * there is no useful information to store as the value. The raw (unencoded)
     * path cannot be stored because IndexedDb doesn't store prototype
     * information.
     */
sr.PLACEHOLDER = new sr();
var ur = function(t3, e) {
  this.path = t3, this.readTime = e;
};
var ar = function(t3, e) {
  this.path = t3, this.version = e;
};
var cr = (
  // TODO: We are currently storing full document keys almost three times
  // (once as part of the primary key, once - partly - as `parentPath` and once
  // inside the encoded documents). During our next migration, we should
  // rewrite the primary key as parentPath + document ID which would allow us
  // to drop one value.
  function(t3, e, n2, r2, i, o) {
    this.unknownDocument = t3, this.noDocument = e, this.document = n2, this.hasCommittedMutations = r2, this.readTime = i, this.parentPath = o;
  }
);
cr.store = "remoteDocuments", /**
     * An index that provides access to all entries sorted by read time (which
     * corresponds to the last modification time of each row).
     *
     * This index is used to provide a changelog for Multi-Tab.
     */
cr.readTimeIndex = "readTimeIndex", cr.readTimeIndexPath = "readTime", /**
     * An index that provides access to documents in a collection sorted by read
     * time.
     *
     * This index is used to allow the RemoteDocumentCache to fetch newly changed
     * documents in a collection.
     */
cr.collectionReadTimeIndex = "collectionReadTimeIndex", cr.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var hr = (
  /**
       * @param byteSize - Approximately the total size in bytes of all the
       * documents in the document cache.
       */
  function(t3) {
    this.byteSize = t3;
  }
);
hr.store = "remoteDocumentGlobal", hr.key = "remoteDocumentGlobalKey";
var fr = function(t3, e, n2, r2, i, o, s) {
  this.targetId = t3, this.canonicalId = e, this.readTime = n2, this.resumeToken = r2, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = o, this.query = s;
};
fr.store = "targets", /** Keys are automatically assigned via the targetId property. */
fr.keyPath = "targetId", /** The name of the queryTargets index. */
fr.queryTargetsIndexName = "queryTargetsIndex", /**
     * The index of all canonicalIds to the targets that they match. This is not
     * a unique mapping because canonicalId does not promise a unique name for all
     * possible queries, so we append the targetId to make the mapping unique.
     */
fr.queryTargetsKeyPath = ["canonicalId", "targetId"];
var lr = function(t3, e, n2) {
  this.targetId = t3, this.path = e, this.sequenceNumber = n2;
};
lr.store = "targetDocuments", /** Keys are automatically assigned via the targetId, path properties. */
lr.keyPath = ["targetId", "path"], /** The index name for the reverse index. */
lr.documentTargetsIndex = "documentTargetsIndex", /** We also need to create the reverse index for these properties. */
lr.documentTargetsKeyPath = ["path", "targetId"];
var dr = function(t3, e, n2, r2) {
  this.highestTargetId = t3, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n2, this.targetCount = r2;
};
dr.key = "targetGlobalKey", dr.store = "targetGlobal";
var pr = function(t3, e) {
  this.collectionId = t3, this.parent = e;
};
pr.store = "collectionParents", /** Keys are automatically assigned via the collectionId, parent properties. */
pr.keyPath = ["collectionId", "parent"];
var yr = function(t3, e, n2, r2) {
  this.clientId = t3, this.updateTimeMs = e, this.networkEnabled = n2, this.inForeground = r2;
};
yr.store = "clientMetadata", /** Keys are automatically assigned via the clientId properties. */
yr.keyPath = "clientId";
var vr = function(t3, e, n2) {
  this.bundleId = t3, this.createTime = e, this.version = n2;
};
vr.store = "bundles", vr.keyPath = "bundleId";
var mr = function(t3, e, n2) {
  this.name = t3, this.readTime = e, this.bundledQuery = n2;
};
mr.store = "namedQueries", mr.keyPath = "name";
var gr = __spreadArray(__spreadArray([], __spreadArray(__spreadArray([], __spreadArray(__spreadArray([], __spreadArray(__spreadArray([], [ir.store, or.store, sr.store, cr.store, fr.store, rr.store, dr.store, lr.store]), [yr.store])), [hr.store])), [pr.store])), [vr.store, mr.store]);
var wr = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var br = (
  /** @class */
  function() {
    function t3() {
      this.onCommittedListeners = [];
    }
    return t3.prototype.addOnCommittedListener = function(t4) {
      this.onCommittedListeners.push(t4);
    }, t3.prototype.raiseOnCommittedEvent = function() {
      this.onCommittedListeners.forEach(function(t4) {
        return t4();
      });
    }, t3;
  }()
);
var Ir = function() {
  var t3 = this;
  this.promise = new Promise(function(e, n2) {
    t3.resolve = e, t3.reject = n2;
  });
};
var Er = (
  /** @class */
  function() {
    function t3(t4) {
      var e = this;
      this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
      this.result = void 0, this.error = void 0, this.isDone = false, // Set to true when .then() or .catch() are called and prevents additional
      // chaining.
      this.callbackAttached = false, t4(function(t5) {
        e.isDone = true, e.result = t5, e.nextCallback && // value should be defined unless T is Void, but we can't express
        // that in the type system.
        e.nextCallback(t5);
      }, function(t5) {
        e.isDone = true, e.error = t5, e.catchCallback && e.catchCallback(t5);
      });
    }
    return t3.prototype.catch = function(t4) {
      return this.next(void 0, t4);
    }, t3.prototype.next = function(e, n2) {
      var r2 = this;
      return this.callbackAttached && A2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(n2, this.error) : this.wrapSuccess(e, this.result) : new t3(function(t4, i) {
        r2.nextCallback = function(n3) {
          r2.wrapSuccess(e, n3).next(t4, i);
        }, r2.catchCallback = function(e2) {
          r2.wrapFailure(n2, e2).next(t4, i);
        };
      });
    }, t3.prototype.toPromise = function() {
      var t4 = this;
      return new Promise(function(e, n2) {
        t4.next(e, n2);
      });
    }, t3.prototype.wrapUserFunction = function(e) {
      try {
        var n2 = e();
        return n2 instanceof t3 ? n2 : t3.resolve(n2);
      } catch (e2) {
        return t3.reject(e2);
      }
    }, t3.prototype.wrapSuccess = function(e, n2) {
      return e ? this.wrapUserFunction(function() {
        return e(n2);
      }) : t3.resolve(n2);
    }, t3.prototype.wrapFailure = function(e, n2) {
      return e ? this.wrapUserFunction(function() {
        return e(n2);
      }) : t3.reject(n2);
    }, t3.resolve = function(e) {
      return new t3(function(t4, n2) {
        t4(e);
      });
    }, t3.reject = function(e) {
      return new t3(function(t4, n2) {
        n2(e);
      });
    }, t3.waitFor = function(e) {
      return new t3(function(t4, n2) {
        var r2 = 0, i = 0, o = false;
        e.forEach(function(e2) {
          ++r2, e2.next(function() {
            ++i, o && i === r2 && t4();
          }, function(t5) {
            return n2(t5);
          });
        }), o = true, i === r2 && t4();
      });
    }, /**
     * Given an array of predicate functions that asynchronously evaluate to a
     * boolean, implements a short-circuiting `or` between the results. Predicates
     * will be evaluated until one of them returns `true`, then stop. The final
     * result will be whether any of them returned `true`.
     */
    t3.or = function(e) {
      for (var n2 = t3.resolve(false), r2 = function(e2) {
        n2 = n2.next(function(n3) {
          return n3 ? t3.resolve(n3) : e2();
        });
      }, i = 0, o = e; i < o.length; i++) {
        r2(o[i]);
      }
      return n2;
    }, t3.forEach = function(t4, e) {
      var n2 = this, r2 = [];
      return t4.forEach(function(t5, i) {
        r2.push(e.call(n2, t5, i));
      }), this.waitFor(r2);
    }, t3;
  }()
);
var Tr = (
  /** @class */
  function() {
    function t3(t4, e) {
      var n2 = this;
      this.action = t4, this.transaction = e, this.aborted = false, /**
           * A promise that resolves with the result of the IndexedDb transaction.
           */
      this.gt = new Ir(), this.transaction.oncomplete = function() {
        n2.gt.resolve();
      }, this.transaction.onabort = function() {
        e.error ? n2.gt.reject(new Dr(t4, e.error)) : n2.gt.resolve();
      }, this.transaction.onerror = function(e2) {
        var r2 = xr(e2.target.error);
        n2.gt.reject(new Dr(t4, r2));
      };
    }
    return t3.open = function(e, n2, r2, i) {
      try {
        return new t3(n2, e.transaction(i, r2));
      } catch (e2) {
        throw new Dr(n2, e2);
      }
    }, Object.defineProperty(t3.prototype, "Et", {
      get: function() {
        return this.gt.promise;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.abort = function(t4) {
      t4 && this.gt.reject(t4), this.aborted || (_("SimpleDb", "Aborting transaction:", t4 ? t4.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
    }, /**
     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All
     * operations performed on the SimpleDbStore happen within the context of this
     * transaction and it cannot be used anymore once the transaction is
     * completed.
     *
     * Note that we can't actually enforce that the KeyType and ValueType are
     * correct, but they allow type safety through the rest of the consuming code.
     */
    t3.prototype.store = function(t4) {
      var e = this.transaction.objectStore(t4);
      return new Ar(e);
    }, t3;
  }()
);
var _r = (
  /** @class */
  function() {
    function t3(e, r2, i) {
      this.name = e, this.version = r2, this.Tt = i, // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the
      // bug we're checking for should exist in iOS >= 12.2 and < 13, but for
      // whatever reason it's much harder to hit after 12.2 so we only proactively
      // log on 12.2.
      12.2 === t3.It(getUA()) && S2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
    }
    return t3.delete = function(t4) {
      return _("SimpleDb", "Removing database:", t4), kr(window.indexedDB.deleteDatabase(t4)).toPromise();
    }, /** Returns true if IndexedDB is available in the current environment. */
    t3.At = function() {
      if ("undefined" == typeof indexedDB)
        return false;
      if (t3.Rt())
        return true;
      var e = getUA(), r2 = t3.It(e), i = 0 < r2 && r2 < 10, o = t3.bt(e), s = 0 < o && o < 4.5;
      return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || i || s);
    }, /**
     * Returns true if the backing IndexedDB store is the Node IndexedDBShim
     * (see https://github.com/axemclion/IndexedDBShim).
     */
    t3.Rt = function() {
      var t4;
      return "undefined" != typeof process && "YES" === (null === (t4 = process.env) || void 0 === t4 ? void 0 : t4.vt);
    }, /** Helper to get a typed SimpleDbStore from a transaction. */
    t3.Pt = function(t4, e) {
      return t4.store(e);
    }, // visible for testing
    /** Parse User Agent to determine iOS version. Returns -1 if not found. */
    t3.It = function(t4) {
      var e = t4.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n2 = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
      return Number(n2);
    }, // visible for testing
    /** Parse User Agent to determine Android version. Returns -1 if not found. */
    t3.bt = function(t4) {
      var e = t4.match(/Android ([\d.]+)/i), n2 = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
      return Number(n2);
    }, /**
     * Opens the specified database, creating or upgrading it if necessary.
     */
    t3.prototype.Vt = function(t4) {
      return __awaiter(this, void 0, void 0, function() {
        var e, n2 = this;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              return this.db ? [3, 2] : (_("SimpleDb", "Opening database:", this.name), e = this, [4, new Promise(function(e2, r3) {
                var i = indexedDB.open(n2.name, n2.version);
                i.onsuccess = function(t5) {
                  var n3 = t5.target.result;
                  e2(n3);
                }, i.onblocked = function() {
                  r3(new Dr(t4, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
                }, i.onerror = function(e3) {
                  var n3 = e3.target.error;
                  "VersionError" === n3.name ? r3(new G2(j.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : r3(new Dr(t4, n3));
                }, i.onupgradeneeded = function(t5) {
                  _("SimpleDb", 'Database "' + n2.name + '" requires upgrade from version:', t5.oldVersion);
                  var e3 = t5.target.result;
                  n2.Tt.St(e3, i.transaction, t5.oldVersion, n2.version).next(function() {
                    _("SimpleDb", "Database upgrade to version " + n2.version + " complete");
                  });
                };
              })]);
            case 1:
              e.db = r2.sent(), r2.label = 2;
            case 2:
              return [2, (this.Dt && (this.db.onversionchange = function(t5) {
                return n2.Dt(t5);
              }), this.db)];
          }
        });
      });
    }, t3.prototype.Ct = function(t4) {
      this.Dt = t4, this.db && (this.db.onversionchange = function(e) {
        return t4(e);
      });
    }, t3.prototype.runTransaction = function(t4, e, n2, r2) {
      return __awaiter(this, void 0, void 0, function() {
        var i, o, s, u, a;
        return __generator(this, function(c) {
          switch (c.label) {
            case 0:
              i = "readonly" === e, o = 0, s = function() {
                var e2, s2, a2, c2, h2;
                return __generator(this, function(f) {
                  switch (f.label) {
                    case 0:
                      ++o, f.label = 1;
                    case 1:
                      return f.trys.push([1, 4, , 5]), [4, u.Vt(t4)];
                    case 2:
                      return u.db = f.sent(), e2 = Tr.open(u.db, t4, i ? "readonly" : "readwrite", n2), s2 = r2(e2).catch(function(t5) {
                        return e2.abort(t5), Er.reject(t5);
                      }).toPromise(), a2 = {}, s2.catch(function() {
                      }), [4, e2.Et];
                    case 3:
                      return [2, (a2.value = // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to
                      // fire), but still return the original transactionFnResult back to the
                      // caller.
                      (f.sent(), s2), a2)];
                    case 4:
                      return c2 = f.sent(), h2 = "FirebaseError" !== c2.name && o < 3, _("SimpleDb", "Transaction failed with error:", c2.message, "Retrying:", h2), u.close(), h2 ? [3, 5] : [2, {
                        value: Promise.reject(c2)
                      }];
                    case 5:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              }, u = this, c.label = 1;
            case 1:
              return [5, s()];
            case 2:
              if ("object" == typeof (a = c.sent()))
                return [2, a.value];
              c.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.close = function() {
      this.db && this.db.close(), this.db = void 0;
    }, t3;
  }()
);
var Sr = (
  /** @class */
  function() {
    function t3(t4) {
      this.xt = t4, this.Nt = false, this.$t = null;
    }
    return Object.defineProperty(t3.prototype, "isDone", {
      get: function() {
        return this.Nt;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "Ft", {
      get: function() {
        return this.$t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "cursor", {
      set: function(t4) {
        this.xt = t4;
      },
      enumerable: false,
      configurable: true
    }), /**
     * This function can be called to stop iteration at any point.
     */
    t3.prototype.done = function() {
      this.Nt = true;
    }, /**
     * This function can be called to skip to that next key, which could be
     * an index or a primary key.
     */
    t3.prototype.Ot = function(t4) {
      this.$t = t4;
    }, /**
     * Delete the current cursor value from the object store.
     *
     * NOTE: You CANNOT do this with a keysOnly query.
     */
    t3.prototype.delete = function() {
      return kr(this.xt.delete());
    }, t3;
  }()
);
var Dr = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, j.UNAVAILABLE, "IndexedDB transaction '" + e2 + "' failed: " + n2) || this).name = "IndexedDbTransactionError", r2;
    }
    return __extends(e, t3), e;
  }(G2)
);
function Nr(t3) {
  return "IndexedDbTransactionError" === t3.name;
}
var Ar = (
  /** @class */
  function() {
    function t3(t4) {
      this.store = t4;
    }
    return t3.prototype.put = function(t4, e) {
      var n2;
      return void 0 !== e ? (_("SimpleDb", "PUT", this.store.name, t4, e), n2 = this.store.put(e, t4)) : (_("SimpleDb", "PUT", this.store.name, "<auto-key>", t4), n2 = this.store.put(t4)), kr(n2);
    }, /**
     * Adds a new value into an Object Store and returns the new key. Similar to
     * IndexedDb's `add()`, this method will fail on primary key collisions.
     *
     * @param value - The object to write.
     * @returns The key of the value to add.
     */
    t3.prototype.add = function(t4) {
      return _("SimpleDb", "ADD", this.store.name, t4, t4), kr(this.store.add(t4));
    }, /**
     * Gets the object with the specified key from the specified store, or null
     * if no object exists with the specified key.
     *
     * @key The key of the object to get.
     * @returns The object with the specified key or null if no object exists.
     */
    t3.prototype.get = function(t4) {
      var e = this;
      return kr(this.store.get(t4)).next(function(n2) {
        return void 0 === n2 && (n2 = null), _("SimpleDb", "GET", e.store.name, t4, n2), n2;
      });
    }, t3.prototype.delete = function(t4) {
      return _("SimpleDb", "DELETE", this.store.name, t4), kr(this.store.delete(t4));
    }, /**
     * If we ever need more of the count variants, we can add overloads. For now,
     * all we need is to count everything in a store.
     *
     * Returns the number of rows in the store.
     */
    t3.prototype.count = function() {
      return _("SimpleDb", "COUNT", this.store.name), kr(this.store.count());
    }, t3.prototype.kt = function(t4, e) {
      var n2 = this.cursor(this.options(t4, e)), r2 = [];
      return this.Mt(n2, function(t5, e2) {
        r2.push(e2);
      }).next(function() {
        return r2;
      });
    }, t3.prototype.Lt = function(t4, e) {
      _("SimpleDb", "DELETE ALL", this.store.name);
      var n2 = this.options(t4, e);
      n2.Bt = false;
      var r2 = this.cursor(n2);
      return this.Mt(r2, function(t5, e2, n3) {
        return n3.delete();
      });
    }, t3.prototype.qt = function(t4, e) {
      var n2;
      e ? n2 = t4 : (n2 = {}, e = t4);
      var r2 = this.cursor(n2);
      return this.Mt(r2, e);
    }, /**
     * Iterates over a store, but waits for the given callback to complete for
     * each entry before iterating the next entry. This allows the callback to do
     * asynchronous work to determine if this iteration should continue.
     *
     * The provided callback should return `true` to continue iteration, and
     * `false` otherwise.
     */
    t3.prototype.Ut = function(t4) {
      var e = this.cursor({});
      return new Er(function(n2, r2) {
        e.onerror = function(t5) {
          var e2 = xr(t5.target.error);
          r2(e2);
        }, e.onsuccess = function(e2) {
          var r3 = e2.target.result;
          r3 ? t4(r3.primaryKey, r3.value).next(function(t5) {
            t5 ? r3.continue() : n2();
          }) : n2();
        };
      });
    }, t3.prototype.Mt = function(t4, e) {
      var n2 = [];
      return new Er(function(r2, i) {
        t4.onerror = function(t5) {
          i(t5.target.error);
        }, t4.onsuccess = function(t5) {
          var i2 = t5.target.result;
          if (i2) {
            var o = new Sr(i2), s = e(i2.primaryKey, i2.value, o);
            if (s instanceof Er) {
              var u = s.catch(function(t6) {
                return o.done(), Er.reject(t6);
              });
              n2.push(u);
            }
            o.isDone ? r2() : null === o.Ft ? i2.continue() : i2.continue(o.Ft);
          } else
            r2();
        };
      }).next(function() {
        return Er.waitFor(n2);
      });
    }, t3.prototype.options = function(t4, e) {
      var n2;
      return void 0 !== t4 && ("string" == typeof t4 ? n2 = t4 : e = t4), {
        index: n2,
        range: e
      };
    }, t3.prototype.cursor = function(t4) {
      var e = "next";
      if (t4.reverse && (e = "prev"), t4.index) {
        var n2 = this.store.index(t4.index);
        return t4.Bt ? n2.openKeyCursor(t4.range, e) : n2.openCursor(t4.range, e);
      }
      return this.store.openCursor(t4.range, e);
    }, t3;
  }()
);
function kr(t3) {
  return new Er(function(e, n2) {
    t3.onsuccess = function(t4) {
      var n3 = t4.target.result;
      e(n3);
    }, t3.onerror = function(t4) {
      var e2 = xr(t4.target.error);
      n2(e2);
    };
  });
}
var Cr = false;
function xr(t3) {
  var e = _r.It(getUA());
  if (e >= 12.2 && e < 13) {
    var r2 = "An internal error was encountered in the Indexed Database server";
    if (t3.message.indexOf(r2) >= 0) {
      var i = new G2("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '" + r2 + "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
      return Cr || (Cr = true, // Throw a global exception outside of this promise chain, for the user to
      // potentially catch.
      setTimeout(function() {
        throw i;
      }, 0)), i;
    }
  }
  return t3;
}
var Lr = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).Qt = e2, r2.currentSequenceNumber = n2, r2;
    }
    return __extends(e, t3), e;
  }(br)
);
function Rr(t3, e) {
  var n2 = C(t3);
  return _r.Pt(n2.Qt, e);
}
var Or = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.batchId = t4, this.localWriteTime = e, this.baseMutations = n2, this.mutations = r2;
    }
    return t3.prototype.applyToRemoteDocument = function(t4, e, n2) {
      for (var r2 = n2.mutationResults, i = 0; i < this.mutations.length; i++) {
        var o = this.mutations[i];
        o.key.isEqual(t4) && (e = ke(o, e, r2[i]));
      }
      return e;
    }, /**
     * Computes the local view of a document given all the mutations in this
     * batch.
     *
     * @param docKey - The key of the document to apply mutations to.
     * @param maybeDoc - The document to apply mutations to.
     */
    t3.prototype.applyToLocalView = function(t4, e) {
      for (var n2 = 0, r2 = this.baseMutations; n2 < r2.length; n2++) {
        (s = r2[n2]).key.isEqual(t4) && (e = Ce(s, e, this.localWriteTime));
      }
      for (var i = 0, o = this.mutations; i < o.length; i++) {
        var s;
        (s = o[i]).key.isEqual(t4) && (e = Ce(s, e, this.localWriteTime));
      }
      return e;
    }, /**
     * Computes the local view for all provided documents given the mutations in
     * this batch.
     */
    t3.prototype.applyToLocalDocumentSet = function(t4) {
      var e = this, n2 = t4;
      return this.mutations.forEach(function(r2) {
        var i = e.applyToLocalView(r2.key, t4.get(r2.key));
        i && (n2 = n2.insert(r2.key, i));
      }), n2;
    }, t3.prototype.keys = function() {
      return this.mutations.reduce(function(t4, e) {
        return t4.add(e.key);
      }, un());
    }, t3.prototype.isEqual = function(t4) {
      return this.batchId === t4.batchId && O2(this.mutations, t4.mutations, function(t5, e) {
        return Le(t5, e);
      }) && O2(this.baseMutations, t4.baseMutations, function(t5, e) {
        return Le(t5, e);
      });
    }, t3;
  }()
);
var Pr = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.batch = t4, this.commitVersion = e, this.mutationResults = n2, this.docVersions = r2;
    }
    return t3.from = function(e, n2, r2) {
      k2(e.mutations.length === r2.length);
      for (var i = on(), o = e.mutations, s = 0; s < o.length; s++)
        i = i.insert(o[s].key, r2[s].version);
      return new t3(e, n2, r2, i);
    }, t3;
  }()
);
var Mr = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i, o, s) {
      void 0 === i && (i = ie.min()), void 0 === o && (o = ie.min()), void 0 === s && (s = Y2.EMPTY_BYTE_STRING), this.target = t4, this.targetId = e, this.purpose = n2, this.sequenceNumber = r2, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = s;
    }
    return t3.prototype.withSequenceNumber = function(e) {
      return new t3(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
    }, /**
     * Creates a new target data instance with an updated resume token and
     * snapshot version.
     */
    t3.prototype.withResumeToken = function(e, n2) {
      return new t3(this.target, this.targetId, this.purpose, this.sequenceNumber, n2, this.lastLimboFreeSnapshotVersion, e);
    }, /**
     * Creates a new target data instance with an updated last limbo free
     * snapshot version number.
     */
    t3.prototype.withLastLimboFreeSnapshotVersion = function(e) {
      return new t3(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken);
    }, t3;
  }()
);
var Fr = function(t3) {
  this.Kt = t3;
};
function qr(t3, e) {
  if (e.document)
    return Pn(t3.Kt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    var n2 = H2.fromSegments(e.noDocument.path), r2 = Gr(e.noDocument.readTime);
    return new wt(n2, r2, {
      hasCommittedMutations: !!e.hasCommittedMutations
    });
  }
  if (e.unknownDocument) {
    var i = H2.fromSegments(e.unknownDocument.path);
    r2 = Gr(e.unknownDocument.version);
    return new bt(i, r2);
  }
  return A2();
}
function Vr(t3, e, n2) {
  var r2 = Ur(n2), i = e.key.path.popLast().toArray();
  if (e instanceof gt) {
    var o = function(t4, e2) {
      return {
        name: An(t4, e2.key),
        fields: e2.toProto().mapValue.fields,
        updateTime: En(t4, e2.version.toTimestamp())
      };
    }(t3.Kt, e), s = e.hasCommittedMutations;
    return new cr(
      /* unknownDocument= */
      null,
      /* noDocument= */
      null,
      o,
      s,
      r2,
      i
    );
  }
  if (e instanceof wt) {
    var u = e.key.path.toArray(), a = jr(e.version);
    s = e.hasCommittedMutations;
    return new cr(
      /* unknownDocument= */
      null,
      new ur(u, a),
      /* document= */
      null,
      s,
      r2,
      i
    );
  }
  if (e instanceof bt) {
    var c = e.key.path.toArray(), h2 = jr(e.version);
    return new cr(
      new ar(c, h2),
      /* noDocument= */
      null,
      /* document= */
      null,
      /* hasCommittedMutations= */
      true,
      r2,
      i
    );
  }
  return A2();
}
function Ur(t3) {
  var e = t3.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Br(t3) {
  var e = new tt(t3[0], t3[1]);
  return ie.fromTimestamp(e);
}
function jr(t3) {
  var e = t3.toTimestamp();
  return new nr(e.seconds, e.nanoseconds);
}
function Gr(t3) {
  var e = new tt(t3.seconds, t3.nanoseconds);
  return ie.fromTimestamp(e);
}
function Kr(t3, e) {
  for (var n2 = (e.baseMutations || []).map(function(e2) {
    return Fn(t3.Kt, e2);
  }), r2 = 0; r2 < e.mutations.length - 1; ++r2) {
    var i = e.mutations[r2];
    if (r2 + 1 < e.mutations.length && void 0 !== e.mutations[r2 + 1].transform) {
      var o = e.mutations[r2 + 1];
      i.updateTransforms = o.transform.fieldTransforms, e.mutations.splice(r2 + 1, 1), ++r2;
    }
  }
  var s = e.mutations.map(function(e2) {
    return Fn(t3.Kt, e2);
  }), u = tt.fromMillis(e.localWriteTimeMs);
  return new Or(e.batchId, u, n2, s);
}
function zr(t3) {
  var e, n2, r2 = Gr(t3.readTime), i = void 0 !== t3.lastLimboFreeSnapshotVersion ? Gr(t3.lastLimboFreeSnapshotVersion) : ie.min();
  return void 0 !== t3.query.documents ? (k2(1 === (n2 = t3.query).documents.length), e = Jt(Gt(xn(n2.documents[0])))) : e = function(t4) {
    return Jt(Un(t4));
  }(t3.query), new Mr(e, t3.targetId, 0, t3.lastListenSequenceNumber, r2, i, Y2.fromBase64String(t3.resumeToken));
}
function Qr(t3, e) {
  var n2, r2 = jr(e.snapshotVersion), i = jr(e.lastLimboFreeSnapshotVersion);
  n2 = St(e.target) ? qn(t3.Kt, e.target) : Vn(t3.Kt, e.target);
  var o = e.resumeToken.toBase64();
  return new fr(e.targetId, Tt(e.target), r2, o, e.sequenceNumber, i, n2);
}
function Wr(t3) {
  var e = Un({
    parent: t3.parent,
    structuredQuery: t3.structuredQuery
  });
  return "LAST" === t3.limitType ? Xt(
    e,
    e.limit,
    "L"
    /* Last */
  ) : e;
}
var Hr = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.getBundleMetadata = function(t4, e) {
      return Yr(t4).get(e).next(function(t5) {
        if (t5)
          return {
            id: (e2 = t5).bundleId,
            createTime: Gr(e2.createTime),
            version: e2.version
          };
        var e2;
      });
    }, t3.prototype.saveBundleMetadata = function(t4, e) {
      return Yr(t4).put({
        bundleId: (n2 = e).id,
        createTime: jr(Sn(n2.createTime)),
        version: n2.version
      });
      var n2;
    }, t3.prototype.getNamedQuery = function(t4, e) {
      return Jr(t4).get(e).next(function(t5) {
        if (t5)
          return {
            name: (e2 = t5).name,
            query: Wr(e2.bundledQuery),
            readTime: Gr(e2.readTime)
          };
        var e2;
      });
    }, t3.prototype.saveNamedQuery = function(t4, e) {
      return Jr(t4).put(function(t5) {
        return {
          name: t5.name,
          readTime: jr(Sn(t5.readTime)),
          bundledQuery: t5.bundledQuery
        };
      }(e));
    }, t3;
  }()
);
function Yr(t3) {
  return Rr(t3, vr.store);
}
function Jr(t3) {
  return Rr(t3, mr.store);
}
var Xr = (
  /** @class */
  function() {
    function t3() {
      this.Wt = new $r();
    }
    return t3.prototype.addToCollectionParentIndex = function(t4, e) {
      return this.Wt.add(e), Er.resolve();
    }, t3.prototype.getCollectionParents = function(t4, e) {
      return Er.resolve(this.Wt.getEntries(e));
    }, t3;
  }()
);
var $r = (
  /** @class */
  function() {
    function t3() {
      this.index = {};
    }
    return t3.prototype.add = function(t4) {
      var e = t4.lastSegment(), n2 = t4.popLast(), r2 = this.index[e] || new Je(z2.comparator), i = !r2.has(n2);
      return this.index[e] = r2.add(n2), i;
    }, t3.prototype.has = function(t4) {
      var e = t4.lastSegment(), n2 = t4.popLast(), r2 = this.index[e];
      return r2 && r2.has(n2);
    }, t3.prototype.getEntries = function(t4) {
      return (this.index[t4] || new Je(z2.comparator)).toArray();
    }, t3;
  }()
);
var Zr = (
  /** @class */
  function() {
    function t3() {
      this.jt = new $r();
    }
    return t3.prototype.addToCollectionParentIndex = function(t4, e) {
      var n2 = this;
      if (!this.jt.has(e)) {
        var r2 = e.lastSegment(), i = e.popLast();
        t4.addOnCommittedListener(function() {
          n2.jt.add(e);
        });
        var o = {
          collectionId: r2,
          parent: $n(i)
        };
        return ti(t4).put(o);
      }
      return Er.resolve();
    }, t3.prototype.getCollectionParents = function(t4, e) {
      var n2 = [], r2 = IDBKeyRange.bound(
        [e, ""],
        [P2(e), ""],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      );
      return ti(t4).kt(r2).next(function(t5) {
        for (var r3 = 0, i = t5; r3 < i.length; r3++) {
          var o = i[r3];
          if (o.collectionId !== e)
            break;
          n2.push(er(o.parent));
        }
        return n2;
      });
    }, t3;
  }()
);
function ti(t3) {
  return Rr(t3, pr.store);
}
var ei = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var ni = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.cacheSizeCollectionThreshold = t4, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n2;
    }
    return t3.withCacheSize = function(e) {
      return new t3(e, t3.DEFAULT_COLLECTION_PERCENTILE, t3.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
    }, t3;
  }()
);
function ri(t3, e, n2) {
  var r2 = t3.store(or.store), i = t3.store(sr.store), o = [], s = IDBKeyRange.only(n2.batchId), u = 0, a = r2.qt({
    range: s
  }, function(t4, e2, n3) {
    return u++, n3.delete();
  });
  o.push(a.next(function() {
    k2(1 === u);
  }));
  for (var c = [], h2 = 0, f = n2.mutations; h2 < f.length; h2++) {
    var l = f[h2], d = sr.key(e, l.key.path, n2.batchId);
    o.push(i.delete(d)), c.push(l.key);
  }
  return Er.waitFor(o).next(function() {
    return c;
  });
}
function ii(t3) {
  var e;
  if (t3.document)
    e = t3.document;
  else if (t3.unknownDocument)
    e = t3.unknownDocument;
  else {
    if (!t3.noDocument)
      throw A2();
    e = t3.noDocument;
  }
  return JSON.stringify(e).length;
}
ni.DEFAULT_COLLECTION_PERCENTILE = 10, ni.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, ni.DEFAULT = new ni(41943040, ni.DEFAULT_COLLECTION_PERCENTILE, ni.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), ni.DISABLED = new ni(-1, 0, 0);
var oi = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.userId = t4, this.D = e, this.Gt = n2, this.referenceDelegate = r2, /**
           * Caches the document keys for pending mutation batches. If the mutation
           * has been removed from IndexedDb, the cached value may continue to
           * be used to retrieve the batch's document keys. To remove a cached value
           * locally, `removeCachedMutationKeys()` should be invoked either directly
           * or through `removeMutationBatches()`.
           *
           * With multi-tab, when the primary client acknowledges or rejects a mutation,
           * this cache is used by secondary clients to invalidate the local
           * view of the documents that were previously affected by the mutation.
           */
      // PORTING NOTE: Multi-tab only.
      this.zt = {};
    }
    return t3.Ht = function(e, n2, r2, i) {
      return k2("" !== e.uid), new t3(e.isAuthenticated() ? e.uid : "", n2, r2, i);
    }, t3.prototype.checkEmpty = function(t4) {
      var e = true, n2 = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
      return ui(t4).qt({
        index: or.userMutationsIndex,
        range: n2
      }, function(t5, n3, r2) {
        e = false, r2.done();
      }).next(function() {
        return e;
      });
    }, t3.prototype.addMutationBatch = function(t4, e, n2, r2) {
      var i = this, o = ai(t4), s = ui(t4);
      return s.add({}).next(function(u) {
        k2("number" == typeof u);
        for (var a = new Or(u, e, n2, r2), c = function(t5, e2, n3) {
          var r3 = n3.baseMutations.map(function(e3) {
            return Mn(t5.Kt, e3);
          }), i2 = n3.mutations.map(function(e3) {
            return Mn(t5.Kt, e3);
          });
          return new or(e2, n3.batchId, n3.localWriteTime.toMillis(), r3, i2);
        }(i.D, i.userId, a), h2 = [], f = new Je(function(t5, e2) {
          return R2(t5.canonicalString(), e2.canonicalString());
        }), l = 0, d = r2; l < d.length; l++) {
          var p2 = d[l], y2 = sr.key(i.userId, p2.key.path, u);
          f = f.add(p2.key.path.popLast()), h2.push(s.put(c)), h2.push(o.put(y2, sr.PLACEHOLDER));
        }
        return f.forEach(function(e2) {
          h2.push(i.Gt.addToCollectionParentIndex(t4, e2));
        }), t4.addOnCommittedListener(function() {
          i.zt[u] = a.keys();
        }), Er.waitFor(h2).next(function() {
          return a;
        });
      });
    }, t3.prototype.lookupMutationBatch = function(t4, e) {
      var n2 = this;
      return ui(t4).get(e).next(function(t5) {
        return t5 ? (k2(t5.userId === n2.userId), Kr(n2.D, t5)) : null;
      });
    }, /**
     * Returns the document keys for the mutation batch with the given batchId.
     * For primary clients, this method returns `null` after
     * `removeMutationBatches()` has been called. Secondary clients return a
     * cached result until `removeCachedMutationKeys()` is invoked.
     */
    // PORTING NOTE: Multi-tab only.
    t3.prototype.Jt = function(t4, e) {
      var n2 = this;
      return this.zt[e] ? Er.resolve(this.zt[e]) : this.lookupMutationBatch(t4, e).next(function(t5) {
        if (t5) {
          var r2 = t5.keys();
          return n2.zt[e] = r2, r2;
        }
        return null;
      });
    }, t3.prototype.getNextMutationBatchAfterBatchId = function(t4, e) {
      var n2 = this, r2 = e + 1, i = IDBKeyRange.lowerBound([this.userId, r2]), o = null;
      return ui(t4).qt({
        index: or.userMutationsIndex,
        range: i
      }, function(t5, e2, i2) {
        e2.userId === n2.userId && (k2(e2.batchId >= r2), o = Kr(n2.D, e2)), i2.done();
      }).next(function() {
        return o;
      });
    }, t3.prototype.getHighestUnacknowledgedBatchId = function(t4) {
      var e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]), n2 = -1;
      return ui(t4).qt({
        index: or.userMutationsIndex,
        range: e,
        reverse: true
      }, function(t5, e2, r2) {
        n2 = e2.batchId, r2.done();
      }).next(function() {
        return n2;
      });
    }, t3.prototype.getAllMutationBatches = function(t4) {
      var e = this, n2 = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
      return ui(t4).kt(or.userMutationsIndex, n2).next(function(t5) {
        return t5.map(function(t6) {
          return Kr(e.D, t6);
        });
      });
    }, t3.prototype.getAllMutationBatchesAffectingDocumentKey = function(t4, e) {
      var n2 = this, r2 = sr.prefixForPath(this.userId, e.path), i = IDBKeyRange.lowerBound(r2), o = [];
      return ai(t4).qt({
        range: i
      }, function(r3, i2, s) {
        var u = r3[0], a = r3[1], c = r3[2], h2 = er(a);
        if (u === n2.userId && e.path.isEqual(h2))
          return ui(t4).get(c).next(function(t5) {
            if (!t5)
              throw A2();
            k2(t5.userId === n2.userId), o.push(Kr(n2.D, t5));
          });
        s.done();
      }).next(function() {
        return o;
      });
    }, t3.prototype.getAllMutationBatchesAffectingDocumentKeys = function(t4, e) {
      var n2 = this, r2 = new Je(R2), i = [];
      return e.forEach(function(e2) {
        var o = sr.prefixForPath(n2.userId, e2.path), s = IDBKeyRange.lowerBound(o), u = ai(t4).qt({
          range: s
        }, function(t5, i2, o2) {
          var s2 = t5[0], u2 = t5[1], a = t5[2], c = er(u2);
          s2 === n2.userId && e2.path.isEqual(c) ? r2 = r2.add(a) : o2.done();
        });
        i.push(u);
      }), Er.waitFor(i).next(function() {
        return n2.Yt(t4, r2);
      });
    }, t3.prototype.getAllMutationBatchesAffectingQuery = function(t4, e) {
      var n2 = this, r2 = e.path, i = r2.length + 1, o = sr.prefixForPath(this.userId, r2), s = IDBKeyRange.lowerBound(o), u = new Je(R2);
      return ai(t4).qt({
        range: s
      }, function(t5, e2, o2) {
        var s2 = t5[0], a = t5[1], c = t5[2], h2 = er(a);
        s2 === n2.userId && r2.isPrefixOf(h2) ? (
          // Rows with document keys more than one segment longer than the
          // query path can't be matches. For example, a query on 'rooms'
          // can't match the document /rooms/abc/messages/xyx.
          // TODO(mcg): we'll need a different scanner when we implement
          // ancestor queries.
          h2.length === i && (u = u.add(c))
        ) : o2.done();
      }).next(function() {
        return n2.Yt(t4, u);
      });
    }, t3.prototype.Yt = function(t4, e) {
      var n2 = this, r2 = [], i = [];
      return e.forEach(function(e2) {
        i.push(ui(t4).get(e2).next(function(t5) {
          if (null === t5)
            throw A2();
          k2(t5.userId === n2.userId), r2.push(Kr(n2.D, t5));
        }));
      }), Er.waitFor(i).next(function() {
        return r2;
      });
    }, t3.prototype.removeMutationBatch = function(t4, e) {
      var n2 = this;
      return ri(t4.Qt, this.userId, e).next(function(r2) {
        return t4.addOnCommittedListener(function() {
          n2.Xt(e.batchId);
        }), Er.forEach(r2, function(e2) {
          return n2.referenceDelegate.markPotentiallyOrphaned(t4, e2);
        });
      });
    }, /**
     * Clears the cached keys for a mutation batch. This method should be
     * called by secondary clients after they process mutation updates.
     *
     * Note that this method does not have to be called from primary clients as
     * the corresponding cache entries are cleared when an acknowledged or
     * rejected batch is removed from the mutation queue.
     */
    // PORTING NOTE: Multi-tab only
    t3.prototype.Xt = function(t4) {
      delete this.zt[t4];
    }, t3.prototype.performConsistencyCheck = function(t4) {
      var e = this;
      return this.checkEmpty(t4).next(function(n2) {
        if (!n2)
          return Er.resolve();
        var r2 = IDBKeyRange.lowerBound(sr.prefixForUser(e.userId)), i = [];
        return ai(t4).qt({
          range: r2
        }, function(t5, n3, r3) {
          if (t5[0] === e.userId) {
            var o = er(t5[1]);
            i.push(o);
          } else
            r3.done();
        }).next(function() {
          k2(0 === i.length);
        });
      });
    }, t3.prototype.containsKey = function(t4, e) {
      return si(t4, this.userId, e);
    }, // PORTING NOTE: Multi-tab only (state is held in memory in other clients).
    /** Returns the mutation queue's metadata from IndexedDb. */
    t3.prototype.Zt = function(t4) {
      var e = this;
      return ci(t4).get(this.userId).next(function(t5) {
        return t5 || new ir(
          e.userId,
          -1,
          /*lastStreamToken=*/
          ""
        );
      });
    }, t3;
  }()
);
function si(t3, e, n2) {
  var r2 = sr.prefixForPath(e, n2.path), i = r2[1], o = IDBKeyRange.lowerBound(r2), s = false;
  return ai(t3).qt({
    range: o,
    Bt: true
  }, function(t4, n3, r3) {
    var o2 = t4[0], u = t4[1];
    t4[2];
    o2 === e && u === i && (s = true), r3.done();
  }).next(function() {
    return s;
  });
}
function ui(t3) {
  return Rr(t3, or.store);
}
function ai(t3) {
  return Rr(t3, sr.store);
}
function ci(t3) {
  return Rr(t3, ir.store);
}
var hi = (
  /** @class */
  function() {
    function t3(t4) {
      this.te = t4;
    }
    return t3.prototype.next = function() {
      return this.te += 2, this.te;
    }, t3.ee = function() {
      return new t3(0);
    }, t3.ne = function() {
      return new t3(-1);
    }, t3;
  }()
);
var fi = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.referenceDelegate = t4, this.D = e;
    }
    return t3.prototype.allocateTargetId = function(t4) {
      var e = this;
      return this.se(t4).next(function(n2) {
        var r2 = new hi(n2.highestTargetId);
        return n2.highestTargetId = r2.next(), e.ie(t4, n2).next(function() {
          return n2.highestTargetId;
        });
      });
    }, t3.prototype.getLastRemoteSnapshotVersion = function(t4) {
      return this.se(t4).next(function(t5) {
        return ie.fromTimestamp(new tt(t5.lastRemoteSnapshotVersion.seconds, t5.lastRemoteSnapshotVersion.nanoseconds));
      });
    }, t3.prototype.getHighestSequenceNumber = function(t4) {
      return this.se(t4).next(function(t5) {
        return t5.highestListenSequenceNumber;
      });
    }, t3.prototype.setTargetsMetadata = function(t4, e, n2) {
      var r2 = this;
      return this.se(t4).next(function(i) {
        return i.highestListenSequenceNumber = e, n2 && (i.lastRemoteSnapshotVersion = n2.toTimestamp()), e > i.highestListenSequenceNumber && (i.highestListenSequenceNumber = e), r2.ie(t4, i);
      });
    }, t3.prototype.addTargetData = function(t4, e) {
      var n2 = this;
      return this.re(t4, e).next(function() {
        return n2.se(t4).next(function(r2) {
          return r2.targetCount += 1, n2.oe(e, r2), n2.ie(t4, r2);
        });
      });
    }, t3.prototype.updateTargetData = function(t4, e) {
      return this.re(t4, e);
    }, t3.prototype.removeTargetData = function(t4, e) {
      var n2 = this;
      return this.removeMatchingKeysForTargetId(t4, e.targetId).next(function() {
        return li(t4).delete(e.targetId);
      }).next(function() {
        return n2.se(t4);
      }).next(function(e2) {
        return k2(e2.targetCount > 0), e2.targetCount -= 1, n2.ie(t4, e2);
      });
    }, /**
     * Drops any targets with sequence number less than or equal to the upper bound, excepting those
     * present in `activeTargetIds`. Document associations for the removed targets are also removed.
     * Returns the number of targets removed.
     */
    t3.prototype.removeTargets = function(t4, e, n2) {
      var r2 = this, i = 0, o = [];
      return li(t4).qt(function(s, u) {
        var a = zr(u);
        a.sequenceNumber <= e && null === n2.get(a.targetId) && (i++, o.push(r2.removeTargetData(t4, a)));
      }).next(function() {
        return Er.waitFor(o);
      }).next(function() {
        return i;
      });
    }, /**
     * Call provided function with each `TargetData` that we have cached.
     */
    t3.prototype.forEachTarget = function(t4, e) {
      return li(t4).qt(function(t5, n2) {
        var r2 = zr(n2);
        e(r2);
      });
    }, t3.prototype.se = function(t4) {
      return di(t4).get(dr.key).next(function(t5) {
        return k2(null !== t5), t5;
      });
    }, t3.prototype.ie = function(t4, e) {
      return di(t4).put(dr.key, e);
    }, t3.prototype.re = function(t4, e) {
      return li(t4).put(Qr(this.D, e));
    }, /**
     * In-place updates the provided metadata to account for values in the given
     * TargetData. Saving is done separately. Returns true if there were any
     * changes to the metadata.
     */
    t3.prototype.oe = function(t4, e) {
      var n2 = false;
      return t4.targetId > e.highestTargetId && (e.highestTargetId = t4.targetId, n2 = true), t4.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t4.sequenceNumber, n2 = true), n2;
    }, t3.prototype.getTargetCount = function(t4) {
      return this.se(t4).next(function(t5) {
        return t5.targetCount;
      });
    }, t3.prototype.getTargetData = function(t4, e) {
      var n2 = Tt(e), r2 = IDBKeyRange.bound([n2, Number.NEGATIVE_INFINITY], [n2, Number.POSITIVE_INFINITY]), i = null;
      return li(t4).qt({
        range: r2,
        index: fr.queryTargetsIndexName
      }, function(t5, n3, r3) {
        var o = zr(n3);
        _t(e, o.target) && (i = o, r3.done());
      }).next(function() {
        return i;
      });
    }, t3.prototype.addMatchingKeys = function(t4, e, n2) {
      var r2 = this, i = [], o = pi(t4);
      return e.forEach(function(e2) {
        var s = $n(e2.path);
        i.push(o.put(new lr(n2, s))), i.push(r2.referenceDelegate.addReference(t4, n2, e2));
      }), Er.waitFor(i);
    }, t3.prototype.removeMatchingKeys = function(t4, e, n2) {
      var r2 = this, i = pi(t4);
      return Er.forEach(e, function(e2) {
        var o = $n(e2.path);
        return Er.waitFor([i.delete([n2, o]), r2.referenceDelegate.removeReference(t4, n2, e2)]);
      });
    }, t3.prototype.removeMatchingKeysForTargetId = function(t4, e) {
      var n2 = pi(t4), r2 = IDBKeyRange.bound(
        [e],
        [e + 1],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      );
      return n2.delete(r2);
    }, t3.prototype.getMatchingKeysForTargetId = function(t4, e) {
      var n2 = IDBKeyRange.bound(
        [e],
        [e + 1],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      ), r2 = pi(t4), i = un();
      return r2.qt({
        range: n2,
        Bt: true
      }, function(t5, e2, n3) {
        var r3 = er(t5[1]), o = new H2(r3);
        i = i.add(o);
      }).next(function() {
        return i;
      });
    }, t3.prototype.containsKey = function(t4, e) {
      var n2 = $n(e.path), r2 = IDBKeyRange.bound(
        [n2],
        [P2(n2)],
        /*lowerOpen=*/
        false,
        /*upperOpen=*/
        true
      ), i = 0;
      return pi(t4).qt({
        index: lr.documentTargetsIndex,
        Bt: true,
        range: r2
      }, function(t5, e2, n3) {
        var r3 = t5[0];
        t5[1];
        0 !== r3 && (i++, n3.done());
      }).next(function() {
        return i > 0;
      });
    }, /**
     * Looks up a TargetData entry by target ID.
     *
     * @param targetId - The target ID of the TargetData entry to look up.
     * @returns The cached TargetData entry, or null if the cache has no entry for
     * the target.
     */
    // PORTING NOTE: Multi-tab only.
    t3.prototype.yt = function(t4, e) {
      return li(t4).get(e).next(function(t5) {
        return t5 ? zr(t5) : null;
      });
    }, t3;
  }()
);
function li(t3) {
  return Rr(t3, fr.store);
}
function di(t3) {
  return Rr(t3, dr.store);
}
function pi(t3) {
  return Rr(t3, lr.store);
}
function yi(t3) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      if (t3.code !== j.FAILED_PRECONDITION || t3.message !== wr)
        throw t3;
      return _("LocalStore", "Unexpectedly lost primary lease"), [
        2
        /*return*/
      ];
    });
  });
}
function vi(t3, e) {
  var n2 = t3[0], r2 = t3[1], i = e[0], o = e[1], s = R2(n2, i);
  return 0 === s ? R2(r2, o) : s;
}
var mi = (
  /** @class */
  function() {
    function t3(t4) {
      this.ce = t4, this.buffer = new Je(vi), this.ae = 0;
    }
    return t3.prototype.ue = function() {
      return ++this.ae;
    }, t3.prototype.he = function(t4) {
      var e = [t4, this.ue()];
      if (this.buffer.size < this.ce)
        this.buffer = this.buffer.add(e);
      else {
        var n2 = this.buffer.last();
        vi(e, n2) < 0 && (this.buffer = this.buffer.delete(n2).add(e));
      }
    }, Object.defineProperty(t3.prototype, "maxValue", {
      get: function() {
        return this.buffer.last()[0];
      },
      enumerable: false,
      configurable: true
    }), t3;
  }()
);
var gi = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.garbageCollector = t4, this.asyncQueue = e, this.le = false, this.fe = null;
    }
    return t3.prototype.start = function(t4) {
      -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.de(t4);
    }, t3.prototype.stop = function() {
      this.fe && (this.fe.cancel(), this.fe = null);
    }, Object.defineProperty(t3.prototype, "started", {
      get: function() {
        return null !== this.fe;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.de = function(t4) {
      var e = this, n2 = this.le ? 3e5 : 6e4;
      _("LruGarbageCollector", "Garbage collection scheduled in " + n2 + "ms"), this.fe = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", n2, function() {
        return __awaiter(e, void 0, void 0, function() {
          var e2;
          return __generator(this, function(n3) {
            switch (n3.label) {
              case 0:
                this.fe = null, this.le = true, n3.label = 1;
              case 1:
                return n3.trys.push([1, 3, , 7]), [4, t4.collectGarbage(this.garbageCollector)];
              case 2:
                return n3.sent(), [3, 7];
              case 3:
                return Nr(e2 = n3.sent()) ? (_("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e2), [3, 6]) : [3, 4];
              case 4:
                return [4, yi(e2)];
              case 5:
                n3.sent(), n3.label = 6;
              case 6:
                return [3, 7];
              case 7:
                return [4, this.de(t4)];
              case 8:
                return n3.sent(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    }, t3;
  }()
);
var wi = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.we = t4, this.params = e;
    }
    return t3.prototype.calculateTargetCount = function(t4, e) {
      return this.we._e(t4).next(function(t5) {
        return Math.floor(e / 100 * t5);
      });
    }, t3.prototype.nthSequenceNumber = function(t4, e) {
      var n2 = this;
      if (0 === e)
        return Er.resolve(I2.o);
      var r2 = new mi(e);
      return this.we.forEachTarget(t4, function(t5) {
        return r2.he(t5.sequenceNumber);
      }).next(function() {
        return n2.we.me(t4, function(t5) {
          return r2.he(t5);
        });
      }).next(function() {
        return r2.maxValue;
      });
    }, t3.prototype.removeTargets = function(t4, e, n2) {
      return this.we.removeTargets(t4, e, n2);
    }, t3.prototype.removeOrphanedDocuments = function(t4, e) {
      return this.we.removeOrphanedDocuments(t4, e);
    }, t3.prototype.collect = function(t4, e) {
      var n2 = this;
      return -1 === this.params.cacheSizeCollectionThreshold ? (_("LruGarbageCollector", "Garbage collection skipped; disabled"), Er.resolve(ei)) : this.getCacheSize(t4).next(function(r2) {
        return r2 < n2.params.cacheSizeCollectionThreshold ? (_("LruGarbageCollector", "Garbage collection skipped; Cache size " + r2 + " is lower than threshold " + n2.params.cacheSizeCollectionThreshold), ei) : n2.ye(t4, e);
      });
    }, t3.prototype.getCacheSize = function(t4) {
      return this.we.getCacheSize(t4);
    }, t3.prototype.ye = function(t4, n2) {
      var r2, i, o, s, u, a, c, h2 = this, f = Date.now();
      return this.calculateTargetCount(t4, this.params.percentileToCollect).next(function(e) {
        return e > h2.params.maximumSequenceNumbersToCollect ? (_("LruGarbageCollector", "Capping sequence numbers to collect down to the maximum of " + h2.params.maximumSequenceNumbersToCollect + " from " + e), i = h2.params.maximumSequenceNumbersToCollect) : i = e, s = Date.now(), h2.nthSequenceNumber(t4, i);
      }).next(function(e) {
        return r2 = e, u = Date.now(), h2.removeTargets(t4, r2, n2);
      }).next(function(e) {
        return o = e, a = Date.now(), h2.removeOrphanedDocuments(t4, r2);
      }).next(function(t5) {
        return c = Date.now(), T2() <= LogLevel.DEBUG && _("LruGarbageCollector", "LRU Garbage Collection\n	Counted targets in " + (s - f) + "ms\n	Determined least recently used " + i + " in " + (u - s) + "ms\n	Removed " + o + " targets in " + (a - u) + "ms\n	Removed " + t5 + " documents in " + (c - a) + "ms\nTotal Duration: " + (c - f) + "ms"), Er.resolve({
          didRun: true,
          sequenceNumbersCollected: i,
          targetsRemoved: o,
          documentsRemoved: t5
        });
      });
    }, t3;
  }()
);
var bi = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.db = t4, this.garbageCollector = function(t5, e2) {
        return new wi(t5, e2);
      }(this, e);
    }
    return t3.prototype._e = function(t4) {
      var e = this.ge(t4);
      return this.db.getTargetCache().getTargetCount(t4).next(function(t5) {
        return e.next(function(e2) {
          return t5 + e2;
        });
      });
    }, t3.prototype.ge = function(t4) {
      var e = 0;
      return this.me(t4, function(t5) {
        e++;
      }).next(function() {
        return e;
      });
    }, t3.prototype.forEachTarget = function(t4, e) {
      return this.db.getTargetCache().forEachTarget(t4, e);
    }, t3.prototype.me = function(t4, e) {
      return this.pe(t4, function(t5, n2) {
        return e(n2);
      });
    }, t3.prototype.addReference = function(t4, e, n2) {
      return Ii(t4, n2);
    }, t3.prototype.removeReference = function(t4, e, n2) {
      return Ii(t4, n2);
    }, t3.prototype.removeTargets = function(t4, e, n2) {
      return this.db.getTargetCache().removeTargets(t4, e, n2);
    }, t3.prototype.markPotentiallyOrphaned = function(t4, e) {
      return Ii(t4, e);
    }, /**
     * Returns true if anything would prevent this document from being garbage
     * collected, given that the document in question is not present in any
     * targets and has a sequence number less than or equal to the upper bound for
     * the collection run.
     */
    t3.prototype.Ee = function(t4, e) {
      return function(t5, e2) {
        var n2 = false;
        return ci(t5).Ut(function(r2) {
          return si(t5, r2, e2).next(function(t6) {
            return t6 && (n2 = true), Er.resolve(!t6);
          });
        }).next(function() {
          return n2;
        });
      }(t4, e);
    }, t3.prototype.removeOrphanedDocuments = function(t4, e) {
      var n2 = this, r2 = this.db.getRemoteDocumentCache().newChangeBuffer(), i = [], o = 0;
      return this.pe(t4, function(s, u) {
        if (u <= e) {
          var a = n2.Ee(t4, s).next(function(e2) {
            if (!e2)
              return o++, r2.getEntry(t4, s).next(function() {
                return r2.removeEntry(s), pi(t4).delete([0, $n(s.path)]);
              });
          });
          i.push(a);
        }
      }).next(function() {
        return Er.waitFor(i);
      }).next(function() {
        return r2.apply(t4);
      }).next(function() {
        return o;
      });
    }, t3.prototype.removeTarget = function(t4, e) {
      var n2 = e.withSequenceNumber(t4.currentSequenceNumber);
      return this.db.getTargetCache().updateTargetData(t4, n2);
    }, t3.prototype.updateLimboDocument = function(t4, e) {
      return Ii(t4, e);
    }, /**
     * Call provided function for each document in the cache that is 'orphaned'. Orphaned
     * means not a part of any target, so the only entry in the target-document index for
     * that document will be the sentinel row (targetId 0), which will also have the sequence
     * number for the last time the document was accessed.
     */
    t3.prototype.pe = function(t4, e) {
      var n2, r2 = pi(t4), i = I2.o;
      return r2.qt({
        index: lr.documentTargetsIndex
      }, function(t5, r3) {
        var o = t5[0], s = (t5[1], r3.path), u = r3.sequenceNumber;
        0 === o ? (
          // if nextToReport is valid, report it, this is a new key so the
          // last one must not be a member of any targets.
          (i !== I2.o && e(new H2(er(n2)), i), // set nextToReport to be this sequence number. It's the next one we
          // might report, if we don't find any targets for this document.
          // Note that the sequence number must be defined when the targetId
          // is 0.
          i = u, n2 = s)
        ) : (
          // set nextToReport to be invalid, we know we don't need to report
          // this one since we found a target for it.
          i = I2.o
        );
      }).next(function() {
        i !== I2.o && e(new H2(er(n2)), i);
      });
    }, t3.prototype.getCacheSize = function(t4) {
      return this.db.getRemoteDocumentCache().getSize(t4);
    }, t3;
  }()
);
function Ii(t3, e) {
  return pi(t3).put(
    /**
    * @returns A value suitable for writing a sentinel row in the target-document
    * store.
    */
    function(t4, e2) {
      return new lr(0, $n(t4.path), e2);
    }(e, t3.currentSequenceNumber)
  );
}
var Ei = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.mapKeyFn = t4, this.equalsFn = e, /**
           * The inner map for a key/value pair. Due to the possibility of collisions we
           * keep a list of entries that we do a linear search through to find an actual
           * match. Note that collisions should be rare, so we still expect near
           * constant time lookups in practice.
           */
      this.inner = {};
    }
    return t3.prototype.get = function(t4) {
      var e = this.mapKeyFn(t4), n2 = this.inner[e];
      if (void 0 !== n2)
        for (var r2 = 0, i = n2; r2 < i.length; r2++) {
          var o = i[r2], s = o[0], u = o[1];
          if (this.equalsFn(s, t4))
            return u;
        }
    }, t3.prototype.has = function(t4) {
      return void 0 !== this.get(t4);
    }, /** Put this key and value in the map. */
    t3.prototype.set = function(t4, e) {
      var n2 = this.mapKeyFn(t4), r2 = this.inner[n2];
      if (void 0 !== r2) {
        for (var i = 0; i < r2.length; i++)
          if (this.equalsFn(r2[i][0], t4))
            return void (r2[i] = [t4, e]);
        r2.push([t4, e]);
      } else
        this.inner[n2] = [[t4, e]];
    }, /**
     * Remove this key from the map. Returns a boolean if anything was deleted.
     */
    t3.prototype.delete = function(t4) {
      var e = this.mapKeyFn(t4), n2 = this.inner[e];
      if (void 0 === n2)
        return false;
      for (var r2 = 0; r2 < n2.length; r2++)
        if (this.equalsFn(n2[r2][0], t4))
          return 1 === n2.length ? delete this.inner[e] : n2.splice(r2, 1), true;
      return false;
    }, t3.prototype.forEach = function(t4) {
      F2(this.inner, function(e, n2) {
        for (var r2 = 0, i = n2; r2 < i.length; r2++) {
          var o = i[r2], s = o[0], u = o[1];
          t4(s, u);
        }
      });
    }, t3.prototype.isEmpty = function() {
      return q2(this.inner);
    }, t3;
  }()
);
var Ti = (
  /** @class */
  function() {
    function t3() {
      this.changes = new Ei(function(t4) {
        return t4.toString();
      }, function(t4, e) {
        return t4.isEqual(e);
      }), this.changesApplied = false;
    }
    return t3.prototype.getReadTime = function(t4) {
      var e = this.changes.get(t4);
      return e ? e.readTime : ie.min();
    }, /**
     * Buffers a `RemoteDocumentCache.addEntry()` call.
     *
     * You can only modify documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */
    t3.prototype.addEntry = function(t4, e) {
      this.assertNotApplied(), this.changes.set(t4.key, {
        maybeDocument: t4,
        readTime: e
      });
    }, /**
     * Buffers a `RemoteDocumentCache.removeEntry()` call.
     *
     * You can only remove documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */
    t3.prototype.removeEntry = function(t4, e) {
      void 0 === e && (e = null), this.assertNotApplied(), this.changes.set(t4, {
        maybeDocument: null,
        readTime: e
      });
    }, /**
     * Looks up an entry in the cache. The buffered changes will first be checked,
     * and if no buffered change applies, this will forward to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction - The transaction in which to perform any persistence
     *     operations.
     * @param documentKey - The key of the entry to look up.
     * @returns The cached Document or NoDocument entry, or null if we have
     *     nothing cached.
     */
    t3.prototype.getEntry = function(t4, e) {
      this.assertNotApplied();
      var n2 = this.changes.get(e);
      return void 0 !== n2 ? Er.resolve(n2.maybeDocument) : this.getFromCache(t4, e);
    }, /**
     * Looks up several entries in the cache, forwarding to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction - The transaction in which to perform any persistence
     *     operations.
     * @param documentKeys - The keys of the entries to look up.
     * @returns A map of cached `Document`s or `NoDocument`s, indexed by key. If
     *     an entry cannot be found, the corresponding key will be mapped to a
     *     null value.
     */
    t3.prototype.getEntries = function(t4, e) {
      return this.getAllFromCache(t4, e);
    }, /**
     * Applies buffered changes to the underlying RemoteDocumentCache, using
     * the provided transaction.
     */
    t3.prototype.apply = function(t4) {
      return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t4);
    }, /** Helper to assert this.changes is not null  */
    t3.prototype.assertNotApplied = function() {
    }, t3;
  }()
);
var _i = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.D = t4, this.Gt = e;
    }
    return t3.prototype.addEntry = function(t4, e, n2) {
      return Ni(t4).put(Ai(e), n2);
    }, /**
     * Removes a document from the cache.
     *
     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.
     */
    t3.prototype.removeEntry = function(t4, e) {
      var n2 = Ni(t4), r2 = Ai(e);
      return n2.delete(r2);
    }, /**
     * Updates the current cache size.
     *
     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the
     * cache's metadata.
     */
    t3.prototype.updateMetadata = function(t4, e) {
      var n2 = this;
      return this.getMetadata(t4).next(function(r2) {
        return r2.byteSize += e, n2.Te(t4, r2);
      });
    }, t3.prototype.getEntry = function(t4, e) {
      var n2 = this;
      return Ni(t4).get(Ai(e)).next(function(t5) {
        return n2.Ie(t5);
      });
    }, /**
     * Looks up an entry in the cache.
     *
     * @param documentKey - The key of the entry to look up.
     * @returns The cached MaybeDocument entry and its size, or null if we have
     * nothing cached.
     */
    t3.prototype.Ae = function(t4, e) {
      var n2 = this;
      return Ni(t4).get(Ai(e)).next(function(t5) {
        var e2 = n2.Ie(t5);
        return e2 ? {
          maybeDocument: e2,
          size: ii(t5)
        } : null;
      });
    }, t3.prototype.getEntries = function(t4, e) {
      var n2 = this, r2 = tn();
      return this.Re(t4, e, function(t5, e2) {
        var i = n2.Ie(e2);
        r2 = r2.insert(t5, i);
      }).next(function() {
        return r2;
      });
    }, /**
     * Looks up several entries in the cache.
     *
     * @param documentKeys - The set of keys entries to look up.
     * @returns A map of MaybeDocuments indexed by key (if a document cannot be
     *     found, the key will be mapped to null) and a map of sizes indexed by
     *     key (zero if the key cannot be found).
     */
    t3.prototype.be = function(t4, e) {
      var n2 = this, r2 = tn(), i = new We(H2.comparator);
      return this.Re(t4, e, function(t5, e2) {
        var o = n2.Ie(e2);
        o ? (r2 = r2.insert(t5, o), i = i.insert(t5, ii(e2))) : (r2 = r2.insert(t5, null), i = i.insert(t5, 0));
      }).next(function() {
        return {
          ve: r2,
          Pe: i
        };
      });
    }, t3.prototype.Re = function(t4, e, n2) {
      if (e.isEmpty())
        return Er.resolve();
      var r2 = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator(), o = i.getNext();
      return Ni(t4).qt({
        range: r2
      }, function(t5, e2, r3) {
        for (var s = H2.fromSegments(t5); o && H2.comparator(o, s) < 0; )
          n2(o, null), o = i.getNext();
        o && o.isEqual(s) && // Key found in cache.
        (n2(o, e2), o = i.hasNext() ? i.getNext() : null), // Skip to the next key (if there is one).
        o ? r3.Ot(o.path.toArray()) : r3.done();
      }).next(function() {
        for (; o; )
          n2(o, null), o = i.hasNext() ? i.getNext() : null;
      });
    }, t3.prototype.getDocumentsMatchingQuery = function(t4, e, n2) {
      var r2 = this, i = nn(), o = e.path.length + 1, s = {};
      if (n2.isEqual(ie.min())) {
        var u = e.path.toArray();
        s.range = IDBKeyRange.lowerBound(u);
      } else {
        var a = e.path.toArray(), c = Ur(n2);
        s.range = IDBKeyRange.lowerBound(
          [a, c],
          /* open= */
          true
        ), s.index = cr.collectionReadTimeIndex;
      }
      return Ni(t4).qt(s, function(t5, n3, s2) {
        if (t5.length === o) {
          var u2 = qr(r2.D, n3);
          e.path.isPrefixOf(u2.key.path) ? u2 instanceof gt && ee(e, u2) && (i = i.insert(u2.key, u2)) : s2.done();
        }
      }).next(function() {
        return i;
      });
    }, t3.prototype.newChangeBuffer = function(t4) {
      return new Si(this, !!t4 && t4.trackRemovals);
    }, t3.prototype.getSize = function(t4) {
      return this.getMetadata(t4).next(function(t5) {
        return t5.byteSize;
      });
    }, t3.prototype.getMetadata = function(t4) {
      return Di(t4).get(hr.key).next(function(t5) {
        return k2(!!t5), t5;
      });
    }, t3.prototype.Te = function(t4, e) {
      return Di(t4).put(hr.key, e);
    }, /**
     * Decodes `remoteDoc` and returns the document (or null, if the document
     * corresponds to the format used for sentinel deletes).
     */
    t3.prototype.Ie = function(t4) {
      if (t4) {
        var e = qr(this.D, t4);
        return e instanceof wt && e.version.isEqual(ie.min()) ? null : e;
      }
      return null;
    }, t3;
  }()
);
var Si = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).Ve = e2, r2.trackRemovals = n2, // A map of document sizes prior to applying the changes in this buffer.
      r2.Se = new Ei(function(t4) {
        return t4.toString();
      }, function(t4, e3) {
        return t4.isEqual(e3);
      }), r2;
    }
    return __extends(e, t3), e.prototype.applyChanges = function(t4) {
      var e2 = this, n2 = [], r2 = 0, i = new Je(function(t5, e3) {
        return R2(t5.canonicalString(), e3.canonicalString());
      });
      return this.changes.forEach(function(o, s) {
        var u = e2.Se.get(o);
        if (s.maybeDocument) {
          var a = Vr(e2.Ve.D, s.maybeDocument, e2.getReadTime(o));
          i = i.add(o.path.popLast());
          var c = ii(a);
          r2 += c - u, n2.push(e2.Ve.addEntry(t4, o, a));
        } else if (r2 -= u, e2.trackRemovals) {
          var h2 = Vr(e2.Ve.D, new wt(o, ie.min()), e2.getReadTime(o));
          n2.push(e2.Ve.addEntry(t4, o, h2));
        } else
          n2.push(e2.Ve.removeEntry(t4, o));
      }), i.forEach(function(r3) {
        n2.push(e2.Ve.Gt.addToCollectionParentIndex(t4, r3));
      }), n2.push(this.Ve.updateMetadata(t4, r2)), Er.waitFor(n2);
    }, e.prototype.getFromCache = function(t4, e2) {
      var n2 = this;
      return this.Ve.Ae(t4, e2).next(function(t5) {
        return null === t5 ? (n2.Se.set(e2, 0), null) : (n2.Se.set(e2, t5.size), t5.maybeDocument);
      });
    }, e.prototype.getAllFromCache = function(t4, e2) {
      var n2 = this;
      return this.Ve.be(t4, e2).next(function(t5) {
        var e3 = t5.ve;
        return t5.Pe.forEach(function(t6, e4) {
          n2.Se.set(t6, e4);
        }), e3;
      });
    }, e;
  }(Ti)
);
function Di(t3) {
  return Rr(t3, hr.store);
}
function Ni(t3) {
  return Rr(t3, cr.store);
}
function Ai(t3) {
  return t3.path.toArray();
}
var ki = (
  /** @class */
  function() {
    function t3(t4) {
      this.D = t4;
    }
    return t3.prototype.St = function(t4, e, n2, r2) {
      var i = this;
      k2(n2 < r2 && n2 >= 0 && r2 <= 11);
      var o = new Tr("createOrUpgrade", e);
      n2 < 1 && r2 >= 1 && (function(t5) {
        t5.createObjectStore(rr.store);
      }(t4), function(t5) {
        t5.createObjectStore(ir.store, {
          keyPath: ir.keyPath
        }), t5.createObjectStore(or.store, {
          keyPath: or.keyPath,
          autoIncrement: true
        }).createIndex(or.userMutationsIndex, or.userMutationsKeyPath, {
          unique: true
        }), t5.createObjectStore(sr.store);
      }(t4), Ci(t4), function(t5) {
        t5.createObjectStore(cr.store);
      }(t4));
      var s = Er.resolve();
      return n2 < 3 && r2 >= 3 && // Brand new clients don't need to drop and recreate--only clients that
      // potentially have corrupt data.
      (0 !== n2 && (function(t5) {
        t5.deleteObjectStore(lr.store), t5.deleteObjectStore(fr.store), t5.deleteObjectStore(dr.store);
      }(t4), Ci(t4)), s = s.next(function() {
        return function(t5) {
          var e2 = t5.store(dr.store), n3 = new dr(
            /*highestTargetId=*/
            0,
            /*lastListenSequenceNumber=*/
            0,
            ie.min().toTimestamp(),
            /*targetCount=*/
            0
          );
          return e2.put(dr.key, n3);
        }(o);
      })), n2 < 4 && r2 >= 4 && (0 !== n2 && // Schema version 3 uses auto-generated keys to generate globally unique
      // mutation batch IDs (this was previously ensured internally by the
      // client). To migrate to the new schema, we have to read all mutations
      // and write them back out. We preserve the existing batch IDs to guarantee
      // consistency with other object stores. Any further mutation batch IDs will
      // be auto-generated.
      (s = s.next(function() {
        return function(t5, e2) {
          return e2.store(or.store).kt().next(function(n3) {
            t5.deleteObjectStore(or.store), t5.createObjectStore(or.store, {
              keyPath: or.keyPath,
              autoIncrement: true
            }).createIndex(or.userMutationsIndex, or.userMutationsKeyPath, {
              unique: true
            });
            var r3 = e2.store(or.store), i2 = n3.map(function(t6) {
              return r3.put(t6);
            });
            return Er.waitFor(i2);
          });
        }(t4, o);
      })), s = s.next(function() {
        !function(t5) {
          t5.createObjectStore(yr.store, {
            keyPath: yr.keyPath
          });
        }(t4);
      })), n2 < 5 && r2 >= 5 && (s = s.next(function() {
        return i.De(o);
      })), n2 < 6 && r2 >= 6 && (s = s.next(function() {
        return function(t5) {
          t5.createObjectStore(hr.store);
        }(t4), i.Ce(o);
      })), n2 < 7 && r2 >= 7 && (s = s.next(function() {
        return i.xe(o);
      })), n2 < 8 && r2 >= 8 && (s = s.next(function() {
        return i.Ne(t4, o);
      })), n2 < 9 && r2 >= 9 && (s = s.next(function() {
        !function(t5) {
          t5.objectStoreNames.contains("remoteDocumentChanges") && t5.deleteObjectStore("remoteDocumentChanges");
        }(t4), function(t5) {
          var e2 = t5.objectStore(cr.store);
          e2.createIndex(cr.readTimeIndex, cr.readTimeIndexPath, {
            unique: false
          }), e2.createIndex(cr.collectionReadTimeIndex, cr.collectionReadTimeIndexPath, {
            unique: false
          });
        }(e);
      })), n2 < 10 && r2 >= 10 && (s = s.next(function() {
        return i.$e(o);
      })), n2 < 11 && r2 >= 11 && (s = s.next(function() {
        !function(t5) {
          t5.createObjectStore(vr.store, {
            keyPath: vr.keyPath
          });
        }(t4), function(t5) {
          t5.createObjectStore(mr.store, {
            keyPath: mr.keyPath
          });
        }(t4);
      })), s;
    }, t3.prototype.Ce = function(t4) {
      var e = 0;
      return t4.store(cr.store).qt(function(t5, n2) {
        e += ii(n2);
      }).next(function() {
        var n2 = new hr(e);
        return t4.store(hr.store).put(hr.key, n2);
      });
    }, t3.prototype.De = function(t4) {
      var e = this, n2 = t4.store(ir.store), r2 = t4.store(or.store);
      return n2.kt().next(function(n3) {
        return Er.forEach(n3, function(n4) {
          var i = IDBKeyRange.bound([n4.userId, -1], [n4.userId, n4.lastAcknowledgedBatchId]);
          return r2.kt(or.userMutationsIndex, i).next(function(r3) {
            return Er.forEach(r3, function(r4) {
              k2(r4.userId === n4.userId);
              var i2 = Kr(e.D, r4);
              return ri(t4, n4.userId, i2).next(function() {
              });
            });
          });
        });
      });
    }, /**
     * Ensures that every document in the remote document cache has a corresponding sentinel row
     * with a sequence number. Missing rows are given the most recently used sequence number.
     */
    t3.prototype.xe = function(t4) {
      var e = t4.store(lr.store), n2 = t4.store(cr.store);
      return t4.store(dr.store).get(dr.key).next(function(t5) {
        var r2 = [];
        return n2.qt(function(n3, i) {
          var o = new z2(n3), s = function(t6) {
            return [0, $n(t6)];
          }(o);
          r2.push(e.get(s).next(function(n4) {
            return n4 ? Er.resolve() : function(n5) {
              return e.put(new lr(0, $n(n5), t5.highestListenSequenceNumber));
            }(o);
          }));
        }).next(function() {
          return Er.waitFor(r2);
        });
      });
    }, t3.prototype.Ne = function(t4, e) {
      t4.createObjectStore(pr.store, {
        keyPath: pr.keyPath
      });
      var n2 = e.store(pr.store), r2 = new $r(), i = function(t5) {
        if (r2.add(t5)) {
          var e2 = t5.lastSegment(), i2 = t5.popLast();
          return n2.put({
            collectionId: e2,
            parent: $n(i2)
          });
        }
      };
      return e.store(cr.store).qt({
        Bt: true
      }, function(t5, e2) {
        var n3 = new z2(t5);
        return i(n3.popLast());
      }).next(function() {
        return e.store(sr.store).qt({
          Bt: true
        }, function(t5, e2) {
          t5[0];
          var n3 = t5[1], r3 = (t5[2], er(n3));
          return i(r3.popLast());
        });
      });
    }, t3.prototype.$e = function(t4) {
      var e = this, n2 = t4.store(fr.store);
      return n2.qt(function(t5, r2) {
        var i = zr(r2), o = Qr(e.D, i);
        return n2.put(o);
      });
    }, t3;
  }()
);
function Ci(t3) {
  t3.createObjectStore(lr.store, {
    keyPath: lr.keyPath
  }).createIndex(lr.documentTargetsIndex, lr.documentTargetsKeyPath, {
    unique: true
  }), // NOTE: This is unique only because the TargetId is the suffix.
  t3.createObjectStore(fr.store, {
    keyPath: fr.keyPath
  }).createIndex(fr.queryTargetsIndexName, fr.queryTargetsKeyPath, {
    unique: true
  }), t3.createObjectStore(dr.store);
}
var xi = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Li = (
  /** @class */
  function() {
    function t3(e, n2, r2, i, o, s, u, a, c, h2) {
      if (this.allowTabSynchronization = e, this.persistenceKey = n2, this.clientId = r2, this.Fe = o, this.window = s, this.document = u, this.Oe = c, this.ke = h2, this.Me = null, this.Le = false, this.isPrimary = false, this.networkEnabled = true, /** Our window.unload handler, if registered. */
      this.Be = null, this.inForeground = false, /** Our 'visibilitychange' listener if registered. */
      this.qe = null, /** The client metadata refresh task. */
      this.Ue = null, /** The last time we garbage collected the client metadata object store. */
      this.Qe = Number.NEGATIVE_INFINITY, /** A listener to notify on primary state changes. */
      this.Ke = function(t4) {
        return Promise.resolve();
      }, !t3.At())
        throw new G2(j.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
      this.referenceDelegate = new bi(this, i), this.We = n2 + "main", this.D = new Fr(a), this.je = new _r(this.We, 11, new ki(this.D)), this.Ge = new fi(this.referenceDelegate, this.D), this.Gt = new Zr(), this.ze = function(t4, e2) {
        return new _i(t4, e2);
      }(this.D, this.Gt), this.He = new Hr(), this.window && this.window.localStorage ? this.Je = this.window.localStorage : (this.Je = null, false === h2 && S2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
    }
    return t3.prototype.start = function() {
      var t4 = this;
      return this.Ye().then(function() {
        if (!t4.isPrimary && !t4.allowTabSynchronization)
          throw new G2(j.FAILED_PRECONDITION, xi);
        return t4.Xe(), t4.Ze(), t4.tn(), t4.runTransaction("getHighestListenSequenceNumber", "readonly", function(e) {
          return t4.Ge.getHighestSequenceNumber(e);
        });
      }).then(function(e) {
        t4.Me = new I2(e, t4.Oe);
      }).then(function() {
        t4.Le = true;
      }).catch(function(e) {
        return t4.je && t4.je.close(), Promise.reject(e);
      });
    }, /**
     * Registers a listener that gets called when the primary state of the
     * instance changes. Upon registering, this listener is invoked immediately
     * with the current primary state.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t3.prototype.en = function(t4) {
      var e = this;
      return this.Ke = function(n2) {
        return __awaiter(e, void 0, void 0, function() {
          return __generator(this, function(e2) {
            return this.started ? [2, t4(n2)] : [
              2
              /*return*/
            ];
          });
        });
      }, t4(this.isPrimary);
    }, /**
     * Registers a listener that gets called when the database receives a
     * version change event indicating that it has deleted.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t3.prototype.setDatabaseDeletedListener = function(t4) {
      var e = this;
      this.je.Ct(function(n2) {
        return __awaiter(e, void 0, void 0, function() {
          return __generator(this, function(e2) {
            switch (e2.label) {
              case 0:
                return null === n2.newVersion ? [4, t4()] : [3, 2];
              case 1:
                e2.sent(), e2.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    }, /**
     * Adjusts the current network state in the client's metadata, potentially
     * affecting the primary lease.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t3.prototype.setNetworkEnabled = function(t4) {
      var e = this;
      this.networkEnabled !== t4 && (this.networkEnabled = t4, // Schedule a primary lease refresh for immediate execution. The eventual
      // lease update will be propagated via `primaryStateListener`.
      this.Fe.enqueueAndForget(function() {
        return __awaiter(e, void 0, void 0, function() {
          return __generator(this, function(t5) {
            switch (t5.label) {
              case 0:
                return this.started ? [4, this.Ye()] : [3, 2];
              case 1:
                t5.sent(), t5.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }));
    }, /**
     * Updates the client metadata in IndexedDb and attempts to either obtain or
     * extend the primary lease for the local client. Asynchronously notifies the
     * primary state listener if the client either newly obtained or released its
     * primary lease.
     */
    t3.prototype.Ye = function() {
      var t4 = this;
      return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", function(e) {
        return Oi(e).put(new yr(t4.clientId, Date.now(), t4.networkEnabled, t4.inForeground)).next(function() {
          if (t4.isPrimary)
            return t4.nn(e).next(function(e2) {
              e2 || (t4.isPrimary = false, t4.Fe.enqueueRetryable(function() {
                return t4.Ke(false);
              }));
            });
        }).next(function() {
          return t4.sn(e);
        }).next(function(n2) {
          return t4.isPrimary && !n2 ? t4.rn(e).next(function() {
            return false;
          }) : !!n2 && t4.on(e).next(function() {
            return true;
          });
        });
      }).catch(function(e) {
        if (Nr(e))
          return _("IndexedDbPersistence", "Failed to extend owner lease: ", e), t4.isPrimary;
        if (!t4.allowTabSynchronization)
          throw e;
        return _("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), /* isPrimary= */
        false;
      }).then(function(e) {
        t4.isPrimary !== e && t4.Fe.enqueueRetryable(function() {
          return t4.Ke(e);
        }), t4.isPrimary = e;
      });
    }, t3.prototype.nn = function(t4) {
      var e = this;
      return Ri(t4).get(rr.key).next(function(t5) {
        return Er.resolve(e.cn(t5));
      });
    }, t3.prototype.an = function(t4) {
      return Oi(t4).delete(this.clientId);
    }, /**
     * If the garbage collection threshold has passed, prunes the
     * RemoteDocumentChanges and the ClientMetadata store based on the last update
     * time of all clients.
     */
    t3.prototype.un = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e, n2, r2, i = this;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              return !this.isPrimary || this.hn(this.Qe, 18e5) ? [3, 2] : (this.Qe = Date.now(), [4, this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", function(t5) {
                var e2 = Rr(t5, yr.store);
                return e2.kt().next(function(t6) {
                  var n3 = i.ln(t6, 18e5), r3 = t6.filter(function(t7) {
                    return -1 === n3.indexOf(t7);
                  });
                  return Er.forEach(r3, function(t7) {
                    return e2.delete(t7.clientId);
                  }).next(function() {
                    return r3;
                  });
                });
              }).catch(function() {
                return [];
              })]);
            case 1:
              if (t4 = o.sent(), this.Je)
                for (e = 0, n2 = t4; e < n2.length; e++)
                  r2 = n2[e], this.Je.removeItem(this.fn(r2.clientId));
              o.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Schedules a recurring timer to update the client metadata and to either
     * extend or acquire the primary lease if the client is eligible.
     */
    t3.prototype.tn = function() {
      var t4 = this;
      this.Ue = this.Fe.enqueueAfterDelay("client_metadata_refresh", 4e3, function() {
        return t4.Ye().then(function() {
          return t4.un();
        }).then(function() {
          return t4.tn();
        });
      });
    }, /** Checks whether `client` is the local client. */
    t3.prototype.cn = function(t4) {
      return !!t4 && t4.ownerId === this.clientId;
    }, /**
     * Evaluate the state of all active clients and determine whether the local
     * client is or can act as the holder of the primary lease. Returns whether
     * the client is eligible for the lease, but does not actually acquire it.
     * May return 'false' even if there is no active leaseholder and another
     * (foreground) client should become leaseholder instead.
     */
    t3.prototype.sn = function(t4) {
      var e = this;
      return this.ke ? Er.resolve(true) : Ri(t4).get(rr.key).next(function(n2) {
        if (null !== n2 && e.hn(n2.leaseTimestampMs, 5e3) && !e.dn(n2.ownerId)) {
          if (e.cn(n2) && e.networkEnabled)
            return true;
          if (!e.cn(n2)) {
            if (!n2.allowTabSynchronization)
              throw new G2(j.FAILED_PRECONDITION, xi);
            return false;
          }
        }
        return !(!e.networkEnabled || !e.inForeground) || Oi(t4).kt().next(function(t5) {
          return void 0 === e.ln(t5, 5e3).find(function(t6) {
            if (e.clientId !== t6.clientId) {
              var n3 = !e.networkEnabled && t6.networkEnabled, r2 = !e.inForeground && t6.inForeground, i = e.networkEnabled === t6.networkEnabled;
              if (n3 || r2 && i)
                return true;
            }
            return false;
          });
        });
      }).next(function(t5) {
        return e.isPrimary !== t5 && _("IndexedDbPersistence", "Client " + (t5 ? "is" : "is not") + " eligible for a primary lease."), t5;
      });
    }, t3.prototype.shutdown = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4 = this;
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return this.Le = false, this.wn(), this.Ue && (this.Ue.cancel(), this.Ue = null), this._n(), this.mn(), [4, this.je.runTransaction("shutdown", "readwrite", [rr.store, yr.store], function(e2) {
                var n2 = new Lr(e2, I2.o);
                return t4.rn(n2).next(function() {
                  return t4.an(n2);
                });
              })];
            case 1:
              return e.sent(), this.je.close(), // Remove the entry marking the client as zombied from LocalStorage since
              // we successfully deleted its metadata from IndexedDb.
              this.yn(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Returns clients that are not zombied and have an updateTime within the
     * provided threshold.
     */
    t3.prototype.ln = function(t4, e) {
      var n2 = this;
      return t4.filter(function(t5) {
        return n2.hn(t5.updateTimeMs, e) && !n2.dn(t5.clientId);
      });
    }, /**
     * Returns the IDs of the clients that are currently active. If multi-tab
     * is not supported, returns an array that only contains the local client's
     * ID.
     *
     * PORTING NOTE: This is only used for Web multi-tab.
     */
    t3.prototype.gn = function() {
      var t4 = this;
      return this.runTransaction("getActiveClients", "readonly", function(e) {
        return Oi(e).kt().next(function(e2) {
          return t4.ln(e2, 18e5).map(function(t5) {
            return t5.clientId;
          });
        });
      });
    }, Object.defineProperty(t3.prototype, "started", {
      get: function() {
        return this.Le;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.getMutationQueue = function(t4) {
      return oi.Ht(t4, this.D, this.Gt, this.referenceDelegate);
    }, t3.prototype.getTargetCache = function() {
      return this.Ge;
    }, t3.prototype.getRemoteDocumentCache = function() {
      return this.ze;
    }, t3.prototype.getIndexManager = function() {
      return this.Gt;
    }, t3.prototype.getBundleCache = function() {
      return this.He;
    }, t3.prototype.runTransaction = function(t4, e, n2) {
      var r2 = this;
      _("IndexedDbPersistence", "Starting transaction:", t4);
      var i, o = "readonly" === e ? "readonly" : "readwrite";
      return this.je.runTransaction(t4, o, gr, function(o2) {
        return i = new Lr(o2, r2.Me ? r2.Me.next() : I2.o), "readwrite-primary" === e ? r2.nn(i).next(function(t5) {
          return !!t5 || r2.sn(i);
        }).next(function(e2) {
          if (!e2)
            throw S2("Failed to obtain primary lease for action '" + t4 + "'."), r2.isPrimary = false, r2.Fe.enqueueRetryable(function() {
              return r2.Ke(false);
            }), new G2(j.FAILED_PRECONDITION, wr);
          return n2(i);
        }).next(function(t5) {
          return r2.on(i).next(function() {
            return t5;
          });
        }) : r2.pn(i).next(function() {
          return n2(i);
        });
      }).then(function(t5) {
        return i.raiseOnCommittedEvent(), t5;
      });
    }, /**
     * Verifies that the current tab is the primary leaseholder or alternatively
     * that the leaseholder has opted into multi-tab synchronization.
     */
    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer
    // be turned off.
    t3.prototype.pn = function(t4) {
      var e = this;
      return Ri(t4).get(rr.key).next(function(t5) {
        if (null !== t5 && e.hn(t5.leaseTimestampMs, 5e3) && !e.dn(t5.ownerId) && !e.cn(t5) && !(e.ke || e.allowTabSynchronization && t5.allowTabSynchronization))
          throw new G2(j.FAILED_PRECONDITION, xi);
      });
    }, /**
     * Obtains or extends the new primary lease for the local client. This
     * method does not verify that the client is eligible for this lease.
     */
    t3.prototype.on = function(t4) {
      var e = new rr(this.clientId, this.allowTabSynchronization, Date.now());
      return Ri(t4).put(rr.key, e);
    }, t3.At = function() {
      return _r.At();
    }, /** Checks the primary lease and removes it if we are the current primary. */
    t3.prototype.rn = function(t4) {
      var e = this, n2 = Ri(t4);
      return n2.get(rr.key).next(function(t5) {
        return e.cn(t5) ? (_("IndexedDbPersistence", "Releasing primary lease."), n2.delete(rr.key)) : Er.resolve();
      });
    }, /** Verifies that `updateTimeMs` is within `maxAgeMs`. */
    t3.prototype.hn = function(t4, e) {
      var n2 = Date.now();
      return !(t4 < n2 - e || t4 > n2 && (S2("Detected an update time that is in the future: " + t4 + " > " + n2), 1));
    }, t3.prototype.Xe = function() {
      var t4 = this;
      null !== this.document && "function" == typeof this.document.addEventListener && (this.qe = function() {
        t4.Fe.enqueueAndForget(function() {
          return t4.inForeground = "visible" === t4.document.visibilityState, t4.Ye();
        });
      }, this.document.addEventListener("visibilitychange", this.qe), this.inForeground = "visible" === this.document.visibilityState);
    }, t3.prototype._n = function() {
      this.qe && (this.document.removeEventListener("visibilitychange", this.qe), this.qe = null);
    }, /**
     * Attaches a window.unload handler that will synchronously write our
     * clientId to a "zombie client id" location in LocalStorage. This can be used
     * by tabs trying to acquire the primary lease to determine that the lease
     * is no longer valid even if the timestamp is recent. This is particularly
     * important for the refresh case (so the tab correctly re-acquires the
     * primary lease). LocalStorage is used for this rather than IndexedDb because
     * it is a synchronous API and so can be used reliably from  an unload
     * handler.
     */
    t3.prototype.Ze = function() {
      var t4, e = this;
      "function" == typeof (null === (t4 = this.window) || void 0 === t4 ? void 0 : t4.addEventListener) && (this.Be = function() {
        e.wn(), e.Fe.enqueueAndForget(function() {
          return e.shutdown();
        });
      }, this.window.addEventListener("unload", this.Be));
    }, t3.prototype.mn = function() {
      this.Be && (this.window.removeEventListener("unload", this.Be), this.Be = null);
    }, /**
     * Returns whether a client is "zombied" based on its LocalStorage entry.
     * Clients become zombied when their tab closes without running all of the
     * cleanup logic in `shutdown()`.
     */
    t3.prototype.dn = function(t4) {
      var e;
      try {
        var n2 = null !== (null === (e = this.Je) || void 0 === e ? void 0 : e.getItem(this.fn(t4)));
        return _("IndexedDbPersistence", "Client '" + t4 + "' " + (n2 ? "is" : "is not") + " zombied in LocalStorage"), n2;
      } catch (t5) {
        return S2("IndexedDbPersistence", "Failed to get zombied client id.", t5), false;
      }
    }, /**
     * Record client as zombied (a client that had its tab closed). Zombied
     * clients are ignored during primary tab selection.
     */
    t3.prototype.wn = function() {
      if (this.Je)
        try {
          this.Je.setItem(this.fn(this.clientId), String(Date.now()));
        } catch (t4) {
          S2("Failed to set zombie client id.", t4);
        }
    }, /** Removes the zombied client entry if it exists. */
    t3.prototype.yn = function() {
      if (this.Je)
        try {
          this.Je.removeItem(this.fn(this.clientId));
        } catch (t4) {
        }
    }, t3.prototype.fn = function(t4) {
      return "firestore_zombie_" + this.persistenceKey + "_" + t4;
    }, t3;
  }()
);
function Ri(t3) {
  return Rr(t3, rr.store);
}
function Oi(t3) {
  return Rr(t3, yr.store);
}
function Pi(t3, e) {
  var n2 = t3.projectId;
  return t3.isDefaultDatabase || (n2 += "." + t3.database), "firestore/" + e + "/" + n2 + "/";
}
var Mi = function(t3, e) {
  this.progress = t3, this.En = e;
};
var Fi = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.ze = t4, this.Tn = e, this.Gt = n2;
    }
    return t3.prototype.In = function(t4, e) {
      var n2 = this;
      return this.Tn.getAllMutationBatchesAffectingDocumentKey(t4, e).next(function(r2) {
        return n2.An(t4, e, r2);
      });
    }, /** Internal version of `getDocument` that allows reusing batches. */
    t3.prototype.An = function(t4, e, n2) {
      return this.ze.getEntry(t4, e).next(function(t5) {
        for (var r2 = 0, i = n2; r2 < i.length; r2++) {
          t5 = i[r2].applyToLocalView(e, t5);
        }
        return t5;
      });
    }, // Returns the view of the given `docs` as they would appear after applying
    // all mutations in the given `batches`.
    t3.prototype.Rn = function(t4, e, n2) {
      var r2 = tn();
      return e.forEach(function(t5, e2) {
        for (var i = 0, o = n2; i < o.length; i++) {
          e2 = o[i].applyToLocalView(t5, e2);
        }
        r2 = r2.insert(t5, e2);
      }), r2;
    }, /**
     * Gets the local view of the documents identified by `keys`.
     *
     * If we don't have cached state for a document in `keys`, a NoDocument will
     * be stored for that key in the resulting set.
     */
    t3.prototype.bn = function(t4, e) {
      var n2 = this;
      return this.ze.getEntries(t4, e).next(function(e2) {
        return n2.vn(t4, e2);
      });
    }, /**
     * Similar to `getDocuments`, but creates the local view from the given
     * `baseDocs` without retrieving documents from the local store.
     */
    t3.prototype.vn = function(t4, e) {
      var n2 = this;
      return this.Tn.getAllMutationBatchesAffectingDocumentKeys(t4, e).next(function(r2) {
        var i = n2.Rn(t4, e, r2), o = Ze();
        return i.forEach(function(t5, e2) {
          e2 || (e2 = new wt(t5, ie.min())), o = o.insert(t5, e2);
        }), o;
      });
    }, /**
     * Performs a query against the local view of all documents.
     *
     * @param transaction - The persistence transaction.
     * @param query - The query to match documents against.
     * @param sinceReadTime - If not set to SnapshotVersion.min(), return only
     *     documents that have been read since this snapshot version (exclusive).
     */
    t3.prototype.getDocumentsMatchingQuery = function(t4, e, n2) {
      return function(t5) {
        return H2.isDocumentKey(t5.path) && null === t5.collectionGroup && 0 === t5.filters.length;
      }(e) ? this.Pn(t4, e.path) : Ht(e) ? this.Vn(t4, e, n2) : this.Sn(t4, e, n2);
    }, t3.prototype.Pn = function(t4, e) {
      return this.In(t4, new H2(e)).next(function(t5) {
        var e2 = nn();
        return t5 instanceof gt && (e2 = e2.insert(t5.key, t5)), e2;
      });
    }, t3.prototype.Vn = function(t4, e, n2) {
      var r2 = this, i = e.collectionGroup, o = nn();
      return this.Gt.getCollectionParents(t4, i).next(function(s) {
        return Er.forEach(s, function(s2) {
          var u = function(t5, e2) {
            return new Bt(
              e2,
              /*collectionGroup=*/
              null,
              t5.explicitOrderBy.slice(),
              t5.filters.slice(),
              t5.limit,
              t5.limitType,
              t5.startAt,
              t5.endAt
            );
          }(e, s2.child(i));
          return r2.Sn(t4, u, n2).next(function(t5) {
            t5.forEach(function(t6, e2) {
              o = o.insert(t6, e2);
            });
          });
        }).next(function() {
          return o;
        });
      });
    }, t3.prototype.Sn = function(t4, e, n2) {
      var r2, i, o = this;
      return this.ze.getDocumentsMatchingQuery(t4, e, n2).next(function(n3) {
        return r2 = n3, o.Tn.getAllMutationBatchesAffectingQuery(t4, e);
      }).next(function(e2) {
        return i = e2, o.Dn(t4, i, r2).next(function(t5) {
          r2 = t5;
          for (var e3 = 0, n3 = i; e3 < n3.length; e3++)
            for (var o2 = n3[e3], s = 0, u = o2.mutations; s < u.length; s++) {
              var a = u[s], c = a.key, h2 = Ce(a, r2.get(c), o2.localWriteTime);
              r2 = h2 instanceof gt ? r2.insert(c, h2) : r2.remove(c);
            }
        });
      }).next(function() {
        return r2.forEach(function(t5, n3) {
          ee(e, n3) || (r2 = r2.remove(t5));
        }), r2;
      });
    }, t3.prototype.Dn = function(t4, e, n2) {
      for (var r2 = un(), i = 0, o = e; i < o.length; i++)
        for (var s = 0, u = o[i].mutations; s < u.length; s++) {
          var a = u[s];
          a instanceof Pe && null === n2.get(a.key) && (r2 = r2.add(a.key));
        }
      var c = n2;
      return this.ze.getEntries(t4, r2).next(function(t5) {
        return t5.forEach(function(t6, e2) {
          null !== e2 && e2 instanceof gt && (c = c.insert(t6, e2));
        }), c;
      });
    }, t3;
  }()
);
var qi = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.targetId = t4, this.fromCache = e, this.Cn = n2, this.xn = r2;
    }
    return t3.Nn = function(e, n2) {
      for (var r2 = un(), i = un(), o = 0, s = n2.docChanges; o < s.length; o++) {
        var u = s[o];
        switch (u.type) {
          case 0:
            r2 = r2.add(u.doc.key);
            break;
          case 1:
            i = i.add(u.doc.key);
        }
      }
      return new t3(e, n2.fromCache, r2, i);
    }, t3;
  }()
);
var Vi = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.$n = function(t4) {
      this.Fn = t4;
    }, /** Returns all local documents matching the specified query. */
    t3.prototype.getDocumentsMatchingQuery = function(t4, n2, r2, i) {
      var o = this;
      return function(t5) {
        return 0 === t5.filters.length && null === t5.limit && null == t5.startAt && null == t5.endAt && (0 === t5.explicitOrderBy.length || 1 === t5.explicitOrderBy.length && t5.explicitOrderBy[0].field.isKeyField());
      }(n2) || r2.isEqual(ie.min()) ? this.On(t4, n2) : this.Fn.bn(t4, i).next(function(s) {
        var u = o.kn(n2, s);
        return (Kt(n2) || zt(n2)) && o.Mn(n2.limitType, u, i, r2) ? o.On(t4, n2) : (T2() <= LogLevel.DEBUG && _("QueryEngine", "Re-using previous result from %s to execute query: %s", r2.toString(), te(n2)), o.Fn.getDocumentsMatchingQuery(t4, n2, r2).next(function(t5) {
          return u.forEach(function(e) {
            t5 = t5.insert(e.key, e);
          }), t5;
        }));
      });
    }, /** Applies the query filter and sorting to the provided documents.  */
    t3.prototype.kn = function(t4, e) {
      var n2 = new Je(ne(t4));
      return e.forEach(function(e2, r2) {
        r2 instanceof gt && ee(t4, r2) && (n2 = n2.add(r2));
      }), n2;
    }, /**
     * Determines if a limit query needs to be refilled from cache, making it
     * ineligible for index-free execution.
     *
     * @param sortedPreviousResults - The documents that matched the query when it
     * was last synchronized, sorted by the query's comparator.
     * @param remoteKeys - The document keys that matched the query at the last
     * snapshot.
     * @param limboFreeSnapshotVersion - The version of the snapshot when the
     * query was last synchronized.
     */
    t3.prototype.Mn = function(t4, e, n2, r2) {
      if (n2.size !== e.size)
        return true;
      var i = "F" === t4 ? e.last() : e.first();
      return !!i && (i.hasPendingWrites || i.version.compareTo(r2) > 0);
    }, t3.prototype.On = function(t4, n2) {
      return T2() <= LogLevel.DEBUG && _("QueryEngine", "Using full collection scan to execute query:", te(n2)), this.Fn.getDocumentsMatchingQuery(t4, n2, ie.min());
    }, t3;
  }()
);
var Ui = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.persistence = t4, this.Ln = e, this.D = r2, /**
           * Maps a targetID to data about its target.
           *
           * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
           * of `applyRemoteEvent()` idempotent.
           */
      this.Bn = new We(R2), /** Maps a target to its targetID. */
      // TODO(wuandy): Evaluate if TargetId can be part of Target.
      this.qn = new Ei(function(t5) {
        return Tt(t5);
      }, _t), /**
           * The read time of the last entry processed by `getNewDocumentChanges()`.
           *
           * PORTING NOTE: This is only used for multi-tab synchronization.
           */
      this.Un = ie.min(), this.Tn = t4.getMutationQueue(n2), this.Qn = t4.getRemoteDocumentCache(), this.Ge = t4.getTargetCache(), this.Kn = new Fi(this.Qn, this.Tn, this.persistence.getIndexManager()), this.He = t4.getBundleCache(), this.Ln.$n(this.Kn);
    }
    return t3.prototype.collectGarbage = function(t4) {
      var e = this;
      return this.persistence.runTransaction("Collect garbage", "readwrite-primary", function(n2) {
        return t4.collect(n2, e.Bn);
      });
    }, t3;
  }()
);
function Bi(t3, e, n2, r2) {
  return new Ui(t3, e, n2, r2);
}
function ji(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          return n2 = C(t3), r2 = n2.Tn, i = n2.Kn, [4, n2.persistence.runTransaction("Handle user change", "readonly", function(t4) {
            var o2;
            return n2.Tn.getAllMutationBatches(t4).next(function(s2) {
              return o2 = s2, r2 = n2.persistence.getMutationQueue(e), // Recreate our LocalDocumentsView using the new
              // MutationQueue.
              i = new Fi(n2.Qn, r2, n2.persistence.getIndexManager()), r2.getAllMutationBatches(t4);
            }).next(function(e2) {
              for (var n3 = [], r3 = [], s2 = un(), u = 0, a = o2; u < a.length; u++) {
                var c = a[u];
                n3.push(c.batchId);
                for (var h2 = 0, f = c.mutations; h2 < f.length; h2++) {
                  var l = f[h2];
                  s2 = s2.add(l.key);
                }
              }
              for (var d = 0, p2 = e2; d < p2.length; d++) {
                var y2 = p2[d];
                r3.push(y2.batchId);
                for (var v2 = 0, m = y2.mutations; v2 < m.length; v2++) {
                  var g = m[v2];
                  s2 = s2.add(g.key);
                }
              }
              return i.bn(t4, s2).next(function(t5) {
                return {
                  Wn: t5,
                  removedBatchIds: n3,
                  addedBatchIds: r3
                };
              });
            });
          })];
        case 1:
          return o = s.sent(), [2, (n2.Tn = r2, n2.Kn = i, n2.Ln.$n(n2.Kn), o)];
      }
    });
  });
}
function Gi(t3, e) {
  var n2 = C(t3);
  return n2.persistence.runTransaction("Acknowledge batch", "readwrite-primary", function(t4) {
    var r2 = e.batch.keys(), i = n2.Qn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t5, e2, n3, r3) {
      var i2 = n3.batch, o = i2.keys(), s = Er.resolve();
      return o.forEach(function(t6) {
        s = s.next(function() {
          return r3.getEntry(e2, t6);
        }).next(function(e3) {
          var o2 = e3, s2 = n3.docVersions.get(t6);
          k2(null !== s2), (!o2 || o2.version.compareTo(s2) < 0) && ((o2 = i2.applyToRemoteDocument(t6, o2, n3)) && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          r3.addEntry(o2, n3.commitVersion));
        });
      }), s.next(function() {
        return t5.Tn.removeMutationBatch(e2, i2);
      });
    }(n2, t4, e, i).next(function() {
      return i.apply(t4);
    }).next(function() {
      return n2.Tn.performConsistencyCheck(t4);
    }).next(function() {
      return n2.Kn.bn(t4, r2);
    });
  });
}
function Ki(t3) {
  var e = C(t3);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", function(t4) {
    return e.Ge.getLastRemoteSnapshotVersion(t4);
  });
}
function zi(t3, e) {
  var n2 = C(t3), r2 = e.snapshotVersion, i = n2.Bn;
  return n2.persistence.runTransaction("Apply remote event", "readwrite-primary", function(t4) {
    var o = n2.Qn.newChangeBuffer({
      trackRemovals: true
    });
    i = n2.Bn;
    var s = [];
    e.targetChanges.forEach(function(e2, o2) {
      var u2 = i.get(o2);
      if (u2) {
        s.push(n2.Ge.removeMatchingKeys(t4, e2.removedDocuments, o2).next(function() {
          return n2.Ge.addMatchingKeys(t4, e2.addedDocuments, o2);
        }));
        var a2 = e2.resumeToken;
        if (a2.approximateByteSize() > 0) {
          var c = u2.withResumeToken(a2, r2).withSequenceNumber(t4.currentSequenceNumber);
          i = i.insert(o2, c), // Update the target data if there are target changes (or if
          // sufficient time has passed since the last update).
          /**
          * Returns true if the newTargetData should be persisted during an update of
          * an active target. TargetData should always be persisted when a target is
          * being released and should not call this function.
          *
          * While the target is active, TargetData updates can be omitted when nothing
          * about the target has changed except metadata like the resume token or
          * snapshot version. Occasionally it's worth the extra write to prevent these
          * values from getting too stale after a crash, but this doesn't have to be
          * too frequent.
          */
          function(t5, e3, n3) {
            return k2(e3.resumeToken.approximateByteSize() > 0), 0 === t5.resumeToken.approximateByteSize() || // Don't allow resume token changes to be buffered indefinitely. This
            // allows us to be reasonably up-to-date after a crash and avoids needing
            // to loop over all active queries on shutdown. Especially in the browser
            // we may not get time to do anything interesting while the current tab is
            // closing.
            (e3.snapshotVersion.toMicroseconds() - t5.snapshotVersion.toMicroseconds() >= 3e8 || n3.addedDocuments.size + n3.modifiedDocuments.size + n3.removedDocuments.size > 0);
          }(u2, c, e2) && s.push(n2.Ge.updateTargetData(t4, c));
        }
      }
    });
    var u = Ze();
    if (e.documentUpdates.forEach(function(r3, i2) {
      e.resolvedLimboDocuments.has(r3) && s.push(n2.persistence.referenceDelegate.updateLimboDocument(t4, r3));
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all the remote
    // documents in advance in a single call.
    s.push(Qi(t4, o, e.documentUpdates, r2, void 0).next(function(t5) {
      u = t5;
    })), !r2.isEqual(ie.min())) {
      var a = n2.Ge.getLastRemoteSnapshotVersion(t4).next(function(e2) {
        return n2.Ge.setTargetsMetadata(t4, t4.currentSequenceNumber, r2);
      });
      s.push(a);
    }
    return Er.waitFor(s).next(function() {
      return o.apply(t4);
    }).next(function() {
      return n2.Kn.vn(t4, u);
    });
  }).then(function(t4) {
    return n2.Bn = i, t4;
  });
}
function Qi(t3, e, n2, r2, i) {
  var o = un();
  return n2.forEach(function(t4) {
    return o = o.add(t4);
  }), e.getEntries(t3, o).next(function(t4) {
    var o2 = Ze();
    return n2.forEach(function(n3, s) {
      var u = t4.get(n3), a = (null == i ? void 0 : i.get(n3)) || r2;
      s instanceof wt && s.version.isEqual(ie.min()) ? (
        // NoDocuments with SnapshotVersion.min() are used in manufactured
        // events. We remove these documents from cache since we lost
        // access.
        (e.removeEntry(n3, a), o2 = o2.insert(n3, s))
      ) : null == u || s.version.compareTo(u.version) > 0 || 0 === s.version.compareTo(u.version) && u.hasPendingWrites ? (e.addEntry(s, a), o2 = o2.insert(n3, s)) : _("LocalStore", "Ignoring outdated watch update for ", n3, ". Current version:", u.version, " Watch version:", s.version);
    }), o2;
  });
}
function Wi(t3, e) {
  var n2 = C(t3);
  return n2.persistence.runTransaction("Get next mutation batch", "readonly", function(t4) {
    return void 0 === e && (e = -1), n2.Tn.getNextMutationBatchAfterBatchId(t4, e);
  });
}
function Hi(t3, e) {
  var n2 = C(t3);
  return n2.persistence.runTransaction("Allocate target", "readwrite", function(t4) {
    var r2;
    return n2.Ge.getTargetData(t4, e).next(function(i) {
      return i ? (
        // This target has been listened to previously, so reuse the
        // previous targetID.
        // TODO(mcg): freshen last accessed date?
        (r2 = i, Er.resolve(r2))
      ) : n2.Ge.allocateTargetId(t4).next(function(i2) {
        return r2 = new Mr(e, i2, 0, t4.currentSequenceNumber), n2.Ge.addTargetData(t4, r2).next(function() {
          return r2;
        });
      });
    });
  }).then(function(t4) {
    var r2 = n2.Bn.get(t4.targetId);
    return (null === r2 || t4.snapshotVersion.compareTo(r2.snapshotVersion) > 0) && (n2.Bn = n2.Bn.insert(t4.targetId, t4), n2.qn.set(e, t4.targetId)), t4;
  });
}
function Yi(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o, s;
    return __generator(this, function(u) {
      switch (u.label) {
        case 0:
          r2 = C(t3), i = r2.Bn.get(e), o = n2 ? "readwrite" : "readwrite-primary", u.label = 1;
        case 1:
          return u.trys.push([1, 4, , 5]), n2 ? [3, 3] : [4, r2.persistence.runTransaction("Release target", o, function(t4) {
            return r2.persistence.referenceDelegate.removeTarget(t4, i);
          })];
        case 2:
          u.sent(), u.label = 3;
        case 3:
          return [3, 5];
        case 4:
          if (!Nr(s = u.sent()))
            throw s;
          return _("LocalStore", "Failed to update sequence numbers for target " + e + ": " + s), [3, 5];
        case 5:
          return r2.Bn = r2.Bn.remove(e), r2.qn.delete(i.target), [
            2
            /*return*/
          ];
      }
    });
  });
}
function Ji(t3, e, n2) {
  var r2 = C(t3), i = ie.min(), o = un();
  return r2.persistence.runTransaction("Execute query", "readonly", function(t4) {
    return function(t5, e2, n3) {
      var r3 = C(t5), i2 = r3.qn.get(n3);
      return void 0 !== i2 ? Er.resolve(r3.Bn.get(i2)) : r3.Ge.getTargetData(e2, n3);
    }(r2, t4, Jt(e)).next(function(e2) {
      if (e2)
        return i = e2.lastLimboFreeSnapshotVersion, r2.Ge.getMatchingKeysForTargetId(t4, e2.targetId).next(function(t5) {
          o = t5;
        });
    }).next(function() {
      return r2.Ln.getDocumentsMatchingQuery(t4, e, n2 ? i : ie.min(), n2 ? o : un());
    }).next(function(t5) {
      return {
        documents: t5,
        jn: o
      };
    });
  });
}
function Xi(t3, e) {
  var n2 = C(t3), r2 = C(n2.Ge), i = n2.Bn.get(e);
  return i ? Promise.resolve(i.target) : n2.persistence.runTransaction("Get target data", "readonly", function(t4) {
    return r2.yt(t4, e).next(function(t5) {
      return t5 ? t5.target : null;
    });
  });
}
function $i(t3) {
  var e = C(t3);
  return e.persistence.runTransaction("Get new document changes", "readonly", function(t4) {
    return function(t5, e2, n2) {
      var r2 = C(t5), i = Ze(), o = Ur(n2), s = Ni(e2), u = IDBKeyRange.lowerBound(o, true);
      return s.qt({
        index: cr.readTimeIndex,
        range: u
      }, function(t6, e3) {
        var n3 = qr(r2.D, e3);
        i = i.insert(n3.key, n3), o = e3.readTime;
      }).next(function() {
        return {
          En: i,
          readTime: Br(o)
        };
      });
    }(e.Qn, t4, e.Un);
  }).then(function(t4) {
    var n2 = t4.En, r2 = t4.readTime;
    return e.Un = r2, n2;
  });
}
function Zi(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e;
    return __generator(this, function(n2) {
      return [2, (e = C(t3)).persistence.runTransaction("Synchronize last document change read time", "readonly", function(t4) {
        return function(t5) {
          var e2 = Ni(t5), n3 = ie.min();
          return e2.qt({
            index: cr.readTimeIndex,
            reverse: true
          }, function(t6, e3, r2) {
            e3.readTime && (n3 = Br(e3.readTime)), r2.done();
          }).next(function() {
            return n3;
          });
        }(t4);
      }).then(function(t4) {
        e.Un = t4;
      })];
    });
  });
}
function to(t3, e, n2, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var i, o, s, u, a, c, h2, f, l, d;
    return __generator(this, function(p2) {
      switch (p2.label) {
        case 0:
          for (i = C(t3), o = un(), s = Ze(), u = on(), a = 0, c = n2; a < c.length; a++)
            h2 = c[a], f = e.Gn(h2.metadata.name), h2.document && (o = o.add(f)), s = s.insert(f, e.zn(h2)), u = u.insert(f, e.Hn(h2.metadata.readTime));
          return l = i.Qn.newChangeBuffer({
            trackRemovals: true
          }), [4, Hi(i, function(t4) {
            return Jt(Gt(z2.fromString("__bundle__/docs/" + t4)));
          }(r2))];
        case 1:
          return d = p2.sent(), [2, i.persistence.runTransaction("Apply bundle documents", "readwrite", function(t4) {
            return Qi(t4, l, s, ie.min(), u).next(function(e2) {
              return l.apply(t4), e2;
            }).next(function(e2) {
              return i.Ge.removeMatchingKeysForTargetId(t4, d.targetId).next(function() {
                return i.Ge.addMatchingKeys(t4, o, d.targetId);
              }).next(function() {
                return i.Kn.vn(t4, e2);
              });
            });
          })];
      }
    });
  });
}
function eo(t3, e, n2) {
  return void 0 === n2 && (n2 = un()), __awaiter(this, void 0, void 0, function() {
    var r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          return [4, Hi(t3, Jt(Wr(e.bundledQuery)))];
        case 1:
          return r2 = o.sent(), [2, (i = C(t3)).persistence.runTransaction("Save named query", "readwrite", function(t4) {
            var o2 = Sn(e.readTime);
            if (r2.snapshotVersion.compareTo(o2) >= 0)
              return i.He.saveNamedQuery(t4, e);
            var s = r2.withResumeToken(Y2.EMPTY_BYTE_STRING, o2);
            return i.Bn = i.Bn.insert(s.targetId, s), i.Ge.updateTargetData(t4, s).next(function() {
              return i.Ge.removeMatchingKeysForTargetId(t4, r2.targetId);
            }).next(function() {
              return i.Ge.addMatchingKeys(t4, n2, r2.targetId);
            }).next(function() {
              return i.He.saveNamedQuery(t4, e);
            });
          })];
      }
    });
  });
}
var no = (
  /** @class */
  function() {
    function t3(t4) {
      this.D = t4, this.Jn = /* @__PURE__ */ new Map(), this.Yn = /* @__PURE__ */ new Map();
    }
    return t3.prototype.getBundleMetadata = function(t4, e) {
      return Er.resolve(this.Jn.get(e));
    }, t3.prototype.saveBundleMetadata = function(t4, e) {
      var n2;
      return this.Jn.set(e.id, {
        id: (n2 = e).id,
        version: n2.version,
        createTime: Sn(n2.createTime)
      }), Er.resolve();
    }, t3.prototype.getNamedQuery = function(t4, e) {
      return Er.resolve(this.Yn.get(e));
    }, t3.prototype.saveNamedQuery = function(t4, e) {
      return this.Yn.set(e.name, function(t5) {
        return {
          name: t5.name,
          query: Wr(t5.bundledQuery),
          readTime: Sn(t5.readTime)
        };
      }(e)), Er.resolve();
    }, t3;
  }()
);
var ro = (
  /** @class */
  function() {
    function t3() {
      this.Xn = new Je(io.Zn), // A set of outstanding references to a document sorted by target id.
      this.ts = new Je(io.es);
    }
    return t3.prototype.isEmpty = function() {
      return this.Xn.isEmpty();
    }, /** Adds a reference to the given document key for the given ID. */
    t3.prototype.addReference = function(t4, e) {
      var n2 = new io(t4, e);
      this.Xn = this.Xn.add(n2), this.ts = this.ts.add(n2);
    }, /** Add references to the given document keys for the given ID. */
    t3.prototype.ns = function(t4, e) {
      var n2 = this;
      t4.forEach(function(t5) {
        return n2.addReference(t5, e);
      });
    }, /**
     * Removes a reference to the given document key for the given
     * ID.
     */
    t3.prototype.removeReference = function(t4, e) {
      this.ss(new io(t4, e));
    }, t3.prototype.rs = function(t4, e) {
      var n2 = this;
      t4.forEach(function(t5) {
        return n2.removeReference(t5, e);
      });
    }, /**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */
    t3.prototype.os = function(t4) {
      var e = this, n2 = new H2(new z2([])), r2 = new io(n2, t4), i = new io(n2, t4 + 1), o = [];
      return this.ts.forEachInRange([r2, i], function(t5) {
        e.ss(t5), o.push(t5.key);
      }), o;
    }, t3.prototype.cs = function() {
      var t4 = this;
      this.Xn.forEach(function(e) {
        return t4.ss(e);
      });
    }, t3.prototype.ss = function(t4) {
      this.Xn = this.Xn.delete(t4), this.ts = this.ts.delete(t4);
    }, t3.prototype.us = function(t4) {
      var e = new H2(new z2([])), n2 = new io(e, t4), r2 = new io(e, t4 + 1), i = un();
      return this.ts.forEachInRange([n2, r2], function(t5) {
        i = i.add(t5.key);
      }), i;
    }, t3.prototype.containsKey = function(t4) {
      var e = new io(t4, 0), n2 = this.Xn.firstAfterOrEqual(e);
      return null !== n2 && t4.isEqual(n2.key);
    }, t3;
  }()
);
var io = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.key = t4, this.hs = e;
    }
    return t3.Zn = function(t4, e) {
      return H2.comparator(t4.key, e.key) || R2(t4.hs, e.hs);
    }, /** Compare by ID then by key */
    t3.es = function(t4, e) {
      return R2(t4.hs, e.hs) || H2.comparator(t4.key, e.key);
    }, t3;
  }()
);
var oo = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.Gt = t4, this.referenceDelegate = e, /**
           * The set of all mutations that have been sent but not yet been applied to
           * the backend.
           */
      this.Tn = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
      this.ls = 1, /** An ordered mapping between documents and the mutations batch IDs. */
      this.fs = new Je(io.Zn);
    }
    return t3.prototype.checkEmpty = function(t4) {
      return Er.resolve(0 === this.Tn.length);
    }, t3.prototype.addMutationBatch = function(t4, e, n2, r2) {
      var i = this.ls;
      this.ls++, this.Tn.length > 0 && this.Tn[this.Tn.length - 1];
      var o = new Or(i, e, n2, r2);
      this.Tn.push(o);
      for (var s = 0, u = r2; s < u.length; s++) {
        var a = u[s];
        this.fs = this.fs.add(new io(a.key, i)), this.Gt.addToCollectionParentIndex(t4, a.key.path.popLast());
      }
      return Er.resolve(o);
    }, t3.prototype.lookupMutationBatch = function(t4, e) {
      return Er.resolve(this.ds(e));
    }, t3.prototype.getNextMutationBatchAfterBatchId = function(t4, e) {
      var n2 = e + 1, r2 = this.ws(n2), i = r2 < 0 ? 0 : r2;
      return Er.resolve(this.Tn.length > i ? this.Tn[i] : null);
    }, t3.prototype.getHighestUnacknowledgedBatchId = function() {
      return Er.resolve(0 === this.Tn.length ? -1 : this.ls - 1);
    }, t3.prototype.getAllMutationBatches = function(t4) {
      return Er.resolve(this.Tn.slice());
    }, t3.prototype.getAllMutationBatchesAffectingDocumentKey = function(t4, e) {
      var n2 = this, r2 = new io(e, 0), i = new io(e, Number.POSITIVE_INFINITY), o = [];
      return this.fs.forEachInRange([r2, i], function(t5) {
        var e2 = n2.ds(t5.hs);
        o.push(e2);
      }), Er.resolve(o);
    }, t3.prototype.getAllMutationBatchesAffectingDocumentKeys = function(t4, e) {
      var n2 = this, r2 = new Je(R2);
      return e.forEach(function(t5) {
        var e2 = new io(t5, 0), i = new io(t5, Number.POSITIVE_INFINITY);
        n2.fs.forEachInRange([e2, i], function(t6) {
          r2 = r2.add(t6.hs);
        });
      }), Er.resolve(this._s(r2));
    }, t3.prototype.getAllMutationBatchesAffectingQuery = function(t4, e) {
      var n2 = e.path, r2 = n2.length + 1, i = n2;
      H2.isDocumentKey(i) || (i = i.child(""));
      var o = new io(new H2(i), 0), s = new Je(R2);
      return this.fs.forEachWhile(function(t5) {
        var e2 = t5.key.path;
        return !!n2.isPrefixOf(e2) && // Rows with document keys more than one segment longer than the query
        // path can't be matches. For example, a query on 'rooms' can't match
        // the document /rooms/abc/messages/xyx.
        // TODO(mcg): we'll need a different scanner when we implement
        // ancestor queries.
        (e2.length === r2 && (s = s.add(t5.hs)), true);
      }, o), Er.resolve(this._s(s));
    }, t3.prototype._s = function(t4) {
      var e = this, n2 = [];
      return t4.forEach(function(t5) {
        var r2 = e.ds(t5);
        null !== r2 && n2.push(r2);
      }), n2;
    }, t3.prototype.removeMutationBatch = function(t4, e) {
      var n2 = this;
      k2(0 === this.ys(e.batchId, "removed")), this.Tn.shift();
      var r2 = this.fs;
      return Er.forEach(e.mutations, function(i) {
        var o = new io(i.key, e.batchId);
        return r2 = r2.delete(o), n2.referenceDelegate.markPotentiallyOrphaned(t4, i.key);
      }).next(function() {
        n2.fs = r2;
      });
    }, t3.prototype.Xt = function(t4) {
    }, t3.prototype.containsKey = function(t4, e) {
      var n2 = new io(e, 0), r2 = this.fs.firstAfterOrEqual(n2);
      return Er.resolve(e.isEqual(r2 && r2.key));
    }, t3.prototype.performConsistencyCheck = function(t4) {
      return this.Tn.length, Er.resolve();
    }, /**
     * Finds the index of the given batchId in the mutation queue and asserts that
     * the resulting index is within the bounds of the queue.
     *
     * @param batchId - The batchId to search for
     * @param action - A description of what the caller is doing, phrased in passive
     * form (e.g. "acknowledged" in a routine that acknowledges batches).
     */
    t3.prototype.ys = function(t4, e) {
      return this.ws(t4);
    }, /**
     * Finds the index of the given batchId in the mutation queue. This operation
     * is O(1).
     *
     * @returns The computed index of the batch with the given batchId, based on
     * the state of the queue. Note this index can be negative if the requested
     * batchId has already been remvoed from the queue or past the end of the
     * queue if the batchId is larger than the last added batch.
     */
    t3.prototype.ws = function(t4) {
      return 0 === this.Tn.length ? 0 : t4 - this.Tn[0].batchId;
    }, /**
     * A version of lookupMutationBatch that doesn't return a promise, this makes
     * other functions that uses this code easier to read and more efficent.
     */
    t3.prototype.ds = function(t4) {
      var e = this.ws(t4);
      return e < 0 || e >= this.Tn.length ? null : this.Tn[e];
    }, t3;
  }()
);
var so = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.Gt = t4, this.gs = e, /** Underlying cache of documents and their read times. */
      this.docs = new We(H2.comparator), /** Size of all cached documents. */
      this.size = 0;
    }
    return t3.prototype.addEntry = function(t4, e, n2) {
      var r2 = e.key, i = this.docs.get(r2), o = i ? i.size : 0, s = this.gs(e);
      return this.docs = this.docs.insert(r2, {
        maybeDocument: e,
        size: s,
        readTime: n2
      }), this.size += s - o, this.Gt.addToCollectionParentIndex(t4, r2.path.popLast());
    }, /**
     * Removes the specified entry from the cache and updates the cache size as appropriate.
     *
     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()`.
     */
    t3.prototype.removeEntry = function(t4) {
      var e = this.docs.get(t4);
      e && (this.docs = this.docs.remove(t4), this.size -= e.size);
    }, t3.prototype.getEntry = function(t4, e) {
      var n2 = this.docs.get(e);
      return Er.resolve(n2 ? n2.maybeDocument : null);
    }, t3.prototype.getEntries = function(t4, e) {
      var n2 = this, r2 = tn();
      return e.forEach(function(t5) {
        var e2 = n2.docs.get(t5);
        r2 = r2.insert(t5, e2 ? e2.maybeDocument : null);
      }), Er.resolve(r2);
    }, t3.prototype.getDocumentsMatchingQuery = function(t4, e, n2) {
      for (var r2 = nn(), i = new H2(e.path.child("")), o = this.docs.getIteratorFrom(i); o.hasNext(); ) {
        var s = o.getNext(), u = s.key, a = s.value, c = a.maybeDocument, h2 = a.readTime;
        if (!e.path.isPrefixOf(u.path))
          break;
        h2.compareTo(n2) <= 0 || c instanceof gt && ee(e, c) && (r2 = r2.insert(c.key, c));
      }
      return Er.resolve(r2);
    }, t3.prototype.ps = function(t4, e) {
      return Er.forEach(this.docs, function(t5) {
        return e(t5);
      });
    }, t3.prototype.newChangeBuffer = function(t4) {
      return new uo(this);
    }, t3.prototype.getSize = function(t4) {
      return Er.resolve(this.size);
    }, t3;
  }()
);
var uo = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).Ve = e2, n2;
    }
    return __extends(e, t3), e.prototype.applyChanges = function(t4) {
      var e2 = this, n2 = [];
      return this.changes.forEach(function(r2, i) {
        i && i.maybeDocument ? n2.push(e2.Ve.addEntry(t4, i.maybeDocument, e2.getReadTime(r2))) : e2.Ve.removeEntry(r2);
      }), Er.waitFor(n2);
    }, e.prototype.getFromCache = function(t4, e2) {
      return this.Ve.getEntry(t4, e2);
    }, e.prototype.getAllFromCache = function(t4, e2) {
      return this.Ve.getEntries(t4, e2);
    }, e;
  }(Ti)
);
var ao = (
  /** @class */
  function() {
    function t3(t4) {
      this.persistence = t4, /**
           * Maps a target to the data about that target
           */
      this.Es = new Ei(function(t5) {
        return Tt(t5);
      }, _t), /** The last received snapshot version. */
      this.lastRemoteSnapshotVersion = ie.min(), /** The highest numbered target ID encountered. */
      this.highestTargetId = 0, /** The highest sequence number encountered. */
      this.Ts = 0, /**
           * A ordered bidirectional mapping between documents and the remote target
           * IDs.
           */
      this.Is = new ro(), this.targetCount = 0, this.As = hi.ee();
    }
    return t3.prototype.forEachTarget = function(t4, e) {
      return this.Es.forEach(function(t5, n2) {
        return e(n2);
      }), Er.resolve();
    }, t3.prototype.getLastRemoteSnapshotVersion = function(t4) {
      return Er.resolve(this.lastRemoteSnapshotVersion);
    }, t3.prototype.getHighestSequenceNumber = function(t4) {
      return Er.resolve(this.Ts);
    }, t3.prototype.allocateTargetId = function(t4) {
      return this.highestTargetId = this.As.next(), Er.resolve(this.highestTargetId);
    }, t3.prototype.setTargetsMetadata = function(t4, e, n2) {
      return n2 && (this.lastRemoteSnapshotVersion = n2), e > this.Ts && (this.Ts = e), Er.resolve();
    }, t3.prototype.re = function(t4) {
      this.Es.set(t4.target, t4);
      var e = t4.targetId;
      e > this.highestTargetId && (this.As = new hi(e), this.highestTargetId = e), t4.sequenceNumber > this.Ts && (this.Ts = t4.sequenceNumber);
    }, t3.prototype.addTargetData = function(t4, e) {
      return this.re(e), this.targetCount += 1, Er.resolve();
    }, t3.prototype.updateTargetData = function(t4, e) {
      return this.re(e), Er.resolve();
    }, t3.prototype.removeTargetData = function(t4, e) {
      return this.Es.delete(e.target), this.Is.os(e.targetId), this.targetCount -= 1, Er.resolve();
    }, t3.prototype.removeTargets = function(t4, e, n2) {
      var r2 = this, i = 0, o = [];
      return this.Es.forEach(function(s, u) {
        u.sequenceNumber <= e && null === n2.get(u.targetId) && (r2.Es.delete(s), o.push(r2.removeMatchingKeysForTargetId(t4, u.targetId)), i++);
      }), Er.waitFor(o).next(function() {
        return i;
      });
    }, t3.prototype.getTargetCount = function(t4) {
      return Er.resolve(this.targetCount);
    }, t3.prototype.getTargetData = function(t4, e) {
      var n2 = this.Es.get(e) || null;
      return Er.resolve(n2);
    }, t3.prototype.addMatchingKeys = function(t4, e, n2) {
      return this.Is.ns(e, n2), Er.resolve();
    }, t3.prototype.removeMatchingKeys = function(t4, e, n2) {
      this.Is.rs(e, n2);
      var r2 = this.persistence.referenceDelegate, i = [];
      return r2 && e.forEach(function(e2) {
        i.push(r2.markPotentiallyOrphaned(t4, e2));
      }), Er.waitFor(i);
    }, t3.prototype.removeMatchingKeysForTargetId = function(t4, e) {
      return this.Is.os(e), Er.resolve();
    }, t3.prototype.getMatchingKeysForTargetId = function(t4, e) {
      var n2 = this.Is.us(e);
      return Er.resolve(n2);
    }, t3.prototype.containsKey = function(t4, e) {
      return Er.resolve(this.Is.containsKey(e));
    }, t3;
  }()
);
var co = (
  /** @class */
  function() {
    function t3(t4, e) {
      var n2 = this;
      this.Rs = {}, this.Me = new I2(0), this.Le = false, this.Le = true, this.referenceDelegate = t4(this), this.Ge = new ao(this), this.Gt = new Xr(), this.ze = function(t5, e2) {
        return new so(t5, function(t6) {
          return n2.referenceDelegate.bs(t6);
        });
      }(this.Gt), this.D = new Fr(e), this.He = new no(this.D);
    }
    return t3.prototype.start = function() {
      return Promise.resolve();
    }, t3.prototype.shutdown = function() {
      return this.Le = false, Promise.resolve();
    }, Object.defineProperty(t3.prototype, "started", {
      get: function() {
        return this.Le;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.setDatabaseDeletedListener = function() {
    }, t3.prototype.setNetworkEnabled = function() {
    }, t3.prototype.getIndexManager = function() {
      return this.Gt;
    }, t3.prototype.getMutationQueue = function(t4) {
      var e = this.Rs[t4.toKey()];
      return e || (e = new oo(this.Gt, this.referenceDelegate), this.Rs[t4.toKey()] = e), e;
    }, t3.prototype.getTargetCache = function() {
      return this.Ge;
    }, t3.prototype.getRemoteDocumentCache = function() {
      return this.ze;
    }, t3.prototype.getBundleCache = function() {
      return this.He;
    }, t3.prototype.runTransaction = function(t4, e, n2) {
      var r2 = this;
      _("MemoryPersistence", "Starting transaction:", t4);
      var i = new ho(this.Me.next());
      return this.referenceDelegate.vs(), n2(i).next(function(t5) {
        return r2.referenceDelegate.Ps(i).next(function() {
          return t5;
        });
      }).toPromise().then(function(t5) {
        return i.raiseOnCommittedEvent(), t5;
      });
    }, t3.prototype.Vs = function(t4, e) {
      return Er.or(Object.values(this.Rs).map(function(n2) {
        return function() {
          return n2.containsKey(t4, e);
        };
      }));
    }, t3;
  }()
);
var ho = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).currentSequenceNumber = e2, n2;
    }
    return __extends(e, t3), e;
  }(br)
);
var fo = (
  /** @class */
  function() {
    function t3(t4) {
      this.persistence = t4, /** Tracks all documents that are active in Query views. */
      this.Ss = new ro(), /** The list of documents that are potentially GCed after each transaction. */
      this.Ds = null;
    }
    return t3.Cs = function(e) {
      return new t3(e);
    }, Object.defineProperty(t3.prototype, "xs", {
      get: function() {
        if (this.Ds)
          return this.Ds;
        throw A2();
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.addReference = function(t4, e, n2) {
      return this.Ss.addReference(n2, e), this.xs.delete(n2.toString()), Er.resolve();
    }, t3.prototype.removeReference = function(t4, e, n2) {
      return this.Ss.removeReference(n2, e), this.xs.add(n2.toString()), Er.resolve();
    }, t3.prototype.markPotentiallyOrphaned = function(t4, e) {
      return this.xs.add(e.toString()), Er.resolve();
    }, t3.prototype.removeTarget = function(t4, e) {
      var n2 = this;
      this.Ss.os(e.targetId).forEach(function(t5) {
        return n2.xs.add(t5.toString());
      });
      var r2 = this.persistence.getTargetCache();
      return r2.getMatchingKeysForTargetId(t4, e.targetId).next(function(t5) {
        t5.forEach(function(t6) {
          return n2.xs.add(t6.toString());
        });
      }).next(function() {
        return r2.removeTargetData(t4, e);
      });
    }, t3.prototype.vs = function() {
      this.Ds = /* @__PURE__ */ new Set();
    }, t3.prototype.Ps = function(t4) {
      var e = this, n2 = this.persistence.getRemoteDocumentCache().newChangeBuffer();
      return Er.forEach(this.xs, function(r2) {
        var i = H2.fromPath(r2);
        return e.Ns(t4, i).next(function(t5) {
          t5 || n2.removeEntry(i);
        });
      }).next(function() {
        return e.Ds = null, n2.apply(t4);
      });
    }, t3.prototype.updateLimboDocument = function(t4, e) {
      var n2 = this;
      return this.Ns(t4, e).next(function(t5) {
        t5 ? n2.xs.delete(e.toString()) : n2.xs.add(e.toString());
      });
    }, t3.prototype.bs = function(t4) {
      return 0;
    }, t3.prototype.Ns = function(t4, e) {
      var n2 = this;
      return Er.or([function() {
        return Er.resolve(n2.Ss.containsKey(e));
      }, function() {
        return n2.persistence.getTargetCache().containsKey(t4, e);
      }, function() {
        return n2.persistence.Vs(t4, e);
      }]);
    }, t3;
  }()
);
var lo = (
  /** @class */
  function() {
    function t3(t4) {
      this.uid = t4;
    }
    return t3.prototype.isAuthenticated = function() {
      return null != this.uid;
    }, /**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */
    t3.prototype.toKey = function() {
      return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
    }, t3.prototype.isEqual = function(t4) {
      return t4.uid === this.uid;
    }, t3;
  }()
);
function po(t3, e) {
  return "firestore_clients_" + t3 + "_" + e;
}
function yo(t3, e, n2) {
  var r2 = "firestore_mutations_" + t3 + "_" + n2;
  return e.isAuthenticated() && (r2 += "_" + e.uid), r2;
}
function vo(t3, e) {
  return "firestore_targets_" + t3 + "_" + e;
}
lo.UNAUTHENTICATED = new lo(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
lo.GOOGLE_CREDENTIALS = new lo("google-credentials-uid"), lo.FIRST_PARTY = new lo("first-party-uid");
var mo = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.user = t4, this.batchId = e, this.state = n2, this.error = r2;
    }
    return t3.$s = function(e, n2, r2) {
      var i, o = JSON.parse(r2), s = "object" == typeof o && -1 !== ["pending", "acknowledged", "rejected"].indexOf(o.state) && (void 0 === o.error || "object" == typeof o.error);
      return s && o.error && ((s = "string" == typeof o.error.message && "string" == typeof o.error.code) && (i = new G2(o.error.code, o.error.message))), s ? new t3(e, n2, o.state, i) : (S2("SharedClientState", "Failed to parse mutation state for ID '" + n2 + "': " + r2), null);
    }, t3.prototype.Fs = function() {
      var t4 = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      return this.error && (t4.error = {
        code: this.error.code,
        message: this.error.message
      }), JSON.stringify(t4);
    }, t3;
  }()
);
var go = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.targetId = t4, this.state = e, this.error = n2;
    }
    return t3.$s = function(e, n2) {
      var r2, i = JSON.parse(n2), o = "object" == typeof i && -1 !== ["not-current", "current", "rejected"].indexOf(i.state) && (void 0 === i.error || "object" == typeof i.error);
      return o && i.error && ((o = "string" == typeof i.error.message && "string" == typeof i.error.code) && (r2 = new G2(i.error.code, i.error.message))), o ? new t3(e, i.state, r2) : (S2("SharedClientState", "Failed to parse target state for ID '" + e + "': " + n2), null);
    }, t3.prototype.Fs = function() {
      var t4 = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      return this.error && (t4.error = {
        code: this.error.code,
        message: this.error.message
      }), JSON.stringify(t4);
    }, t3;
  }()
);
var wo = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.clientId = t4, this.activeTargetIds = e;
    }
    return t3.$s = function(e, n2) {
      for (var r2 = JSON.parse(n2), i = "object" == typeof r2 && r2.activeTargetIds instanceof Array, o = cn(), s = 0; i && s < r2.activeTargetIds.length; ++s)
        i = B(r2.activeTargetIds[s]), o = o.add(r2.activeTargetIds[s]);
      return i ? new t3(e, o) : (S2("SharedClientState", "Failed to parse client data for instance '" + e + "': " + n2), null);
    }, t3;
  }()
);
var bo = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.clientId = t4, this.onlineState = e;
    }
    return t3.$s = function(e) {
      var n2 = JSON.parse(e);
      return "object" == typeof n2 && -1 !== ["Unknown", "Online", "Offline"].indexOf(n2.onlineState) && "string" == typeof n2.clientId ? new t3(n2.clientId, n2.onlineState) : (S2("SharedClientState", "Failed to parse online state: " + e), null);
    }, t3;
  }()
);
var Io = (
  /** @class */
  function() {
    function t3() {
      this.activeTargetIds = cn();
    }
    return t3.prototype.Os = function(t4) {
      this.activeTargetIds = this.activeTargetIds.add(t4);
    }, t3.prototype.ks = function(t4) {
      this.activeTargetIds = this.activeTargetIds.delete(t4);
    }, /**
     * Converts this entry into a JSON-encoded format we can use for WebStorage.
     * Does not encode `clientId` as it is part of the key in WebStorage.
     */
    t3.prototype.Fs = function() {
      var t4 = {
        activeTargetIds: this.activeTargetIds.toArray(),
        updateTimeMs: Date.now()
      };
      return JSON.stringify(t4);
    }, t3;
  }()
);
var Eo = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      this.window = t4, this.Fe = e, this.persistenceKey = n2, this.Ms = r2, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Ls = this.Bs.bind(this), this.qs = new We(R2), this.started = false, /**
           * Captures WebStorage events that occur before `start()` is called. These
           * events are replayed once `WebStorageSharedClientState` is started.
           */
      this.Us = [];
      var o = n2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      this.storage = this.window.localStorage, this.currentUser = i, this.Qs = po(this.persistenceKey, this.Ms), this.Ks = /** Assembles the key for the current sequence number. */
      function(t5) {
        return "firestore_sequence_number_" + t5;
      }(this.persistenceKey), this.qs = this.qs.insert(this.Ms, new Io()), this.Ws = new RegExp("^firestore_clients_" + o + "_([^_]*)$"), this.js = new RegExp("^firestore_mutations_" + o + "_(\\d+)(?:_(.*))?$"), this.Gs = new RegExp("^firestore_targets_" + o + "_(\\d+)$"), this.zs = /** Assembles the key for the online state of the primary tab. */
      function(t5) {
        return "firestore_online_state_" + t5;
      }(this.persistenceKey), this.Hs = function(t5) {
        return "firestore_bundle_loaded_" + t5;
      }(this.persistenceKey), // Rather than adding the storage observer during start(), we add the
      // storage observer during initialization. This ensures that we collect
      // events before other components populate their initial state (during their
      // respective start() calls). Otherwise, we might for example miss a
      // mutation that is added after LocalStore's start() processed the existing
      // mutations but before we observe WebStorage events.
      this.window.addEventListener("storage", this.Ls);
    }
    return t3.At = function(t4) {
      return !(!t4 || !t4.localStorage);
    }, t3.prototype.start = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e, n2, r2, i, o, s, u, a, c, h2, f = this;
        return __generator(this, function(l) {
          switch (l.label) {
            case 0:
              return [4, this.syncEngine.gn()];
            case 1:
              for (t4 = l.sent(), e = 0, n2 = t4; e < n2.length; e++)
                (r2 = n2[e]) !== this.Ms && (i = this.getItem(po(this.persistenceKey, r2))) && (o = wo.$s(r2, i)) && (this.qs = this.qs.insert(o.clientId, o));
              for (this.Js(), (s = this.storage.getItem(this.zs)) && (u = this.Ys(s)) && this.Xs(u), a = 0, c = this.Us; a < c.length; a++)
                h2 = c[a], this.Bs(h2);
              return this.Us = [], // Register a window unload hook to remove the client metadata entry from
              // WebStorage even if `shutdown()` was not called.
              this.window.addEventListener("unload", function() {
                return f.shutdown();
              }), this.started = true, [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.writeSequenceNumber = function(t4) {
      this.setItem(this.Ks, JSON.stringify(t4));
    }, t3.prototype.getAllActiveQueryTargets = function() {
      return this.Zs(this.qs);
    }, t3.prototype.isActiveQueryTarget = function(t4) {
      var e = false;
      return this.qs.forEach(function(n2, r2) {
        r2.activeTargetIds.has(t4) && (e = true);
      }), e;
    }, t3.prototype.addPendingMutation = function(t4) {
      this.ti(t4, "pending");
    }, t3.prototype.updateMutationState = function(t4, e, n2) {
      this.ti(t4, e, n2), // Once a final mutation result is observed by other clients, they no longer
      // access the mutation's metadata entry. Since WebStorage replays events
      // in order, it is safe to delete the entry right after updating it.
      this.ei(t4);
    }, t3.prototype.addLocalQueryTarget = function(t4) {
      var e = "not-current";
      if (this.isActiveQueryTarget(t4)) {
        var n2 = this.storage.getItem(vo(this.persistenceKey, t4));
        if (n2) {
          var r2 = go.$s(t4, n2);
          r2 && (e = r2.state);
        }
      }
      return this.ni.Os(t4), this.Js(), e;
    }, t3.prototype.removeLocalQueryTarget = function(t4) {
      this.ni.ks(t4), this.Js();
    }, t3.prototype.isLocalQueryTarget = function(t4) {
      return this.ni.activeTargetIds.has(t4);
    }, t3.prototype.clearQueryState = function(t4) {
      this.removeItem(vo(this.persistenceKey, t4));
    }, t3.prototype.updateQueryState = function(t4, e, n2) {
      this.si(t4, e, n2);
    }, t3.prototype.handleUserChange = function(t4, e, n2) {
      var r2 = this;
      e.forEach(function(t5) {
        r2.ei(t5);
      }), this.currentUser = t4, n2.forEach(function(t5) {
        r2.addPendingMutation(t5);
      });
    }, t3.prototype.setOnlineState = function(t4) {
      this.ii(t4);
    }, t3.prototype.notifyBundleLoaded = function() {
      this.ri();
    }, t3.prototype.shutdown = function() {
      this.started && (this.window.removeEventListener("storage", this.Ls), this.removeItem(this.Qs), this.started = false);
    }, t3.prototype.getItem = function(t4) {
      var e = this.storage.getItem(t4);
      return _("SharedClientState", "READ", t4, e), e;
    }, t3.prototype.setItem = function(t4, e) {
      _("SharedClientState", "SET", t4, e), this.storage.setItem(t4, e);
    }, t3.prototype.removeItem = function(t4) {
      _("SharedClientState", "REMOVE", t4), this.storage.removeItem(t4);
    }, t3.prototype.Bs = function(t4) {
      var e = this, n2 = t4;
      if (n2.storageArea === this.storage) {
        if (_("SharedClientState", "EVENT", n2.key, n2.newValue), n2.key === this.Qs)
          return void S2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
        this.Fe.enqueueRetryable(function() {
          return __awaiter(e, void 0, void 0, function() {
            var t5, e2, r2, i, o, s;
            return __generator(this, function(u) {
              if (this.started) {
                if (null !== n2.key) {
                  if (this.Ws.test(n2.key)) {
                    if (null == n2.newValue)
                      return t5 = this.oi(n2.key), [2, this.ci(t5, null)];
                    if (e2 = this.ai(n2.key, n2.newValue))
                      return [2, this.ci(e2.clientId, e2)];
                  } else if (this.js.test(n2.key)) {
                    if (null !== n2.newValue && (r2 = this.ui(n2.key, n2.newValue)))
                      return [2, this.hi(r2)];
                  } else if (this.Gs.test(n2.key)) {
                    if (null !== n2.newValue && (i = this.li(n2.key, n2.newValue)))
                      return [2, this.fi(i)];
                  } else if (n2.key === this.zs) {
                    if (null !== n2.newValue && (o = this.Ys(n2.newValue)))
                      return [2, this.Xs(o)];
                  } else if (n2.key === this.Ks)
                    (s = function(t6) {
                      var e3 = I2.o;
                      if (null != t6)
                        try {
                          var n3 = JSON.parse(t6);
                          k2("number" == typeof n3), e3 = n3;
                        } catch (t7) {
                          S2("SharedClientState", "Failed to read sequence number from WebStorage", t7);
                        }
                      return e3;
                    }(n2.newValue)) !== I2.o && this.sequenceNumberHandler(s);
                  else if (n2.key === this.Hs)
                    return [2, this.syncEngine.di()];
                }
              } else
                this.Us.push(n2);
              return [
                2
                /*return*/
              ];
            });
          });
        });
      }
    }, Object.defineProperty(t3.prototype, "ni", {
      get: function() {
        return this.qs.get(this.Ms);
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.Js = function() {
      this.setItem(this.Qs, this.ni.Fs());
    }, t3.prototype.ti = function(t4, e, n2) {
      var r2 = new mo(this.currentUser, t4, e, n2), i = yo(this.persistenceKey, this.currentUser, t4);
      this.setItem(i, r2.Fs());
    }, t3.prototype.ei = function(t4) {
      var e = yo(this.persistenceKey, this.currentUser, t4);
      this.removeItem(e);
    }, t3.prototype.ii = function(t4) {
      var e = {
        clientId: this.Ms,
        onlineState: t4
      };
      this.storage.setItem(this.zs, JSON.stringify(e));
    }, t3.prototype.si = function(t4, e, n2) {
      var r2 = vo(this.persistenceKey, t4), i = new go(t4, e, n2);
      this.setItem(r2, i.Fs());
    }, t3.prototype.ri = function() {
      this.setItem(this.Hs, "value-not-used");
    }, /**
     * Parses a client state key in WebStorage. Returns null if the key does not
     * match the expected key format.
     */
    t3.prototype.oi = function(t4) {
      var e = this.Ws.exec(t4);
      return e ? e[1] : null;
    }, /**
     * Parses a client state in WebStorage. Returns 'null' if the value could not
     * be parsed.
     */
    t3.prototype.ai = function(t4, e) {
      var n2 = this.oi(t4);
      return wo.$s(n2, e);
    }, /**
     * Parses a mutation batch state in WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t3.prototype.ui = function(t4, e) {
      var n2 = this.js.exec(t4), r2 = Number(n2[1]), i = void 0 !== n2[2] ? n2[2] : null;
      return mo.$s(new lo(i), r2, e);
    }, /**
     * Parses a query target state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t3.prototype.li = function(t4, e) {
      var n2 = this.Gs.exec(t4), r2 = Number(n2[1]);
      return go.$s(r2, e);
    }, /**
     * Parses an online state from WebStorage. Returns 'null' if the value
     * could not be parsed.
     */
    t3.prototype.Ys = function(t4) {
      return bo.$s(t4);
    }, t3.prototype.hi = function(t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
          return t4.user.uid === this.currentUser.uid ? [2, this.syncEngine.wi(t4.batchId, t4.state, t4.error)] : (_("SharedClientState", "Ignoring mutation for non-active user " + t4.user.uid), [
            2
            /*return*/
          ]);
        });
      });
    }, t3.prototype.fi = function(t4) {
      return this.syncEngine._i(t4.targetId, t4.state, t4.error);
    }, t3.prototype.ci = function(t4, e) {
      var n2 = this, r2 = e ? this.qs.insert(t4, e) : this.qs.remove(t4), i = this.Zs(this.qs), o = this.Zs(r2), s = [], u = [];
      return o.forEach(function(t5) {
        i.has(t5) || s.push(t5);
      }), i.forEach(function(t5) {
        o.has(t5) || u.push(t5);
      }), this.syncEngine.mi(s, u).then(function() {
        n2.qs = r2;
      });
    }, t3.prototype.Xs = function(t4) {
      this.qs.get(t4.clientId) && this.onlineStateHandler(t4.onlineState);
    }, t3.prototype.Zs = function(t4) {
      var e = cn();
      return t4.forEach(function(t5, n2) {
        e = e.unionWith(n2.activeTargetIds);
      }), e;
    }, t3;
  }()
);
var To = (
  /** @class */
  function() {
    function t3() {
      this.yi = new Io(), this.gi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
    }
    return t3.prototype.addPendingMutation = function(t4) {
    }, t3.prototype.updateMutationState = function(t4, e, n2) {
    }, t3.prototype.addLocalQueryTarget = function(t4) {
      return this.yi.Os(t4), this.gi[t4] || "not-current";
    }, t3.prototype.updateQueryState = function(t4, e, n2) {
      this.gi[t4] = e;
    }, t3.prototype.removeLocalQueryTarget = function(t4) {
      this.yi.ks(t4);
    }, t3.prototype.isLocalQueryTarget = function(t4) {
      return this.yi.activeTargetIds.has(t4);
    }, t3.prototype.clearQueryState = function(t4) {
      delete this.gi[t4];
    }, t3.prototype.getAllActiveQueryTargets = function() {
      return this.yi.activeTargetIds;
    }, t3.prototype.isActiveQueryTarget = function(t4) {
      return this.yi.activeTargetIds.has(t4);
    }, t3.prototype.start = function() {
      return this.yi = new Io(), Promise.resolve();
    }, t3.prototype.handleUserChange = function(t4, e, n2) {
    }, t3.prototype.setOnlineState = function(t4) {
    }, t3.prototype.shutdown = function() {
    }, t3.prototype.writeSequenceNumber = function(t4) {
    }, t3.prototype.notifyBundleLoaded = function() {
    }, t3;
  }()
);
var _o = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.pi = function(t4) {
    }, t3.prototype.shutdown = function() {
    }, t3;
  }()
);
var So = (
  /** @class */
  function() {
    function t3() {
      var t4 = this;
      this.Ei = function() {
        return t4.Ti();
      }, this.Ii = function() {
        return t4.Ai();
      }, this.Ri = [], this.bi();
    }
    return t3.prototype.pi = function(t4) {
      this.Ri.push(t4);
    }, t3.prototype.shutdown = function() {
      window.removeEventListener("online", this.Ei), window.removeEventListener("offline", this.Ii);
    }, t3.prototype.bi = function() {
      window.addEventListener("online", this.Ei), window.addEventListener("offline", this.Ii);
    }, t3.prototype.Ti = function() {
      _("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
      for (var t4 = 0, e = this.Ri; t4 < e.length; t4++) {
        (0, e[t4])(
          0
          /* AVAILABLE */
        );
      }
    }, t3.prototype.Ai = function() {
      _("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
      for (var t4 = 0, e = this.Ri; t4 < e.length; t4++) {
        (0, e[t4])(
          1
          /* UNAVAILABLE */
        );
      }
    }, // TODO(chenbrian): Consider passing in window either into this component or
    // here for testing via FakeWindow.
    /** Checks that all used attributes of window are available. */
    t3.At = function() {
      return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
    }, t3;
  }()
);
var Do = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var No = (
  /** @class */
  function() {
    function t3(t4) {
      this.vi = t4.vi, this.Pi = t4.Pi;
    }
    return t3.prototype.Vi = function(t4) {
      this.Si = t4;
    }, t3.prototype.Di = function(t4) {
      this.Ci = t4;
    }, t3.prototype.onMessage = function(t4) {
      this.xi = t4;
    }, t3.prototype.close = function() {
      this.Pi();
    }, t3.prototype.send = function(t4) {
      this.vi(t4);
    }, t3.prototype.Ni = function() {
      this.Si();
    }, t3.prototype.$i = function(t4) {
      this.Ci(t4);
    }, t3.prototype.Fi = function(t4) {
      this.xi(t4);
    }, t3;
  }()
);
var Ao = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this, e2) || this).forceLongPolling = e2.forceLongPolling, n2.autoDetectLongPolling = e2.autoDetectLongPolling, n2;
    }
    return __extends(e, t3), e.prototype.qi = function(t4, e2, n2, r2) {
      return new Promise(function(i, o) {
        var s = new XhrIo();
        s.listenOnce(EventType.COMPLETE, function() {
          try {
            switch (s.getLastErrorCode()) {
              case ErrorCode.NO_ERROR:
                var e3 = s.getResponseJson();
                _("Connection", "XHR received:", JSON.stringify(e3)), i(e3);
                break;
              case ErrorCode.TIMEOUT:
                _("Connection", 'RPC "' + t4 + '" timed out'), o(new G2(j.DEADLINE_EXCEEDED, "Request time out"));
                break;
              case ErrorCode.HTTP_ERROR:
                var n3 = s.getStatus();
                if (_("Connection", 'RPC "' + t4 + '" failed with status:', n3, "response text:", s.getResponseText()), n3 > 0) {
                  var r3 = s.getResponseJson().error;
                  if (r3 && r3.status && r3.message) {
                    var u2 = function(t5) {
                      var e4 = t5.toLowerCase().replace(/_/g, "-");
                      return Object.values(j).indexOf(e4) >= 0 ? e4 : j.UNKNOWN;
                    }(r3.status);
                    o(new G2(u2, r3.message));
                  } else
                    o(new G2(j.UNKNOWN, "Server responded with status " + s.getStatus()));
                } else
                  o(new G2(j.UNAVAILABLE, "Connection failed."));
                break;
              default:
                A2();
            }
          } finally {
            _("Connection", 'RPC "' + t4 + '" completed.');
          }
        });
        var u = JSON.stringify(r2);
        s.send(e2, "POST", u, n2, 15);
      });
    }, e.prototype.Qi = function(t4, e2) {
      var n2 = [this.Oi, "/", "google.firestore.v1.Firestore", "/", t4, "/channel"], c = createWebChannelTransport(), h2 = getStatEventTarget(), f = {
        // Required for backend stickiness, routing behavior is based on this
        // parameter.
        httpSessionIdParam: "gsessionid",
        initMessageHeaders: {},
        messageUrlParams: {
          // This param is used to improve routing and project isolation by the
          // backend and must be included in every request.
          database: "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database
        },
        sendRawJson: true,
        supportsCrossDomainXhr: true,
        internalChannelParams: {
          // Override the default timeout (randomized between 10-20 seconds) since
          // a large write batch on a slow internet connection may take a long
          // time to send to the backend. Rather than have WebChannel impose a
          // tight timeout which could lead to infinite timeouts and retries, we
          // set it very large (5-10 minutes) and rely on the browser's builtin
          // timeouts to kick in if the request isn't working.
          forwardChannelRequestTimeoutMs: 6e5
        },
        forceLongPolling: this.forceLongPolling,
        detectBufferingProxy: this.autoDetectLongPolling
      };
      this.Bi(f.initMessageHeaders, e2), // Sending the custom headers we just added to request.initMessageHeaders
      // (Authorization, etc.) will trigger the browser to make a CORS preflight
      // request because the XHR will no longer meet the criteria for a "simple"
      // CORS request:
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
      // Therefore to avoid the CORS preflight request (an extra network
      // roundtrip), we use the httpHeadersOverwriteParam option to specify that
      // the headers should instead be encoded into a special "$httpHeaders" query
      // parameter, which is recognized by the webchannel backend. This is
      // formally defined here:
      // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L32
      // TODO(b/145624756): There is a backend bug where $httpHeaders isn't respected if the request
      // doesn't have an Origin header. So we have to exclude a few browser environments that are
      // known to (sometimes) not include an Origin. See
      // https://github.com/firebase/firebase-js-sdk/issues/1491.
      isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (f.httpHeadersOverwriteParam = "$httpHeaders");
      var m = n2.join("");
      _("Connection", "Creating WebChannel: " + m, f);
      var g = c.createWebChannel(m, f), w2 = false, b = false, I3 = new No({
        vi: function(t5) {
          b ? _("Connection", "Not sending because WebChannel is closed:", t5) : (w2 || (_("Connection", "Opening WebChannel transport."), g.open(), w2 = true), _("Connection", "WebChannel sending:", t5), g.send(t5));
        },
        Pi: function() {
          return g.close();
        }
      }), E3 = function(t5, e3, n3) {
        t5.listen(e3, function(t6) {
          try {
            n3(t6);
          } catch (t7) {
            setTimeout(function() {
              throw t7;
            }, 0);
          }
        });
      };
      return E3(g, WebChannel.EventType.OPEN, function() {
        b || _("Connection", "WebChannel transport opened.");
      }), E3(g, WebChannel.EventType.CLOSE, function() {
        b || (b = true, _("Connection", "WebChannel transport closed"), I3.$i());
      }), E3(g, WebChannel.EventType.ERROR, function(t5) {
        b || (b = true, D2("Connection", "WebChannel transport errored:", t5), I3.$i(new G2(j.UNAVAILABLE, "The operation could not be completed")));
      }), E3(g, WebChannel.EventType.MESSAGE, function(t5) {
        var e3;
        if (!b) {
          var n3 = t5.data[0];
          k2(!!n3);
          var r2 = n3, i = r2.error || (null === (e3 = r2[0]) || void 0 === e3 ? void 0 : e3.error);
          if (i) {
            _("Connection", "WebChannel received error:", i);
            var o = i.status, s = (
              /**
              * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
              *
              * @returns The Code equivalent to the given status string or undefined if
              *     there is no match.
              */
              function(t6) {
                var e4 = Ue[t6];
                if (void 0 !== e4)
                  return Qe(e4);
              }(o)
            ), u = i.message;
            void 0 === s && (s = j.INTERNAL, u = "Unknown error status: " + o + " with message " + i.message), // Mark closed so no further events are propagated
            b = true, I3.$i(new G2(s, u)), g.close();
          } else
            _("Connection", "WebChannel received:", n3), I3.Fi(n3);
        }
      }), E3(h2, Event.STAT_EVENT, function(t5) {
        t5.stat === Stat.PROXY ? _("Connection", "Detected buffering proxy") : t5.stat === Stat.NOPROXY && _("Connection", "Detected no buffering proxy");
      }), setTimeout(function() {
        I3.Ni();
      }, 0), I3;
    }, e;
  }(
    /** @class */
    function() {
      function t3(t4) {
        this.databaseInfo = t4, this.databaseId = t4.databaseId;
        var e = t4.ssl ? "https" : "http";
        this.Oi = e + "://" + t4.host, this.ki = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
      }
      return t3.prototype.Mi = function(t4, e, n2, r2) {
        var i = this.Li(t4, e);
        _("RestConnection", "Sending: ", i, n2);
        var o = {};
        return this.Bi(o, r2), this.qi(t4, i, o, n2).then(function(t5) {
          return _("RestConnection", "Received: ", t5), t5;
        }, function(e2) {
          throw D2("RestConnection", t4 + " failed with error: ", e2, "url: ", i, "request:", n2), e2;
        });
      }, t3.prototype.Ui = function(t4, e, n2, r2) {
        return this.Mi(t4, e, n2, r2);
      }, /**
       * Modifies the headers for a request, adding any authorization token if
       * present and any additional headers for the request.
       */
      t3.prototype.Bi = function(t4, e) {
        if (t4["X-Goog-Api-Client"] = "gl-js/ fire/8.3.1", // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        t4["Content-Type"] = "text/plain", e)
          for (var n2 in e.authHeaders)
            e.authHeaders.hasOwnProperty(n2) && (t4[n2] = e.authHeaders[n2]);
      }, t3.prototype.Li = function(t4, e) {
        var n2 = Do[t4];
        return this.Oi + "/v1/" + e + ":" + n2;
      }, t3;
    }()
  )
);
function ko() {
  return "undefined" != typeof window ? window : null;
}
function Co() {
  return "undefined" != typeof document ? document : null;
}
function xo(t3) {
  return new In(
    t3,
    /* useProto3Json= */
    true
  );
}
var Lo = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      void 0 === n2 && (n2 = 1e3), void 0 === r2 && (r2 = 1.5), void 0 === i && (i = 6e4), this.Fe = t4, this.timerId = e, this.Ki = n2, this.Wi = r2, this.ji = i, this.Gi = 0, this.zi = null, /** The last backoff attempt, as epoch milliseconds. */
      this.Hi = Date.now(), this.reset();
    }
    return t3.prototype.reset = function() {
      this.Gi = 0;
    }, /**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */
    t3.prototype.Ji = function() {
      this.Gi = this.ji;
    }, /**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts. If there was a pending backoff operation
     * already, it will be canceled.
     */
    t3.prototype.Yi = function(t4) {
      var e = this;
      this.cancel();
      var n2 = Math.floor(this.Gi + this.Xi()), r2 = Math.max(0, Date.now() - this.Hi), i = Math.max(0, n2 - r2);
      i > 0 && _("ExponentialBackoff", "Backing off for " + i + " ms (base delay: " + this.Gi + " ms, delay with jitter: " + n2 + " ms, last attempt: " + r2 + " ms ago)"), this.zi = this.Fe.enqueueAfterDelay(this.timerId, i, function() {
        return e.Hi = Date.now(), t4();
      }), // Apply backoff factor to determine next delay and ensure it is within
      // bounds.
      this.Gi *= this.Wi, this.Gi < this.Ki && (this.Gi = this.Ki), this.Gi > this.ji && (this.Gi = this.ji);
    }, t3.prototype.Zi = function() {
      null !== this.zi && (this.zi.skipDelay(), this.zi = null);
    }, t3.prototype.cancel = function() {
      null !== this.zi && (this.zi.cancel(), this.zi = null);
    }, /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
    t3.prototype.Xi = function() {
      return (Math.random() - 0.5) * this.Gi;
    }, t3;
  }()
);
var Ro = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i, o) {
      this.Fe = t4, this.tr = n2, this.er = r2, this.nr = i, this.listener = o, this.state = 0, /**
           * A close count that's incremented every time the stream is closed; used by
           * getCloseGuardedDispatcher() to invalidate callbacks that happen after
           * close.
           */
      this.sr = 0, this.ir = null, this.stream = null, this.rr = new Lo(t4, e);
    }
    return t3.prototype.cr = function() {
      return 1 === this.state || 2 === this.state || 4 === this.state;
    }, /**
     * Returns true if the underlying RPC is open (the onOpen() listener has been
     * called) and the stream is ready for outbound requests.
     */
    t3.prototype.ar = function() {
      return 2 === this.state;
    }, /**
     * Starts the RPC. Only allowed if isStarted() returns false. The stream is
     * not immediately ready for use: onOpen() will be invoked when the RPC is
     * ready for outbound requests, at which point isOpen() will return true.
     *
     * When start returns, isStarted() will return true.
     */
    t3.prototype.start = function() {
      3 !== this.state ? this.auth() : this.ur();
    }, /**
     * Stops the RPC. This call is idempotent and allowed regardless of the
     * current isStarted() state.
     *
     * When stop returns, isStarted() and isOpen() will both return false.
     */
    t3.prototype.stop = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return this.cr() ? [4, this.close(
                0
                /* Initial */
              )] : [3, 2];
            case 1:
              t4.sent(), t4.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * After an error the stream will usually back off on the next attempt to
     * start it. If the error warrants an immediate restart of the stream, the
     * sender can use this to indicate that the receiver should not back off.
     *
     * Each error will call the onClose() listener. That function can decide to
     * inhibit backoff if required.
     */
    t3.prototype.hr = function() {
      this.state = 0, this.rr.reset();
    }, /**
     * Marks this stream as idle. If no further actions are performed on the
     * stream for one minute, the stream will automatically close itself and
     * notify the stream's onClose() handler with Status.OK. The stream will then
     * be in a !isStarted() state, requiring the caller to start the stream again
     * before further use.
     *
     * Only streams that are in state 'Open' can be marked idle, as all other
     * states imply pending network operations.
     */
    t3.prototype.lr = function() {
      var t4 = this;
      this.ar() && null === this.ir && (this.ir = this.Fe.enqueueAfterDelay(this.tr, 6e4, function() {
        return t4.dr();
      }));
    }, /** Sends a message to the underlying stream. */
    t3.prototype.wr = function(t4) {
      this._r(), this.stream.send(t4);
    }, /** Called by the idle timer when the stream should close due to inactivity. */
    t3.prototype.dr = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          return this.ar() ? [2, this.close(
            0
            /* Initial */
          )] : [
            2
            /*return*/
          ];
        });
      });
    }, /** Marks the stream as active again. */
    t3.prototype._r = function() {
      this.ir && (this.ir.cancel(), this.ir = null);
    }, /**
     * Closes the stream and cleans up as necessary:
     *
     * * closes the underlying GRPC stream;
     * * calls the onClose handler with the given 'error';
     * * sets internal stream state to 'finalState';
     * * adjusts the backoff timer based on the error
     *
     * A new stream can be opened by calling start().
     *
     * @param finalState - the intended state of the stream after closing.
     * @param error - the error the connection was closed with.
     */
    t3.prototype.close = function(t4, e) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this._r(), this.rr.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
              // underlying stream), guaranteeing they won't execute.
              this.sr++, 3 !== t4 ? (
                // If this is an intentional close ensure we don't delay our next connection attempt.
                this.rr.reset()
              ) : e && e.code === j.RESOURCE_EXHAUSTED ? (
                // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
                (S2(e.toString()), S2("Using maximum backoff delay to prevent overloading the backend."), this.rr.Ji())
              ) : e && e.code === j.UNAUTHENTICATED && // "unauthenticated" error means the token was rejected. Try force refreshing it in case it
              // just expired.
              this.nr.invalidateToken(), // Clean up the underlying stream because we are no longer interested in events.
              null !== this.stream && (this.mr(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
              // inhibit backoff or otherwise manipulate the state in its non-started state.
              this.state = t4, [4, this.listener.Di(e)];
            case 1:
              return n2.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * Can be overridden to perform additional cleanup before the stream is closed.
     * Calling super.tearDown() is not required.
     */
    t3.prototype.mr = function() {
    }, t3.prototype.auth = function() {
      var t4 = this;
      this.state = 1;
      var e = this.yr(this.sr), n2 = this.sr;
      this.nr.getToken().then(function(e2) {
        t4.sr === n2 && // Normally we'd have to schedule the callback on the AsyncQueue.
        // However, the following calls are safe to be called outside the
        // AsyncQueue since they don't chain asynchronous calls
        t4.gr(e2);
      }, function(n3) {
        e(function() {
          var e2 = new G2(j.UNKNOWN, "Fetching auth token failed: " + n3.message);
          return t4.pr(e2);
        });
      });
    }, t3.prototype.gr = function(t4) {
      var e = this, n2 = this.yr(this.sr);
      this.stream = this.Er(t4), this.stream.Vi(function() {
        n2(function() {
          return e.state = 2, e.listener.Vi();
        });
      }), this.stream.Di(function(t5) {
        n2(function() {
          return e.pr(t5);
        });
      }), this.stream.onMessage(function(t5) {
        n2(function() {
          return e.onMessage(t5);
        });
      });
    }, t3.prototype.ur = function() {
      var t4 = this;
      this.state = 4, this.rr.Yi(function() {
        return __awaiter(t4, void 0, void 0, function() {
          return __generator(this, function(t5) {
            return this.state = 0, this.start(), [
              2
              /*return*/
            ];
          });
        });
      });
    }, // Visible for tests
    t3.prototype.pr = function(t4) {
      return _("PersistentStream", "close with error: " + t4), this.stream = null, this.close(3, t4);
    }, /**
     * Returns a "dispatcher" function that dispatches operations onto the
     * AsyncQueue but only runs them if closeCount remains unchanged. This allows
     * us to turn auth / stream callbacks into no-ops if the stream is closed /
     * re-opened, etc.
     */
    t3.prototype.yr = function(t4) {
      var e = this;
      return function(n2) {
        e.Fe.enqueueAndForget(function() {
          return e.sr === t4 ? n2() : (_("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve());
        });
      };
    }, t3;
  }()
);
var Oo = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i, o) {
      var s = this;
      return (s = t3.call(this, e2, "listen_stream_connection_backoff", "listen_stream_idle", n2, r2, o) || this).D = i, s;
    }
    return __extends(e, t3), e.prototype.Er = function(t4) {
      return this.er.Qi("Listen", t4);
    }, e.prototype.onMessage = function(t4) {
      this.rr.reset();
      var e2 = function(t5, e3) {
        var n3;
        if ("targetChange" in e3) {
          e3.targetChange;
          var r2 = function(t6) {
            return "NO_CHANGE" === t6 ? 0 : "ADD" === t6 ? 1 : "REMOVE" === t6 ? 2 : "CURRENT" === t6 ? 3 : "RESET" === t6 ? 4 : A2();
          }(e3.targetChange.targetChangeType || "NO_CHANGE"), i = e3.targetChange.targetIds || [], o = function(t6, e4) {
            return t6.V ? (k2(void 0 === e4 || "string" == typeof e4), Y2.fromBase64String(e4 || "")) : (k2(void 0 === e4 || e4 instanceof Uint8Array), Y2.fromUint8Array(e4 || new Uint8Array()));
          }(t5, e3.targetChange.resumeToken), s = (u = e3.targetChange.cause) && function(t6) {
            var e4 = void 0 === t6.code ? j.UNKNOWN : Qe(t6.code);
            return new G2(e4, t6.message || "");
          }(u);
          n3 = new pn(r2, i, o, s || null);
        } else if ("documentChange" in e3) {
          e3.documentChange, (r2 = e3.documentChange).document, r2.document.name, r2.document.updateTime, i = kn(t5, r2.document.name), o = Sn(r2.document.updateTime);
          var u = new se({
            mapValue: {
              fields: r2.document.fields
            }
          }), a = (s = new gt(i, o, u, {}), r2.targetIds || []), c = r2.removedTargetIds || [];
          n3 = new ln(a, c, s.key, s);
        } else if ("documentDelete" in e3)
          e3.documentDelete, (r2 = e3.documentDelete).document, i = kn(t5, r2.document), o = r2.readTime ? Sn(r2.readTime) : ie.min(), u = new wt(i, o), s = r2.removedTargetIds || [], n3 = new ln([], s, u.key, u);
        else if ("documentRemove" in e3)
          e3.documentRemove, (r2 = e3.documentRemove).document, i = kn(t5, r2.document), o = r2.removedTargetIds || [], n3 = new ln([], o, i, null);
        else {
          if (!("filter" in e3))
            return A2();
          e3.filter;
          var h2 = e3.filter;
          h2.targetId, r2 = h2.count || 0, i = new Ke(r2), o = h2.targetId, n3 = new dn(o, i);
        }
        return n3;
      }(this.D, t4), n2 = function(t5) {
        if (!("targetChange" in t5))
          return ie.min();
        var e3 = t5.targetChange;
        return e3.targetIds && e3.targetIds.length ? ie.min() : e3.readTime ? Sn(e3.readTime) : ie.min();
      }(t4);
      return this.listener.Tr(e2, n2);
    }, /**
     * Registers interest in the results of the given target. If the target
     * includes a resumeToken it will be included in the request. Results that
     * affect the target will be streamed back as WatchChange messages that
     * reference the targetId.
     */
    e.prototype.Ir = function(t4) {
      var e2 = {};
      e2.database = Ln(this.D), e2.addTarget = function(t5, e3) {
        var n3, r2 = e3.target;
        return (n3 = St(r2) ? {
          documents: qn(t5, r2)
        } : {
          query: Vn(t5, r2)
        }).targetId = e3.targetId, e3.resumeToken.approximateByteSize() > 0 ? n3.resumeToken = Tn(t5, e3.resumeToken) : e3.snapshotVersion.compareTo(ie.min()) > 0 && // TODO(wuandy): Consider removing above check because it is most likely true.
        // Right now, many tests depend on this behaviour though (leaving min() out
        // of serialization).
        (n3.readTime = En(t5, e3.snapshotVersion.toTimestamp())), n3;
      }(this.D, t4);
      var n2 = function(t5, e3) {
        var n3 = function(t6, e4) {
          switch (e4) {
            case 0:
              return null;
            case 1:
              return "existence-filter-mismatch";
            case 2:
              return "limbo-document";
            default:
              return A2();
          }
        }(0, e3.purpose);
        return null == n3 ? null : {
          "goog-listen-tags": n3
        };
      }(this.D, t4);
      n2 && (e2.labels = n2), this.wr(e2);
    }, /**
     * Unregisters interest in the results of the target associated with the
     * given targetId.
     */
    e.prototype.Ar = function(t4) {
      var e2 = {};
      e2.database = Ln(this.D), e2.removeTarget = t4, this.wr(e2);
    }, e;
  }(Ro)
);
var Po = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i, o) {
      var s = this;
      return (s = t3.call(this, e2, "write_stream_connection_backoff", "write_stream_idle", n2, r2, o) || this).D = i, s.Rr = false, s;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "br", {
      /**
       * Tracks whether or not a handshake has been successfully exchanged and
       * the stream is ready to accept mutations.
       */
      get: function() {
        return this.Rr;
      },
      enumerable: false,
      configurable: true
    }), // Override of PersistentStream.start
    e.prototype.start = function() {
      this.Rr = false, this.lastStreamToken = void 0, t3.prototype.start.call(this);
    }, e.prototype.mr = function() {
      this.Rr && this.vr([]);
    }, e.prototype.Er = function(t4) {
      return this.er.Qi("Write", t4);
    }, e.prototype.onMessage = function(t4) {
      if (
        // Always capture the last stream token.
        k2(!!t4.streamToken), this.lastStreamToken = t4.streamToken, this.Rr
      ) {
        this.rr.reset();
        var e2 = function(t5, e3) {
          return t5 && t5.length > 0 ? (k2(void 0 !== e3), t5.map(function(t6) {
            return function(t7, e4) {
              var n3 = t7.updateTime ? Sn(t7.updateTime) : Sn(e4);
              return n3.isEqual(ie.min()) && // The Firestore Emulator currently returns an update time of 0 for
              // deletes of non-existing documents (rather than null). This breaks the
              // test "get deleted doc while offline with source=cache" as NoDocuments
              // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
              // TODO(#2149): Remove this when Emulator is fixed
              (n3 = Sn(e4)), new Se(n3, t7.transformResults || []);
            }(t6, e3);
          })) : [];
        }(t4.writeResults, t4.commitTime), n2 = Sn(t4.commitTime);
        return this.listener.Pr(n2, e2);
      }
      return k2(!t4.writeResults || 0 === t4.writeResults.length), this.Rr = true, this.listener.Vr();
    }, /**
     * Sends an initial streamToken to the server, performing the handshake
     * required to make the StreamingWrite RPC work. Subsequent
     * calls should wait until onHandshakeComplete was called.
     */
    e.prototype.Sr = function() {
      var t4 = {};
      t4.database = Ln(this.D), this.wr(t4);
    }, /** Sends a group of mutations to the Firestore backend to apply. */
    e.prototype.vr = function(t4) {
      var e2 = this, n2 = {
        streamToken: this.lastStreamToken,
        writes: t4.map(function(t5) {
          return Mn(e2.D, t5);
        })
      };
      this.wr(n2);
    }, e;
  }(Ro)
);
var Mo = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).credentials = e2, i.er = n2, i.D = r2, i.Dr = false, i;
    }
    return __extends(e, t3), e.prototype.Cr = function() {
      if (this.Dr)
        throw new G2(j.FAILED_PRECONDITION, "The client has already been terminated.");
    }, /** Gets an auth token and invokes the provided RPC. */
    e.prototype.Mi = function(t4, e2, n2) {
      var r2 = this;
      return this.Cr(), this.credentials.getToken().then(function(i) {
        return r2.er.Mi(t4, e2, n2, i);
      }).catch(function(t5) {
        throw t5.code === j.UNAUTHENTICATED && r2.credentials.invalidateToken(), t5;
      });
    }, /** Gets an auth token and invokes the provided RPC with streamed results. */
    e.prototype.Ui = function(t4, e2, n2) {
      var r2 = this;
      return this.Cr(), this.credentials.getToken().then(function(i) {
        return r2.er.Ui(t4, e2, n2, i);
      }).catch(function(t5) {
        throw t5.code === j.UNAUTHENTICATED && r2.credentials.invalidateToken(), t5;
      });
    }, e.prototype.terminate = function() {
      this.Dr = false;
    }, e;
  }(function() {
  })
);
var Fo = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.asyncQueue = t4, this.onlineStateHandler = e, /** The current OnlineState. */
      this.state = "Unknown", /**
           * A count of consecutive failures to open the stream. If it reaches the
           * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
           * Offline.
           */
      this.Nr = 0, /**
           * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
           * transition from OnlineState.Unknown to OnlineState.Offline without waiting
           * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
           */
      this.$r = null, /**
           * Whether the client should log a warning message if it fails to connect to
           * the backend (initially true, cleared after a successful stream, or if we've
           * logged the message already).
           */
      this.Fr = true;
    }
    return t3.prototype.Or = function() {
      var t4 = this;
      0 === this.Nr && (this.kr(
        "Unknown"
        /* Unknown */
      ), this.$r = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, function() {
        return t4.$r = null, t4.Mr("Backend didn't respond within 10 seconds."), t4.kr(
          "Offline"
          /* Offline */
        ), Promise.resolve();
      }));
    }, /**
     * Updates our OnlineState as appropriate after the watch stream reports a
     * failure. The first failure moves us to the 'Unknown' state. We then may
     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
     * actually transition to the 'Offline' state.
     */
    t3.prototype.Lr = function(t4) {
      "Online" === this.state ? this.kr(
        "Unknown"
        /* Unknown */
      ) : (this.Nr++, this.Nr >= 1 && (this.Br(), this.Mr("Connection failed 1 times. Most recent error: " + t4.toString()), this.kr(
        "Offline"
        /* Offline */
      )));
    }, /**
     * Explicitly sets the OnlineState to the specified state.
     *
     * Note that this resets our timers / failure counters, etc. used by our
     * Offline heuristics, so must not be used in place of
     * handleWatchStreamStart() and handleWatchStreamFailure().
     */
    t3.prototype.set = function(t4) {
      this.Br(), this.Nr = 0, "Online" === t4 && // We've connected to watch at least once. Don't warn the developer
      // about being offline going forward.
      (this.Fr = false), this.kr(t4);
    }, t3.prototype.kr = function(t4) {
      t4 !== this.state && (this.state = t4, this.onlineStateHandler(t4));
    }, t3.prototype.Mr = function(t4) {
      var e = "Could not reach Cloud Firestore backend. " + t4 + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
      this.Fr ? (S2(e), this.Fr = false) : _("OnlineStateTracker", e);
    }, t3.prototype.Br = function() {
      null !== this.$r && (this.$r.cancel(), this.$r = null);
    }, t3;
  }()
);
var qo = function(t3, e, n2, r2, i) {
  var o = this;
  this.localStore = t3, this.datastore = e, this.asyncQueue = n2, this.remoteSyncer = {}, /**
           * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
           * LocalStore via fillWritePipeline() and have or will send to the write
           * stream.
           *
           * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
           * restart the write stream. When the stream is established the writes in the
           * pipeline will be sent in order.
           *
           * Writes remain in writePipeline until they are acknowledged by the backend
           * and thus will automatically be re-sent if the stream is interrupted /
           * restarted before they're acknowledged.
           *
           * Write responses from the backend are linked to their originating request
           * purely based on order, and so we can just shift() writes from the front of
           * the writePipeline as we receive responses.
           */
  this.qr = [], /**
           * A mapping of watched targets that the client cares about tracking and the
           * user has explicitly called a 'listen' for this target.
           *
           * These targets may or may not have been sent to or acknowledged by the
           * server. On re-establishing the listen stream, these targets should be sent
           * to the server. The targets removed with unlistens are removed eagerly
           * without waiting for confirmation from the listen stream.
           */
  this.Ur = /* @__PURE__ */ new Map(), /**
           * A set of reasons for why the RemoteStore may be offline. If empty, the
           * RemoteStore may start its network connections.
           */
  this.Qr = /* @__PURE__ */ new Set(), /**
           * Event handlers that get called when the network is disabled or enabled.
           *
           * PORTING NOTE: These functions are used on the Web client to create the
           * underlying streams (to support tree-shakeable streams). On Android and iOS,
           * the streams are created during construction of RemoteStore.
           */
  this.Kr = [], this.Wr = i, this.Wr.pi(function(t4) {
    n2.enqueueAndForget(function() {
      return __awaiter(o, void 0, void 0, function() {
        return __generator(this, function(t5) {
          switch (t5.label) {
            case 0:
              return Wo(this) ? (_("RemoteStore", "Restarting streams for network reachability change."), [4, function(t6) {
                return __awaiter(this, void 0, void 0, function() {
                  var e2;
                  return __generator(this, function(n3) {
                    switch (n3.label) {
                      case 0:
                        return (e2 = C(t6)).Qr.add(
                          4
                          /* ConnectivityChange */
                        ), [4, Uo(e2)];
                      case 1:
                        return n3.sent(), e2.jr.set(
                          "Unknown"
                          /* Unknown */
                        ), e2.Qr.delete(
                          4
                          /* ConnectivityChange */
                        ), [4, Vo(e2)];
                      case 2:
                        return n3.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }(this)]) : [3, 2];
            case 1:
              t5.sent(), t5.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    });
  }), this.jr = new Fo(n2, r2);
};
function Vo(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e, n2;
    return __generator(this, function(r2) {
      switch (r2.label) {
        case 0:
          if (!Wo(t3))
            return [3, 4];
          e = 0, n2 = t3.Kr, r2.label = 1;
        case 1:
          return e < n2.length ? [4, (0, n2[e])(
            /* enabled= */
            true
          )] : [3, 4];
        case 2:
          r2.sent(), r2.label = 3;
        case 3:
          return e++, [3, 1];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Uo(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e, n2;
    return __generator(this, function(r2) {
      switch (r2.label) {
        case 0:
          e = 0, n2 = t3.Kr, r2.label = 1;
        case 1:
          return e < n2.length ? [4, (0, n2[e])(
            /* enabled= */
            false
          )] : [3, 4];
        case 2:
          r2.sent(), r2.label = 3;
        case 3:
          return e++, [3, 1];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Bo(t3, e) {
  var n2 = C(t3);
  n2.Ur.has(e.targetId) || // Mark this as something the client is currently listening for.
  (n2.Ur.set(e.targetId, e), Qo(n2) ? (
    // The listen will be sent in onWatchStreamOpen
    zo(n2)
  ) : as(n2).ar() && Go(n2, e));
}
function jo(t3, e) {
  var n2 = C(t3), r2 = as(n2);
  n2.Ur.delete(e), r2.ar() && Ko(n2, e), 0 === n2.Ur.size && (r2.ar() ? r2.lr() : Wo(n2) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  n2.jr.set(
    "Unknown"
    /* Unknown */
  ));
}
function Go(t3, e) {
  t3.Gr.H(e.targetId), as(t3).Ir(e);
}
function Ko(t3, e) {
  t3.Gr.H(e), as(t3).Ar(e);
}
function zo(t3) {
  t3.Gr = new vn({
    getRemoteKeysForTarget: function(e) {
      return t3.remoteSyncer.getRemoteKeysForTarget(e);
    },
    yt: function(e) {
      return t3.Ur.get(e) || null;
    }
  }), as(t3).start(), t3.jr.Or();
}
function Qo(t3) {
  return Wo(t3) && !as(t3).cr() && t3.Ur.size > 0;
}
function Wo(t3) {
  return 0 === C(t3).Qr.size;
}
function Ho(t3) {
  t3.Gr = void 0;
}
function Yo(t3) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      return t3.Ur.forEach(function(e2, n2) {
        Go(t3, e2);
      }), [
        2
        /*return*/
      ];
    });
  });
}
function Jo(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(n2) {
      return Ho(t3), // If we still need the watch stream, retry the connection.
      Qo(t3) ? (t3.jr.Lr(e), zo(t3)) : (
        // No need to restart watch stream because there are no active targets.
        // The online state is set to unknown because there is no active attempt
        // at establishing a connection
        t3.jr.set(
          "Unknown"
          /* Unknown */
        )
      ), [
        2
        /*return*/
      ];
    });
  });
}
function Xo(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          if (t3.jr.set(
            "Online"
            /* Online */
          ), !(e instanceof pn && 2 === e.state && e.cause))
            return [3, 6];
          s.label = 1;
        case 1:
          return s.trys.push([1, 3, , 5]), [
            4,
            /** Handles an error on a target */
            function(t4, e2) {
              return __awaiter(this, void 0, void 0, function() {
                var n3, r3, i2, o2;
                return __generator(this, function(s2) {
                  switch (s2.label) {
                    case 0:
                      n3 = e2.cause, r3 = 0, i2 = e2.targetIds, s2.label = 1;
                    case 1:
                      return r3 < i2.length ? (o2 = i2[r3], t4.Ur.has(o2) ? [4, t4.remoteSyncer.rejectListen(o2, n3)] : [3, 3]) : [3, 5];
                    case 2:
                      s2.sent(), t4.Ur.delete(o2), t4.Gr.removeTarget(o2), s2.label = 3;
                    case 3:
                      s2.label = 4;
                    case 4:
                      return r3++, [3, 1];
                    case 5:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }(t3, e)
          ];
        case 2:
          return s.sent(), [3, 5];
        case 3:
          return r2 = s.sent(), _("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), r2), [4, $o(t3, r2)];
        case 4:
          return s.sent(), [3, 5];
        case 5:
          return [3, 13];
        case 6:
          if (e instanceof ln ? t3.Gr.st(e) : e instanceof dn ? t3.Gr.ht(e) : t3.Gr.ot(e), n2.isEqual(ie.min()))
            return [3, 13];
          s.label = 7;
        case 7:
          return s.trys.push([7, 11, , 13]), [4, Ki(t3.localStore)];
        case 8:
          return i = s.sent(), n2.compareTo(i) >= 0 ? [
            4,
            /**
             * Takes a batch of changes from the Datastore, repackages them as a
             * RemoteEvent, and passes that on to the listener, which is typically the
             * SyncEngine.
             */
            function(t4, e2) {
              var n3 = t4.Gr.dt(e2);
              return n3.targetChanges.forEach(function(n4, r3) {
                if (n4.resumeToken.approximateByteSize() > 0) {
                  var i2 = t4.Ur.get(r3);
                  i2 && t4.Ur.set(r3, i2.withResumeToken(n4.resumeToken, e2));
                }
              }), // Re-establish listens for the targets that have been invalidated by
              // existence filter mismatches.
              n3.targetMismatches.forEach(function(e3) {
                var n4 = t4.Ur.get(e3);
                if (n4) {
                  t4.Ur.set(e3, n4.withResumeToken(Y2.EMPTY_BYTE_STRING, n4.snapshotVersion)), // Cause a hard reset by unwatching and rewatching immediately, but
                  // deliberately don't send a resume token so that we get a full update.
                  Ko(t4, e3);
                  var r3 = new Mr(n4.target, e3, 1, n4.sequenceNumber);
                  Go(t4, r3);
                }
              }), t4.remoteSyncer.applyRemoteEvent(n3);
            }(t3, n2)
          ] : [3, 10];
        case 9:
          s.sent(), s.label = 10;
        case 10:
          return [3, 13];
        case 11:
          return _("RemoteStore", "Failed to raise snapshot:", o = s.sent()), [4, $o(t3, o)];
        case 12:
          return s.sent(), [3, 13];
        case 13:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function $o(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2 = this;
    return __generator(this, function(i) {
      switch (i.label) {
        case 0:
          if (!Nr(e))
            throw e;
          return t3.Qr.add(
            1
            /* IndexedDbFailed */
          ), [4, Uo(t3)];
        case 1:
          return i.sent(), t3.jr.set(
            "Offline"
            /* Offline */
          ), n2 || // Use a simple read operation to determine if IndexedDB recovered.
          // Ideally, we would expose a health check directly on SimpleDb, but
          // RemoteStore only has access to persistence through LocalStore.
          (n2 = function() {
            return Ki(t3.localStore);
          }), // Probe IndexedDB periodically and re-enable network
          t3.asyncQueue.enqueueRetryable(function() {
            return __awaiter(r2, void 0, void 0, function() {
              return __generator(this, function(e2) {
                switch (e2.label) {
                  case 0:
                    return _("RemoteStore", "Retrying IndexedDB access"), [4, n2()];
                  case 1:
                    return e2.sent(), t3.Qr.delete(
                      1
                      /* IndexedDbFailed */
                    ), [4, Vo(t3)];
                  case 2:
                    return e2.sent(), [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }), [
            2
            /*return*/
          ];
      }
    });
  });
}
function Zo(t3, e) {
  return e().catch(function(n2) {
    return $o(t3, n2, e);
  });
}
function ts(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e, n2, r2, i, o;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          e = C(t3), n2 = cs(e), r2 = e.qr.length > 0 ? e.qr[e.qr.length - 1].batchId : -1, s.label = 1;
        case 1:
          if (!/**
          * Returns true if we can add to the write pipeline (i.e. the network is
          * enabled and the write pipeline is not full).
          */
          function(t4) {
            return Wo(t4) && t4.qr.length < 10;
          }(e))
            return [3, 7];
          s.label = 2;
        case 2:
          return s.trys.push([2, 4, , 6]), [4, Wi(e.localStore, r2)];
        case 3:
          return null === (i = s.sent()) ? (0 === e.qr.length && n2.lr(), [3, 7]) : (r2 = i.batchId, function(t4, e2) {
            t4.qr.push(e2);
            var n3 = cs(t4);
            n3.ar() && n3.br && n3.vr(e2.mutations);
          }(e, i), [3, 6]);
        case 4:
          return o = s.sent(), [4, $o(e, o)];
        case 5:
          return s.sent(), [3, 6];
        case 6:
          return [3, 1];
        case 7:
          return es(e) && ns(e), [
            2
            /*return*/
          ];
      }
    });
  });
}
function es(t3) {
  return Wo(t3) && !cs(t3).cr() && t3.qr.length > 0;
}
function ns(t3) {
  cs(t3).start();
}
function rs(t3) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      return cs(t3).Sr(), [
        2
        /*return*/
      ];
    });
  });
}
function is(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e, n2, r2, i;
    return __generator(this, function(o) {
      for (e = cs(t3), n2 = 0, r2 = t3.qr; n2 < r2.length; n2++)
        i = r2[n2], e.vr(i.mutations);
      return [
        2
        /*return*/
      ];
    });
  });
}
function os(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          return r2 = t3.qr.shift(), i = Pr.from(r2, e, n2), [4, Zo(t3, function() {
            return t3.remoteSyncer.applySuccessfulWrite(i);
          })];
        case 1:
          return o.sent(), [4, ts(t3)];
        case 2:
          return o.sent(), [
            2
            /*return*/
          ];
      }
    });
  });
}
function ss(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(n2) {
      switch (n2.label) {
        case 0:
          return e && cs(t3).br ? [4, function(t4, e2) {
            return __awaiter(this, void 0, void 0, function() {
              var n3, r2;
              return __generator(this, function(i) {
                switch (i.label) {
                  case 0:
                    return ze(r2 = e2.code) && r2 !== j.ABORTED ? (n3 = t4.qr.shift(), // In this case it's also unlikely that the server itself is melting
                    // down -- this was just a bad request so inhibit backoff on the next
                    // restart.
                    cs(t4).hr(), [4, Zo(t4, function() {
                      return t4.remoteSyncer.rejectFailedWrite(n3.batchId, e2);
                    })]) : [3, 3];
                  case 1:
                    return i.sent(), [4, ts(t4)];
                  case 2:
                    i.sent(), i.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }(t3, e)] : [3, 2];
        case 1:
          n2.sent(), n2.label = 2;
        case 2:
          return es(t3) && ns(t3), [
            2
            /*return*/
          ];
      }
    });
  });
}
function us(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2;
    return __generator(this, function(i) {
      switch (i.label) {
        case 0:
          return n2 = C(t3), e ? (n2.Qr.delete(
            2
            /* IsSecondary */
          ), [4, Vo(n2)]) : [3, 2];
        case 1:
          return i.sent(), [3, 5];
        case 2:
          return (r2 = e) ? [3, 4] : (n2.Qr.add(
            2
            /* IsSecondary */
          ), [4, Uo(n2)]);
        case 3:
          i.sent(), r2 = n2.jr.set(
            "Unknown"
            /* Unknown */
          ), i.label = 4;
        case 4:
          r2, i.label = 5;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function as(t3) {
  var e = this;
  return t3.zr || // Create stream (but note that it is not started yet).
  (t3.zr = function(t4, e2, n2) {
    var r2 = C(t4);
    return r2.Cr(), new Oo(e2, r2.er, r2.credentials, r2.D, n2);
  }(t3.datastore, t3.asyncQueue, {
    Vi: Yo.bind(null, t3),
    Di: Jo.bind(null, t3),
    Tr: Xo.bind(null, t3)
  }), t3.Kr.push(function(n2) {
    return __awaiter(e, void 0, void 0, function() {
      return __generator(this, function(e2) {
        switch (e2.label) {
          case 0:
            return n2 ? (t3.zr.hr(), Qo(t3) ? zo(t3) : t3.jr.set(
              "Unknown"
              /* Unknown */
            ), [3, 3]) : [3, 1];
          case 1:
            return [4, t3.zr.stop()];
          case 2:
            e2.sent(), Ho(t3), e2.label = 3;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  })), t3.zr;
}
function cs(t3) {
  var e = this;
  return t3.Hr || // Create stream (but note that it is not started yet).
  (t3.Hr = function(t4, e2, n2) {
    var r2 = C(t4);
    return r2.Cr(), new Po(e2, r2.er, r2.credentials, r2.D, n2);
  }(t3.datastore, t3.asyncQueue, {
    Vi: rs.bind(null, t3),
    Di: ss.bind(null, t3),
    Vr: is.bind(null, t3),
    Pr: os.bind(null, t3)
  }), t3.Kr.push(function(n2) {
    return __awaiter(e, void 0, void 0, function() {
      return __generator(this, function(e2) {
        switch (e2.label) {
          case 0:
            return n2 ? (t3.Hr.hr(), [4, ts(t3)]) : [3, 2];
          case 1:
            return e2.sent(), [3, 4];
          case 2:
            return [4, t3.Hr.stop()];
          case 3:
            e2.sent(), t3.qr.length > 0 && (_("RemoteStore", "Stopping write stream with " + t3.qr.length + " pending writes"), t3.qr = []), e2.label = 4;
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  })), t3.Hr;
}
var hs = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      this.asyncQueue = t4, this.timerId = e, this.targetTimeMs = n2, this.op = r2, this.removalCallback = i, this.deferred = new Ir(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
      // and so we attach a dummy catch callback to avoid
      // 'UnhandledPromiseRejectionWarning' log spam.
      this.deferred.promise.catch(function(t5) {
      });
    }
    return t3.createAndSchedule = function(e, n2, r2, i, o) {
      var s = new t3(e, n2, Date.now() + r2, i, o);
      return s.start(r2), s;
    }, /**
     * Starts the timer. This is called immediately after construction by
     * createAndSchedule().
     */
    t3.prototype.start = function(t4) {
      var e = this;
      this.timerHandle = setTimeout(function() {
        return e.handleDelayElapsed();
      }, t4);
    }, /**
     * Queues the operation to run immediately (if it hasn't already been run or
     * canceled).
     */
    t3.prototype.skipDelay = function() {
      return this.handleDelayElapsed();
    }, /**
     * Cancels the operation if it hasn't already been executed or canceled. The
     * promise will be rejected.
     *
     * As long as the operation has not yet been run, calling cancel() provides a
     * guarantee that the operation will not be run.
     */
    t3.prototype.cancel = function(t4) {
      null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new G2(j.CANCELLED, "Operation cancelled" + (t4 ? ": " + t4 : ""))));
    }, t3.prototype.handleDelayElapsed = function() {
      var t4 = this;
      this.asyncQueue.enqueueAndForget(function() {
        return null !== t4.timerHandle ? (t4.clearTimeout(), t4.op().then(function(e) {
          return t4.deferred.resolve(e);
        })) : Promise.resolve();
      });
    }, t3.prototype.clearTimeout = function() {
      null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
    }, t3;
  }()
);
function fs(t3, e) {
  if (S2("AsyncQueue", e + ": " + t3), Nr(t3))
    return new G2(j.UNAVAILABLE, e + ": " + t3);
  throw t3;
}
var ls = (
  /** @class */
  function() {
    function t3(t4) {
      this.comparator = t4 ? function(e, n2) {
        return t4(e, n2) || H2.comparator(e.key, n2.key);
      } : function(t5, e) {
        return H2.comparator(t5.key, e.key);
      }, this.keyedMap = nn(), this.sortedSet = new We(this.comparator);
    }
    return t3.emptySet = function(e) {
      return new t3(e.comparator);
    }, t3.prototype.has = function(t4) {
      return null != this.keyedMap.get(t4);
    }, t3.prototype.get = function(t4) {
      return this.keyedMap.get(t4);
    }, t3.prototype.first = function() {
      return this.sortedSet.minKey();
    }, t3.prototype.last = function() {
      return this.sortedSet.maxKey();
    }, t3.prototype.isEmpty = function() {
      return this.sortedSet.isEmpty();
    }, /**
     * Returns the index of the provided key in the document set, or -1 if the
     * document key is not present in the set;
     */
    t3.prototype.indexOf = function(t4) {
      var e = this.keyedMap.get(t4);
      return e ? this.sortedSet.indexOf(e) : -1;
    }, Object.defineProperty(t3.prototype, "size", {
      get: function() {
        return this.sortedSet.size;
      },
      enumerable: false,
      configurable: true
    }), /** Iterates documents in order defined by "comparator" */
    t3.prototype.forEach = function(t4) {
      this.sortedSet.inorderTraversal(function(e, n2) {
        return t4(e), false;
      });
    }, /** Inserts or updates a document with the same key */
    t3.prototype.add = function(t4) {
      var e = this.delete(t4.key);
      return e.copy(e.keyedMap.insert(t4.key, t4), e.sortedSet.insert(t4, null));
    }, /** Deletes a document with a given key */
    t3.prototype.delete = function(t4) {
      var e = this.get(t4);
      return e ? this.copy(this.keyedMap.remove(t4), this.sortedSet.remove(e)) : this;
    }, t3.prototype.isEqual = function(e) {
      if (!(e instanceof t3))
        return false;
      if (this.size !== e.size)
        return false;
      for (var n2 = this.sortedSet.getIterator(), r2 = e.sortedSet.getIterator(); n2.hasNext(); ) {
        var i = n2.getNext().key, o = r2.getNext().key;
        if (!i.isEqual(o))
          return false;
      }
      return true;
    }, t3.prototype.toString = function() {
      var t4 = [];
      return this.forEach(function(e) {
        t4.push(e.toString());
      }), 0 === t4.length ? "DocumentSet ()" : "DocumentSet (\n  " + t4.join("  \n") + "\n)";
    }, t3.prototype.copy = function(e, n2) {
      var r2 = new t3();
      return r2.comparator = this.comparator, r2.keyedMap = e, r2.sortedSet = n2, r2;
    }, t3;
  }()
);
var ds = (
  /** @class */
  function() {
    function t3() {
      this.Jr = new We(H2.comparator);
    }
    return t3.prototype.track = function(t4) {
      var e = t4.doc.key, n2 = this.Jr.get(e);
      n2 ? (
        // Merge the new change with the existing change.
        0 !== t4.type && 3 === n2.type ? this.Jr = this.Jr.insert(e, t4) : 3 === t4.type && 1 !== n2.type ? this.Jr = this.Jr.insert(e, {
          type: n2.type,
          doc: t4.doc
        }) : 2 === t4.type && 2 === n2.type ? this.Jr = this.Jr.insert(e, {
          type: 2,
          doc: t4.doc
        }) : 2 === t4.type && 0 === n2.type ? this.Jr = this.Jr.insert(e, {
          type: 0,
          doc: t4.doc
        }) : 1 === t4.type && 0 === n2.type ? this.Jr = this.Jr.remove(e) : 1 === t4.type && 2 === n2.type ? this.Jr = this.Jr.insert(e, {
          type: 1,
          doc: n2.doc
        }) : 0 === t4.type && 1 === n2.type ? this.Jr = this.Jr.insert(e, {
          type: 2,
          doc: t4.doc
        }) : (
          // This includes these cases, which don't make sense:
          // Added->Added
          // Removed->Removed
          // Modified->Added
          // Removed->Modified
          // Metadata->Added
          // Removed->Metadata
          A2()
        )
      ) : this.Jr = this.Jr.insert(e, t4);
    }, t3.prototype.Yr = function() {
      var t4 = [];
      return this.Jr.inorderTraversal(function(e, n2) {
        t4.push(n2);
      }), t4;
    }, t3;
  }()
);
var ps = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i, o, s, u) {
      this.query = t4, this.docs = e, this.oldDocs = n2, this.docChanges = r2, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = s, this.excludesMetadataChanges = u;
    }
    return t3.fromInitialDocuments = function(e, n2, r2, i) {
      var o = [];
      return n2.forEach(function(t4) {
        o.push({
          type: 0,
          doc: t4
        });
      }), new t3(
        e,
        n2,
        ls.emptySet(n2),
        o,
        r2,
        i,
        /* syncStateChanged= */
        true,
        /* excludesMetadataChanges= */
        false
      );
    }, Object.defineProperty(t3.prototype, "hasPendingWrites", {
      get: function() {
        return !this.mutatedKeys.isEmpty();
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.isEqual = function(t4) {
      if (!(this.fromCache === t4.fromCache && this.syncStateChanged === t4.syncStateChanged && this.mutatedKeys.isEqual(t4.mutatedKeys) && $t(this.query, t4.query) && this.docs.isEqual(t4.docs) && this.oldDocs.isEqual(t4.oldDocs)))
        return false;
      var e = this.docChanges, n2 = t4.docChanges;
      if (e.length !== n2.length)
        return false;
      for (var r2 = 0; r2 < e.length; r2++)
        if (e[r2].type !== n2[r2].type || !e[r2].doc.isEqual(n2[r2].doc))
          return false;
      return true;
    }, t3;
  }()
);
var ys = function() {
  this.Xr = void 0, this.listeners = [];
};
var vs = function() {
  this.queries = new Ei(function(t3) {
    return Zt(t3);
  }, $t), this.onlineState = "Unknown", this.Zr = /* @__PURE__ */ new Set();
};
function ms(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o, s, u, a;
    return __generator(this, function(c) {
      switch (c.label) {
        case 0:
          if (n2 = C(t3), r2 = e.query, i = false, (o = n2.queries.get(r2)) || (i = true, o = new ys()), !i)
            return [3, 4];
          c.label = 1;
        case 1:
          return c.trys.push([1, 3, , 4]), s = o, [4, n2.onListen(r2)];
        case 2:
          return s.Xr = c.sent(), [3, 4];
        case 3:
          return u = c.sent(), a = fs(u, "Initialization of query '" + te(e.query) + "' failed"), [2, void e.onError(a)];
        case 4:
          return n2.queries.set(r2, o), o.listeners.push(e), // Run global snapshot listeners if a consistent snapshot has been emitted.
          e.eo(n2.onlineState), o.Xr && e.no(o.Xr) && Is(n2), [
            2
            /*return*/
          ];
      }
    });
  });
}
function gs(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o, s;
    return __generator(this, function(u) {
      return n2 = C(t3), r2 = e.query, i = false, (o = n2.queries.get(r2)) && (s = o.listeners.indexOf(e)) >= 0 && (o.listeners.splice(s, 1), i = 0 === o.listeners.length), i ? [2, (n2.queries.delete(r2), n2.onUnlisten(r2))] : [
        2
        /*return*/
      ];
    });
  });
}
function ws(t3, e) {
  for (var n2 = C(t3), r2 = false, i = 0, o = e; i < o.length; i++) {
    var s = o[i], u = s.query, a = n2.queries.get(u);
    if (a) {
      for (var c = 0, h2 = a.listeners; c < h2.length; c++) {
        h2[c].no(s) && (r2 = true);
      }
      a.Xr = s;
    }
  }
  r2 && Is(n2);
}
function bs(t3, e, n2) {
  var r2 = C(t3), i = r2.queries.get(e);
  if (i)
    for (var o = 0, s = i.listeners; o < s.length; o++) {
      s[o].onError(n2);
    }
  r2.queries.delete(e);
}
function Is(t3) {
  t3.Zr.forEach(function(t4) {
    t4.next();
  });
}
var Es = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.query = t4, this.so = e, /**
           * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
           * observer. This flag is set to true once we've actually raised an event.
           */
      this.io = false, this.ro = null, this.onlineState = "Unknown", this.options = n2 || {};
    }
    return t3.prototype.no = function(t4) {
      if (!this.options.includeMetadataChanges) {
        for (var e = [], n2 = 0, r2 = t4.docChanges; n2 < r2.length; n2++) {
          var i = r2[n2];
          3 !== i.type && e.push(i);
        }
        t4 = new ps(
          t4.query,
          t4.docs,
          t4.oldDocs,
          e,
          t4.mutatedKeys,
          t4.fromCache,
          t4.syncStateChanged,
          /* excludesMetadataChanges= */
          true
        );
      }
      var o = false;
      return this.io ? this.oo(t4) && (this.so.next(t4), o = true) : this.co(t4, this.onlineState) && (this.ao(t4), o = true), this.ro = t4, o;
    }, t3.prototype.onError = function(t4) {
      this.so.error(t4);
    }, /** Returns whether a snapshot was raised. */
    t3.prototype.eo = function(t4) {
      this.onlineState = t4;
      var e = false;
      return this.ro && !this.io && this.co(this.ro, t4) && (this.ao(this.ro), e = true), e;
    }, t3.prototype.co = function(t4, e) {
      if (!t4.fromCache)
        return true;
      var n2 = "Offline" !== e;
      return !(this.options.uo && n2 || t4.docs.isEmpty() && "Offline" !== e);
    }, t3.prototype.oo = function(t4) {
      if (t4.docChanges.length > 0)
        return true;
      var e = this.ro && this.ro.hasPendingWrites !== t4.hasPendingWrites;
      return !(!t4.syncStateChanged && !e) && true === this.options.includeMetadataChanges;
    }, t3.prototype.ao = function(t4) {
      t4 = ps.fromInitialDocuments(t4.query, t4.docs, t4.mutatedKeys, t4.fromCache), this.io = true, this.so.next(t4);
    }, t3;
  }()
);
var Ts = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.payload = t4, this.byteLength = e;
    }
    return t3.prototype.ho = function() {
      return "metadata" in this.payload;
    }, t3;
  }()
);
var _s = (
  /** @class */
  function() {
    function t3(t4) {
      this.D = t4;
    }
    return t3.prototype.Gn = function(t4) {
      return kn(this.D, t4);
    }, /**
     * Converts a BundleDocument to a MaybeDocument.
     */
    t3.prototype.zn = function(t4) {
      return t4.metadata.exists ? Pn(this.D, t4.document, false) : new wt(this.Gn(t4.metadata.name), this.Hn(t4.metadata.readTime));
    }, t3.prototype.Hn = function(t4) {
      return Sn(t4);
    }, t3;
  }()
);
var Ss = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.lo = t4, this.localStore = e, this.D = n2, /** Batched queries to be saved into storage */
      this.queries = [], /** Batched documents to be saved into storage */
      this.documents = [], this.progress = Ds(t4);
    }
    return t3.prototype.fo = function(t4) {
      this.progress.bytesLoaded += t4.byteLength;
      var e = this.progress.documentsLoaded;
      return t4.payload.namedQuery ? this.queries.push(t4.payload.namedQuery) : t4.payload.documentMetadata ? (this.documents.push({
        metadata: t4.payload.documentMetadata
      }), t4.payload.documentMetadata.exists || ++e) : t4.payload.document && (this.documents[this.documents.length - 1].document = t4.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
    }, t3.prototype.wo = function(t4) {
      for (var e = /* @__PURE__ */ new Map(), n2 = new _s(this.D), r2 = 0, i = t4; r2 < i.length; r2++) {
        var o = i[r2];
        if (o.metadata.queries)
          for (var s = n2.Gn(o.metadata.name), u = 0, a = o.metadata.queries; u < a.length; u++) {
            var c = a[u], h2 = (e.get(c) || un()).add(s);
            e.set(c, h2);
          }
      }
      return e;
    }, /**
     * Update the progress to 'Success' and return the updated progress.
     */
    t3.prototype.complete = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e, n2, r2, i;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              return [4, to(this.localStore, new _s(this.D), this.documents, this.lo.id)];
            case 1:
              t4 = o.sent(), e = this.wo(this.documents), n2 = 0, r2 = this.queries, o.label = 2;
            case 2:
              return n2 < r2.length ? (i = r2[n2], [4, eo(this.localStore, i, e.get(i.name))]) : [3, 5];
            case 3:
              o.sent(), o.label = 4;
            case 4:
              return n2++, [3, 2];
            case 5:
              return [2, (this.progress.taskState = "Success", new Mi(Object.assign({}, this.progress), t4))];
          }
        });
      });
    }, t3;
  }()
);
function Ds(t3) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t3.totalDocuments,
    totalBytes: t3.totalBytes
  };
}
var Ns = function(t3) {
  this.key = t3;
};
var As = function(t3) {
  this.key = t3;
};
var ks = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.query = t4, this._o = e, this.mo = null, /**
           * A flag whether the view is current with the backend. A view is considered
           * current after it has seen the current flag from the backend and did not
           * lose consistency within the watch stream (e.g. because of an existence
           * filter mismatch).
           */
      this.current = false, /** Documents in the view but not in the remote target */
      this.yo = un(), /** Document Keys that have local changes */
      this.mutatedKeys = un(), this.po = ne(t4), this.Eo = new ls(this.po);
    }
    return Object.defineProperty(t3.prototype, "To", {
      /**
       * The set of remote documents that the server has told us belongs to the target associated with
       * this view.
       */
      get: function() {
        return this._o;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Iterates over a set of doc changes, applies the query limit, and computes
     * what the new results should be, what the changes were, and whether we may
     * need to go back to the local cache for more results. Does not make any
     * changes to the view.
     * @param docChanges - The doc changes to apply to this view.
     * @param previousChanges - If this is being called with a refill, then start
     *        with this set of docs and changes instead of the current view.
     * @returns a new set of docs, changes, and refill flag.
     */
    t3.prototype.Io = function(t4, e) {
      var n2 = this, r2 = e ? e.Ao : new ds(), i = e ? e.Eo : this.Eo, o = e ? e.mutatedKeys : this.mutatedKeys, s = i, u = false, a = Kt(this.query) && i.size === this.query.limit ? i.last() : null, c = zt(this.query) && i.size === this.query.limit ? i.first() : null;
      if (t4.inorderTraversal(function(t5, e2) {
        var h3 = i.get(t5), f = e2 instanceof gt ? e2 : null;
        f && (f = ee(n2.query, f) ? f : null);
        var l = !!h3 && n2.mutatedKeys.has(h3.key), d = !!f && (f.hasLocalMutations || // We only consider committed mutations for documents that were
        // mutated during the lifetime of the view.
        n2.mutatedKeys.has(f.key) && f.hasCommittedMutations), p2 = false;
        h3 && f ? h3.data().isEqual(f.data()) ? l !== d && (r2.track({
          type: 3,
          doc: f
        }), p2 = true) : n2.Ro(h3, f) || (r2.track({
          type: 2,
          doc: f
        }), p2 = true, (a && n2.po(f, a) > 0 || c && n2.po(f, c) < 0) && // This doc moved from inside the limit to outside the limit.
        // That means there may be some other doc in the local cache
        // that should be included instead.
        (u = true)) : !h3 && f ? (r2.track({
          type: 0,
          doc: f
        }), p2 = true) : h3 && !f && (r2.track({
          type: 1,
          doc: h3
        }), p2 = true, (a || c) && // A doc was removed from a full limit query. We'll need to
        // requery from the local cache to see if we know about some other
        // doc that should be in the results.
        (u = true)), p2 && (f ? (s = s.add(f), o = d ? o.add(t5) : o.delete(t5)) : (s = s.delete(t5), o = o.delete(t5)));
      }), Kt(this.query) || zt(this.query))
        for (; s.size > this.query.limit; ) {
          var h2 = Kt(this.query) ? s.last() : s.first();
          s = s.delete(h2.key), o = o.delete(h2.key), r2.track({
            type: 1,
            doc: h2
          });
        }
      return {
        Eo: s,
        Ao: r2,
        Mn: u,
        mutatedKeys: o
      };
    }, t3.prototype.Ro = function(t4, e) {
      return t4.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
    }, /**
     * Updates the view with the given ViewDocumentChanges and optionally updates
     * limbo docs and sync state from the provided target change.
     * @param docChanges - The set of changes to make to the view's docs.
     * @param updateLimboDocuments - Whether to update limbo documents based on
     *        this change.
     * @param targetChange - A target change to apply for computing limbo docs and
     *        sync state.
     * @returns A new ViewChange with the given docs, changes, and sync state.
     */
    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
    t3.prototype.applyChanges = function(t4, e, n2) {
      var r2 = this, i = this.Eo;
      this.Eo = t4.Eo, this.mutatedKeys = t4.mutatedKeys;
      var o = t4.Ao.Yr();
      o.sort(function(t5, e2) {
        return function(t6, e3) {
          var n3 = function(t7) {
            switch (t7) {
              case 0:
                return 1;
              case 2:
              case 3:
                return 2;
              case 1:
                return 0;
              default:
                return A2();
            }
          };
          return n3(t6) - n3(e3);
        }(t5.type, e2.type) || r2.po(t5.doc, e2.doc);
      }), this.bo(n2);
      var s = e ? this.vo() : [], u = 0 === this.yo.size && this.current ? 1 : 0, a = u !== this.mo;
      return this.mo = u, 0 !== o.length || a ? {
        snapshot: new ps(
          this.query,
          t4.Eo,
          i,
          o,
          t4.mutatedKeys,
          0 === u,
          a,
          /* excludesMetadataChanges= */
          false
        ),
        Po: s
      } : {
        Po: s
      };
    }, /**
     * Applies an OnlineState change to the view, potentially generating a
     * ViewChange if the view's syncState changes as a result.
     */
    t3.prototype.eo = function(t4) {
      return this.current && "Offline" === t4 ? (
        // If we're offline, set `current` to false and then call applyChanges()
        // to refresh our syncState and generate a ViewChange as appropriate. We
        // are guaranteed to get a new TargetChange that sets `current` back to
        // true once the client is back online.
        (this.current = false, this.applyChanges(
          {
            Eo: this.Eo,
            Ao: new ds(),
            mutatedKeys: this.mutatedKeys,
            Mn: false
          },
          /* updateLimboDocuments= */
          false
        ))
      ) : {
        Po: []
      };
    }, /**
     * Returns whether the doc for the given key should be in limbo.
     */
    t3.prototype.Vo = function(t4) {
      return !this._o.has(t4) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
      !!this.Eo.has(t4) && !this.Eo.get(t4).hasLocalMutations;
    }, /**
     * Updates syncedDocuments, current, and limbo docs based on the given change.
     * Returns the list of changes to which docs are in limbo.
     */
    t3.prototype.bo = function(t4) {
      var e = this;
      t4 && (t4.addedDocuments.forEach(function(t5) {
        return e._o = e._o.add(t5);
      }), t4.modifiedDocuments.forEach(function(t5) {
      }), t4.removedDocuments.forEach(function(t5) {
        return e._o = e._o.delete(t5);
      }), this.current = t4.current);
    }, t3.prototype.vo = function() {
      var t4 = this;
      if (!this.current)
        return [];
      var e = this.yo;
      this.yo = un(), this.Eo.forEach(function(e2) {
        t4.Vo(e2.key) && (t4.yo = t4.yo.add(e2.key));
      });
      var n2 = [];
      return e.forEach(function(e2) {
        t4.yo.has(e2) || n2.push(new As(e2));
      }), this.yo.forEach(function(t5) {
        e.has(t5) || n2.push(new Ns(t5));
      }), n2;
    }, /**
     * Update the in-memory state of the current view with the state read from
     * persistence.
     *
     * We update the query view whenever a client's primary status changes:
     * - When a client transitions from primary to secondary, it can miss
     *   LocalStorage updates and its query views may temporarily not be
     *   synchronized with the state on disk.
     * - For secondary to primary transitions, the client needs to update the list
     *   of `syncedDocuments` since secondary clients update their query views
     *   based purely on synthesized RemoteEvents.
     *
     * @param queryResult.documents - The documents that match the query according
     * to the LocalStore.
     * @param queryResult.remoteKeys - The keys of the documents that match the
     * query according to the backend.
     *
     * @returns The ViewChange that resulted from this synchronization.
     */
    // PORTING NOTE: Multi-tab only.
    t3.prototype.So = function(t4) {
      this._o = t4.jn, this.yo = un();
      var e = this.Io(t4.documents);
      return this.applyChanges(
        e,
        /*updateLimboDocuments=*/
        true
      );
    }, /**
     * Returns a view snapshot as if this query was just listened to. Contains
     * a document add for every existing document and the `fromCache` and
     * `hasPendingWrites` status of the already established view.
     */
    // PORTING NOTE: Multi-tab only.
    t3.prototype.Do = function() {
      return ps.fromInitialDocuments(this.query, this.Eo, this.mutatedKeys, 0 === this.mo);
    }, t3;
  }()
);
var Cs = function(t3, e, n2) {
  this.query = t3, this.targetId = e, this.view = n2;
};
var xs = function(t3) {
  this.key = t3, /**
           * Set to true once we've received a document. This is used in
           * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
           * decide whether it needs to manufacture a delete event for the target once
           * the target is CURRENT.
           */
  this.Co = false;
};
var Ls = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i, o) {
      this.localStore = t4, this.remoteStore = e, this.eventManager = n2, this.sharedClientState = r2, this.currentUser = i, this.maxConcurrentLimboResolutions = o, this.xo = {}, this.No = new Ei(function(t5) {
        return Zt(t5);
      }, $t), this.$o = /* @__PURE__ */ new Map(), /**
           * The keys of documents that are in limbo for which we haven't yet started a
           * limbo resolution query. The strings in this set are the result of calling
           * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
           *
           * The `Set` type was chosen because it provides efficient lookup and removal
           * of arbitrary elements and it also maintains insertion order, providing the
           * desired queue-like FIFO semantics.
           */
      this.Fo = /* @__PURE__ */ new Set(), /**
           * Keeps track of the target ID for each document that is in limbo with an
           * active target.
           */
      this.Oo = new We(H2.comparator), /**
           * Keeps track of the information about an active limbo resolution for each
           * active target ID that was started for the purpose of limbo resolution.
           */
      this.ko = /* @__PURE__ */ new Map(), this.Mo = new ro(), /** Stores user completion handlers, indexed by User and BatchId. */
      this.Lo = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
      this.Bo = /* @__PURE__ */ new Map(), this.qo = hi.ne(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
      // startup. In the interim, a client should only be considered primary if
      // `isPrimary` is true.
      this.Uo = void 0;
    }
    return Object.defineProperty(t3.prototype, "isPrimaryClient", {
      get: function() {
        return true === this.Uo;
      },
      enumerable: false,
      configurable: true
    }), t3;
  }()
);
function Rs(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o, s, u;
    return __generator(this, function(a) {
      switch (a.label) {
        case 0:
          return n2 = au(t3), (o = n2.No.get(e)) ? (
            // PORTING NOTE: With Multi-Tab Web, it is possible that a query view
            // already exists when EventManager calls us for the first time. This
            // happens when the primary tab is already listening to this query on
            // behalf of another tab and the user of the primary also starts listening
            // to the query. EventManager will not have an assigned target ID in this
            // case and calls `listen` to obtain this ID.
            (r2 = o.targetId, n2.sharedClientState.addLocalQueryTarget(r2), i = o.view.Do(), [3, 4])
          ) : [3, 1];
        case 1:
          return [4, Hi(n2.localStore, Jt(e))];
        case 2:
          return s = a.sent(), u = n2.sharedClientState.addLocalQueryTarget(s.targetId), r2 = s.targetId, [4, Os(n2, e, r2, "current" === u)];
        case 3:
          i = a.sent(), n2.isPrimaryClient && Bo(n2.remoteStore, s), a.label = 4;
        case 4:
          return [2, i];
      }
    });
  });
}
function Os(t3, e, n2, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var i, o, s, u, a, c;
    return __generator(this, function(h2) {
      switch (h2.label) {
        case 0:
          return t3.Qo = function(e2, n3, r3) {
            return function(t4, e3, n4, r4) {
              return __awaiter(this, void 0, void 0, function() {
                var i2, o2, s2;
                return __generator(this, function(u2) {
                  switch (u2.label) {
                    case 0:
                      return i2 = e3.view.Io(n4), i2.Mn ? [4, Ji(
                        t4.localStore,
                        e3.query,
                        /* usePreviousResults= */
                        false
                      ).then(function(t5) {
                        var n5 = t5.documents;
                        return e3.view.Io(n5, i2);
                      })] : [3, 2];
                    case 1:
                      i2 = u2.sent(), u2.label = 2;
                    case 2:
                      return o2 = r4 && r4.targetChanges.get(e3.targetId), s2 = e3.view.applyChanges(
                        i2,
                        /* updateLimboDocuments= */
                        t4.isPrimaryClient,
                        o2
                      ), [2, (Ws(t4, e3.targetId, s2.Po), s2.snapshot)];
                  }
                });
              });
            }(t3, e2, n3, r3);
          }, [4, Ji(
            t3.localStore,
            e,
            /* usePreviousResults= */
            true
          )];
        case 1:
          return i = h2.sent(), o = new ks(e, i.jn), s = o.Io(i.documents), u = fn.createSynthesizedTargetChangeForCurrentChange(n2, r2 && "Offline" !== t3.onlineState), a = o.applyChanges(
            s,
            /* updateLimboDocuments= */
            t3.isPrimaryClient,
            u
          ), Ws(t3, n2, a.Po), c = new Cs(e, n2, o), [2, (t3.No.set(e, c), t3.$o.has(n2) ? t3.$o.get(n2).push(e) : t3.$o.set(n2, [e]), a.snapshot)];
      }
    });
  });
}
function Ps(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          return n2 = C(t3), r2 = n2.No.get(e), (i = n2.$o.get(r2.targetId)).length > 1 ? [2, (n2.$o.set(r2.targetId, i.filter(function(t4) {
            return !$t(t4, e);
          })), void n2.No.delete(e))] : n2.isPrimaryClient ? (
            // We need to remove the local query target first to allow us to verify
            // whether any other client is still interested in this target.
            (n2.sharedClientState.removeLocalQueryTarget(r2.targetId), n2.sharedClientState.isActiveQueryTarget(r2.targetId) ? [3, 2] : [4, Yi(
              n2.localStore,
              r2.targetId,
              /*keepPersistedTargetData=*/
              false
            ).then(function() {
              n2.sharedClientState.clearQueryState(r2.targetId), jo(n2.remoteStore, r2.targetId), zs(n2, r2.targetId);
            }).catch(yi)])
          ) : [3, 3];
        case 1:
          o.sent(), o.label = 2;
        case 2:
          return [3, 5];
        case 3:
          return zs(n2, r2.targetId), [4, Yi(
            n2.localStore,
            r2.targetId,
            /*keepPersistedTargetData=*/
            true
          )];
        case 4:
          o.sent(), o.label = 5;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Ms(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o, s;
    return __generator(this, function(u) {
      switch (u.label) {
        case 0:
          r2 = cu(t3), u.label = 1;
        case 1:
          return u.trys.push([1, 5, , 6]), [4, function(t4, e2) {
            var n3, r3 = C(t4), i2 = tt.now(), o2 = e2.reduce(function(t5, e3) {
              return t5.add(e3.key);
            }, un());
            return r3.persistence.runTransaction("Locally write mutations", "readwrite", function(t5) {
              return r3.Kn.bn(t5, o2).next(function(o3) {
                n3 = o3;
                for (var s2 = [], u2 = 0, a = e2; u2 < a.length; u2++) {
                  var c = a[u2], h2 = xe(c, n3.get(c.key));
                  null != h2 && // NOTE: The base state should only be applied if there's some
                  // existing document to override, so use a Precondition of
                  // exists=true
                  s2.push(new Pe(c.key, h2, ae(h2.proto.mapValue), De.exists(true)));
                }
                return r3.Tn.addMutationBatch(t5, i2, s2, e2);
              });
            }).then(function(t5) {
              var e3 = t5.applyToLocalDocumentSet(n3);
              return {
                batchId: t5.batchId,
                changes: e3
              };
            });
          }(r2.localStore, e)];
        case 2:
          return i = u.sent(), r2.sharedClientState.addPendingMutation(i.batchId), function(t4, e2, n3) {
            var r3 = t4.Lo[t4.currentUser.toKey()];
            r3 || (r3 = new We(R2)), r3 = r3.insert(e2, n3), t4.Lo[t4.currentUser.toKey()] = r3;
          }(r2, i.batchId, n2), [4, Js(r2, i.changes)];
        case 3:
          return u.sent(), [4, ts(r2.remoteStore)];
        case 4:
          return u.sent(), [3, 6];
        case 5:
          return o = u.sent(), s = fs(o, "Failed to persist write"), n2.reject(s), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Fs(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2;
    return __generator(this, function(i) {
      switch (i.label) {
        case 0:
          n2 = C(t3), i.label = 1;
        case 1:
          return i.trys.push([1, 4, , 6]), [4, zi(n2.localStore, e)];
        case 2:
          return r2 = i.sent(), // Update `receivedDocument` as appropriate for any limbo targets.
          e.targetChanges.forEach(function(t4, e2) {
            var r3 = n2.ko.get(e2);
            r3 && // Since this is a limbo resolution lookup, it's for a single document
            // and it could be added, modified, or removed, but not a combination.
            (k2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? r3.Co = true : t4.modifiedDocuments.size > 0 ? k2(r3.Co) : t4.removedDocuments.size > 0 && (k2(r3.Co), r3.Co = false));
          }), [4, Js(n2, r2, e)];
        case 3:
          return i.sent(), [3, 6];
        case 4:
          return [4, yi(i.sent())];
        case 5:
          return i.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function qs(t3, e, n2) {
  var r2 = C(t3);
  if (r2.isPrimaryClient && 0 === n2 || !r2.isPrimaryClient && 1 === n2) {
    var i = [];
    r2.No.forEach(function(t4, n3) {
      var r3 = n3.view.eo(e);
      r3.snapshot && i.push(r3.snapshot);
    }), function(t4, e2) {
      var n3 = C(t4);
      n3.onlineState = e2;
      var r3 = false;
      n3.queries.forEach(function(t5, n4) {
        for (var i2 = 0, o = n4.listeners; i2 < o.length; i2++) {
          o[i2].eo(e2) && (r3 = true);
        }
      }), r3 && Is(n3);
    }(r2.eventManager, e), i.length && r2.xo.Tr(i), r2.onlineState = e, r2.isPrimaryClient && r2.sharedClientState.setOnlineState(e);
  }
}
function Vs(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o, s, u, a;
    return __generator(this, function(c) {
      switch (c.label) {
        case 0:
          return (r2 = C(t3)).sharedClientState.updateQueryState(e, "rejected", n2), i = r2.ko.get(e), (o = i && i.key) ? (s = (s = new We(H2.comparator)).insert(o, new wt(o, ie.min())), u = un().add(o), a = new hn(
            ie.min(),
            /* targetChanges= */
            /* @__PURE__ */ new Map(),
            /* targetMismatches= */
            new Je(R2),
            s,
            u
          ), [4, Fs(r2, a)]) : [3, 2];
        case 1:
          return c.sent(), // Since this query failed, we won't want to manually unlisten to it.
          // We only remove it from bookkeeping after we successfully applied the
          // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
          // this query when the RemoteStore restarts the Watch stream, which should
          // re-trigger the target failure.
          r2.Oo = r2.Oo.remove(o), r2.ko.delete(e), Ys(r2), [3, 4];
        case 2:
          return [4, Yi(
            r2.localStore,
            e,
            /* keepPersistedTargetData */
            false
          ).then(function() {
            return zs(r2, e, n2);
          }).catch(yi)];
        case 3:
          c.sent(), c.label = 4;
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Us(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          n2 = C(t3), r2 = e.batch.batchId, o.label = 1;
        case 1:
          return o.trys.push([1, 4, , 6]), [4, Gi(n2.localStore, e)];
        case 2:
          return i = o.sent(), // The local store may or may not be able to apply the write result and
          // raise events immediately (depending on whether the watcher is caught
          // up), so we raise user callbacks first so that they consistently happen
          // before listen events.
          Ks(
            n2,
            r2,
            /*error=*/
            null
          ), Gs(n2, r2), n2.sharedClientState.updateMutationState(r2, "acknowledged"), [4, Js(n2, i)];
        case 3:
          return o.sent(), [3, 6];
        case 4:
          return [4, yi(o.sent())];
        case 5:
          return o.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Bs(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          r2 = C(t3), o.label = 1;
        case 1:
          return o.trys.push([1, 4, , 6]), [4, function(t4, e2) {
            var n3 = C(t4);
            return n3.persistence.runTransaction("Reject batch", "readwrite-primary", function(t5) {
              var r3;
              return n3.Tn.lookupMutationBatch(t5, e2).next(function(e3) {
                return k2(null !== e3), r3 = e3.keys(), n3.Tn.removeMutationBatch(t5, e3);
              }).next(function() {
                return n3.Tn.performConsistencyCheck(t5);
              }).next(function() {
                return n3.Kn.bn(t5, r3);
              });
            });
          }(r2.localStore, e)];
        case 2:
          return i = o.sent(), // The local store may or may not be able to apply the write result and
          // raise events immediately (depending on whether the watcher is caught up),
          // so we raise user callbacks first so that they consistently happen before
          // listen events.
          Ks(r2, e, n2), Gs(r2, e), r2.sharedClientState.updateMutationState(e, "rejected", n2), [4, Js(r2, i)];
        case 3:
          return o.sent(), [3, 6];
        case 4:
          return [4, yi(o.sent())];
        case 5:
          return o.sent(), [3, 6];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function js(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o, s;
    return __generator(this, function(u) {
      switch (u.label) {
        case 0:
          Wo((n2 = C(t3)).remoteStore) || _("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."), u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), [4, function(t4) {
            var e2 = C(t4);
            return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", function(t5) {
              return e2.Tn.getHighestUnacknowledgedBatchId(t5);
            });
          }(n2.localStore)];
        case 2:
          return -1 === (r2 = u.sent()) ? [2, void e.resolve()] : ((i = n2.Bo.get(r2) || []).push(e), n2.Bo.set(r2, i), [3, 4]);
        case 3:
          return o = u.sent(), s = fs(o, "Initialization of waitForPendingWrites() operation failed"), e.reject(s), [3, 4];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Gs(t3, e) {
  (t3.Bo.get(e) || []).forEach(function(t4) {
    t4.resolve();
  }), t3.Bo.delete(e);
}
function Ks(t3, e, n2) {
  var r2 = C(t3), i = r2.Lo[r2.currentUser.toKey()];
  if (i) {
    var o = i.get(e);
    o && (n2 ? o.reject(n2) : o.resolve(), i = i.remove(e)), r2.Lo[r2.currentUser.toKey()] = i;
  }
}
function zs(t3, e, n2) {
  void 0 === n2 && (n2 = null), t3.sharedClientState.removeLocalQueryTarget(e);
  for (var r2 = 0, i = t3.$o.get(e); r2 < i.length; r2++) {
    var o = i[r2];
    t3.No.delete(o), n2 && t3.xo.Ko(o, n2);
  }
  t3.$o.delete(e), t3.isPrimaryClient && t3.Mo.os(e).forEach(function(e2) {
    t3.Mo.containsKey(e2) || // We removed the last reference for this key
    Qs(t3, e2);
  });
}
function Qs(t3, e) {
  t3.Fo.delete(e.path.canonicalString());
  var n2 = t3.Oo.get(e);
  null !== n2 && (jo(t3.remoteStore, n2), t3.Oo = t3.Oo.remove(e), t3.ko.delete(n2), Ys(t3));
}
function Ws(t3, e, n2) {
  for (var r2 = 0, i = n2; r2 < i.length; r2++) {
    var o = i[r2];
    o instanceof Ns ? (t3.Mo.addReference(o.key, e), Hs(t3, o)) : o instanceof As ? (_("SyncEngine", "Document no longer in limbo: " + o.key), t3.Mo.removeReference(o.key, e), t3.Mo.containsKey(o.key) || // We removed the last reference for this key
    Qs(t3, o.key)) : A2();
  }
}
function Hs(t3, e) {
  var n2 = e.key, r2 = n2.path.canonicalString();
  t3.Oo.get(n2) || t3.Fo.has(r2) || (_("SyncEngine", "New document in limbo: " + n2), t3.Fo.add(r2), Ys(t3));
}
function Ys(t3) {
  for (; t3.Fo.size > 0 && t3.Oo.size < t3.maxConcurrentLimboResolutions; ) {
    var e = t3.Fo.values().next().value;
    t3.Fo.delete(e);
    var n2 = new H2(z2.fromString(e)), r2 = t3.qo.next();
    t3.ko.set(r2, new xs(n2)), t3.Oo = t3.Oo.insert(n2, r2), Bo(t3.remoteStore, new Mr(Jt(Gt(n2.path)), r2, 2, I2.o));
  }
}
function Js(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o, s;
    return __generator(this, function(u) {
      switch (u.label) {
        case 0:
          return r2 = C(t3), i = [], o = [], s = [], r2.No.isEmpty() ? [3, 3] : (r2.No.forEach(function(t4, u2) {
            s.push(r2.Qo(u2, e, n2).then(function(t5) {
              if (t5) {
                r2.isPrimaryClient && r2.sharedClientState.updateQueryState(u2.targetId, t5.fromCache ? "not-current" : "current"), i.push(t5);
                var e2 = qi.Nn(u2.targetId, t5);
                o.push(e2);
              }
            }));
          }), [4, Promise.all(s)]);
        case 1:
          return u.sent(), r2.xo.Tr(i), [4, function(t4, e2) {
            return __awaiter(this, void 0, void 0, function() {
              var n3, r3, i2, o2, s2, u2, a, c, h2;
              return __generator(this, function(f) {
                switch (f.label) {
                  case 0:
                    n3 = C(t4), f.label = 1;
                  case 1:
                    return f.trys.push([1, 3, , 4]), [4, n3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", function(t5) {
                      return Er.forEach(e2, function(e3) {
                        return Er.forEach(e3.Cn, function(r4) {
                          return n3.persistence.referenceDelegate.addReference(t5, e3.targetId, r4);
                        }).next(function() {
                          return Er.forEach(e3.xn, function(r4) {
                            return n3.persistence.referenceDelegate.removeReference(t5, e3.targetId, r4);
                          });
                        });
                      });
                    })];
                  case 2:
                    return f.sent(), [3, 4];
                  case 3:
                    if (!Nr(r3 = f.sent()))
                      throw r3;
                    return _("LocalStore", "Failed to update sequence numbers: " + r3), [3, 4];
                  case 4:
                    for (i2 = 0, o2 = e2; i2 < o2.length; i2++)
                      s2 = o2[i2], u2 = s2.targetId, s2.fromCache || (a = n3.Bn.get(u2), c = a.snapshotVersion, h2 = a.withLastLimboFreeSnapshotVersion(c), // Advance the last limbo free snapshot version
                      n3.Bn = n3.Bn.insert(u2, h2));
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }(r2.localStore, o)];
        case 2:
          u.sent(), u.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function Xs(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2;
    return __generator(this, function(i) {
      switch (i.label) {
        case 0:
          return (n2 = C(t3)).currentUser.isEqual(e) ? [3, 3] : (_("SyncEngine", "User change. New user:", e.toKey()), [4, ji(n2.localStore, e)]);
        case 1:
          return r2 = i.sent(), n2.currentUser = e, // Fails tasks waiting for pending writes requested by previous user.
          function(t4, e2) {
            t4.Bo.forEach(function(t5) {
              t5.forEach(function(t6) {
                t6.reject(new G2(j.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change."));
              });
            }), t4.Bo.clear();
          }(n2), // TODO(b/114226417): Consider calling this only in the primary tab.
          n2.sharedClientState.handleUserChange(e, r2.removedBatchIds, r2.addedBatchIds), [4, Js(n2, r2.Wn)];
        case 2:
          i.sent(), i.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function $s(t3, e) {
  var n2 = C(t3), r2 = n2.ko.get(e);
  if (r2 && r2.Co)
    return un().add(r2.key);
  var i = un(), o = n2.$o.get(e);
  if (!o)
    return i;
  for (var s = 0, u = o; s < u.length; s++) {
    var a = u[s], c = n2.No.get(a);
    i = i.unionWith(c.view.To);
  }
  return i;
}
function Zs(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          return [4, Ji(
            (n2 = C(t3)).localStore,
            e.query,
            /* usePreviousResults= */
            true
          )];
        case 1:
          return r2 = o.sent(), i = e.view.So(r2), [2, (n2.isPrimaryClient && Ws(n2, e.targetId, i.Po), i)];
      }
    });
  });
}
function tu(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e;
    return __generator(this, function(n2) {
      return [2, $i((e = C(t3)).localStore).then(function(t4) {
        return Js(e, t4);
      })];
    });
  });
}
function eu(t3, e, n2, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var i, o;
    return __generator(this, function(s) {
      switch (s.label) {
        case 0:
          return [4, function(t4, e2) {
            var n3 = C(t4), r3 = C(n3.Tn);
            return n3.persistence.runTransaction("Lookup mutation documents", "readonly", function(t5) {
              return r3.Jt(t5, e2).next(function(e3) {
                return e3 ? n3.Kn.bn(t5, e3) : Er.resolve(null);
              });
            });
          }((i = C(t3)).localStore, e)];
        case 1:
          return null === (o = s.sent()) ? [3, 6] : "pending" !== n2 ? [3, 3] : [4, ts(i.remoteStore)];
        case 2:
          return s.sent(), [3, 4];
        case 3:
          "acknowledged" === n2 || "rejected" === n2 ? (
            // NOTE: Both these methods are no-ops for batches that originated from
            // other clients.
            (Ks(i, e, r2 || null), Gs(i, e), function(t4, e2) {
              C(C(t4).Tn).Xt(e2);
            }(i.localStore, e))
          ) : A2(), s.label = 4;
        case 4:
          return [4, Js(i, o)];
        case 5:
          return s.sent(), [3, 7];
        case 6:
          _("SyncEngine", "Cannot apply mutation batch with id: " + e), s.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function nu(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i, o, s, u, a, c;
    return __generator(this, function(h2) {
      switch (h2.label) {
        case 0:
          return au(n2 = C(t3)), cu(n2), true !== e || true === n2.Uo ? [3, 3] : (r2 = n2.sharedClientState.getAllActiveQueryTargets(), [4, ru(n2, r2.toArray())]);
        case 1:
          return i = h2.sent(), n2.Uo = true, [4, us(n2.remoteStore, true)];
        case 2:
          for (h2.sent(), o = 0, s = i; o < s.length; o++)
            u = s[o], Bo(n2.remoteStore, u);
          return [3, 7];
        case 3:
          return false !== e || false === n2.Uo ? [3, 7] : (a = [], c = Promise.resolve(), n2.$o.forEach(function(t4, e2) {
            n2.sharedClientState.isLocalQueryTarget(e2) ? a.push(e2) : c = c.then(function() {
              return zs(n2, e2), Yi(
                n2.localStore,
                e2,
                /*keepPersistedTargetData=*/
                true
              );
            }), jo(n2.remoteStore, e2);
          }), [4, c]);
        case 4:
          return h2.sent(), [4, ru(n2, a)];
        case 5:
          return h2.sent(), // PORTING NOTE: Multi-Tab only.
          function(t4) {
            var e2 = C(t4);
            e2.ko.forEach(function(t5, n3) {
              jo(e2.remoteStore, n3);
            }), e2.Mo.cs(), e2.ko = /* @__PURE__ */ new Map(), e2.Oo = new We(H2.comparator);
          }(n2), n2.Uo = false, [4, us(n2.remoteStore, false)];
        case 6:
          h2.sent(), h2.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ru(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var n3, r2, i, o, s, u, a, c, h2, f, l, d, p2, y2;
    return __generator(this, function(v2) {
      switch (v2.label) {
        case 0:
          n3 = C(t3), r2 = [], i = [], o = 0, s = e, v2.label = 1;
        case 1:
          return o < s.length ? (u = s[o], a = void 0, (c = n3.$o.get(u)) && 0 !== c.length ? [4, Hi(n3.localStore, Jt(c[0]))] : [3, 7]) : [3, 13];
        case 2:
          a = v2.sent(), h2 = 0, f = c, v2.label = 3;
        case 3:
          return h2 < f.length ? (l = f[h2], d = n3.No.get(l), [4, Zs(n3, d)]) : [3, 6];
        case 4:
          (p2 = v2.sent()).snapshot && i.push(p2.snapshot), v2.label = 5;
        case 5:
          return h2++, [3, 3];
        case 6:
          return [3, 11];
        case 7:
          return [4, Xi(n3.localStore, u)];
        case 8:
          return y2 = v2.sent(), [4, Hi(n3.localStore, y2)];
        case 9:
          return a = v2.sent(), [4, Os(
            n3,
            iu(y2),
            u,
            /*current=*/
            false
          )];
        case 10:
          v2.sent(), v2.label = 11;
        case 11:
          r2.push(a), v2.label = 12;
        case 12:
          return o++, [3, 1];
        case 13:
          return [2, (n3.xo.Tr(i), r2)];
      }
    });
  });
}
function iu(t3) {
  return jt(t3.path, t3.collectionGroup, t3.orderBy, t3.filters, t3.limit, "F", t3.startAt, t3.endAt);
}
function ou(t3) {
  var e = C(t3);
  return C(C(e.localStore).persistence).gn();
}
function su(t3, e, n2, r2) {
  return __awaiter(this, void 0, void 0, function() {
    var i, o, s;
    return __generator(this, function(u) {
      switch (u.label) {
        case 0:
          return (i = C(t3)).Uo ? (
            // If we receive a target state notification via WebStorage, we are
            // either already secondary or another tab has taken the primary lease.
            (_("SyncEngine", "Ignoring unexpected query state notification."), [3, 8])
          ) : [3, 1];
        case 1:
          if (!i.$o.has(e))
            return [3, 8];
          switch (n2) {
            case "current":
            case "not-current":
              return [3, 2];
            case "rejected":
              return [3, 5];
          }
          return [3, 7];
        case 2:
          return [4, $i(i.localStore)];
        case 3:
          return o = u.sent(), s = hn.createSynthesizedRemoteEventForCurrentChange(e, "current" === n2), [4, Js(i, o, s)];
        case 4:
          return u.sent(), [3, 8];
        case 5:
          return [4, Yi(
            i.localStore,
            e,
            /* keepPersistedTargetData */
            true
          )];
        case 6:
          return u.sent(), zs(i, e, r2), [3, 8];
        case 7:
          A2(), u.label = 8;
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function uu(t3, e, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, i, o, s, u, a, c, h2, f, l;
    return __generator(this, function(d) {
      switch (d.label) {
        case 0:
          if (!(r2 = au(t3)).Uo)
            return [3, 10];
          i = 0, o = e, d.label = 1;
        case 1:
          return i < o.length ? (s = o[i], r2.$o.has(s) ? (
            // A target might have been added in a previous attempt
            (_("SyncEngine", "Adding an already active target " + s), [3, 5])
          ) : [4, Xi(r2.localStore, s)]) : [3, 6];
        case 2:
          return u = d.sent(), [4, Hi(r2.localStore, u)];
        case 3:
          return a = d.sent(), [4, Os(
            r2,
            iu(u),
            a.targetId,
            /*current=*/
            false
          )];
        case 4:
          d.sent(), Bo(r2.remoteStore, a), d.label = 5;
        case 5:
          return i++, [3, 1];
        case 6:
          c = function(t4) {
            return __generator(this, function(e2) {
              switch (e2.label) {
                case 0:
                  return r2.$o.has(t4) ? [4, Yi(
                    r2.localStore,
                    t4,
                    /* keepPersistedTargetData */
                    false
                  ).then(function() {
                    jo(r2.remoteStore, t4), zs(r2, t4);
                  }).catch(yi)] : [3, 2];
                case 1:
                  e2.sent(), e2.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          }, h2 = 0, f = n2, d.label = 7;
        case 7:
          return h2 < f.length ? (l = f[h2], [5, c(l)]) : [3, 10];
        case 8:
          d.sent(), d.label = 9;
        case 9:
          return h2++, [3, 7];
        case 10:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function au(t3) {
  var e = C(t3);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Fs.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = $s.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Vs.bind(null, e), e.xo.Tr = ws.bind(null, e.eventManager), e.xo.Ko = bs.bind(null, e.eventManager), e;
}
function cu(t3) {
  var e = C(t3);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = Us.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = Bs.bind(null, e), e;
}
function hu(t3, e, n2) {
  var r2 = C(t3);
  (function(t4, e2, n3) {
    return __awaiter(this, void 0, void 0, function() {
      var r3, i, o, s, u, a;
      return __generator(this, function(c) {
        switch (c.label) {
          case 0:
            return c.trys.push([0, 14, , 15]), [4, e2.getMetadata()];
          case 1:
            return r3 = c.sent(), [4, function(t5, e3) {
              var n4 = C(t5), r4 = Sn(e3.createTime);
              return n4.persistence.runTransaction("hasNewerBundle", "readonly", function(t6) {
                return n4.He.getBundleMetadata(t6, e3.id);
              }).then(function(t6) {
                return !!t6 && t6.createTime.compareTo(r4) >= 0;
              });
            }(t4.localStore, r3)];
          case 2:
            return c.sent() ? [4, e2.close()] : [3, 4];
          case 3:
            return [2, (c.sent(), void n3._completeWith(function(t5) {
              return {
                taskState: "Success",
                documentsLoaded: t5.totalDocuments,
                bytesLoaded: t5.totalBytes,
                totalDocuments: t5.totalDocuments,
                totalBytes: t5.totalBytes
              };
            }(r3)))];
          case 4:
            return n3._updateProgress(Ds(r3)), i = new Ss(r3, t4.localStore, e2.D), [4, e2.Wo()];
          case 5:
            o = c.sent(), c.label = 6;
          case 6:
            return o ? [4, i.fo(o)] : [3, 10];
          case 7:
            return (s = c.sent()) && n3._updateProgress(s), [4, e2.Wo()];
          case 8:
            o = c.sent(), c.label = 9;
          case 9:
            return [3, 6];
          case 10:
            return [4, i.complete()];
          case 11:
            return u = c.sent(), [4, Js(
              t4,
              u.En,
              /* remoteEvent */
              void 0
            )];
          case 12:
            return c.sent(), [4, function(t5, e3) {
              var n4 = C(t5);
              return n4.persistence.runTransaction("Save bundle", "readwrite", function(t6) {
                return n4.He.saveBundleMetadata(t6, e3);
              });
            }(t4.localStore, r3)];
          case 13:
            return c.sent(), n3._completeWith(u.progress), [3, 15];
          case 14:
            return D2("SyncEngine", "Loading bundle failed with " + (a = c.sent())), n3._failWith(a), [3, 15];
          case 15:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  })(r2, e, n2).then(function() {
    r2.sharedClientState.notifyBundleLoaded();
  });
}
var fu = (
  /** @class */
  function() {
    function t3() {
      this.synchronizeTabs = false;
    }
    return t3.prototype.initialize = function(t4) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return this.D = xo(t4.databaseInfo.databaseId), this.sharedClientState = this.jo(t4), this.persistence = this.Go(t4), [4, this.persistence.start()];
            case 1:
              return e.sent(), this.gcScheduler = this.zo(t4), this.localStore = this.Ho(t4), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.zo = function(t4) {
      return null;
    }, t3.prototype.Ho = function(t4) {
      return Bi(this.persistence, new Vi(), t4.initialUser, this.D);
    }, t3.prototype.Go = function(t4) {
      return new co(fo.Cs, this.D);
    }, t3.prototype.jo = function(t4) {
      return new To();
    }, t3.prototype.terminate = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return this.gcScheduler && this.gcScheduler.stop(), [4, this.sharedClientState.shutdown()];
            case 1:
              return t4.sent(), [4, this.persistence.shutdown()];
            case 2:
              return t4.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3;
  }()
);
var lu = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).Jo = e2, i.cacheSizeBytes = n2, i.forceOwnership = r2, i.synchronizeTabs = false, i;
    }
    return __extends(e, t3), e.prototype.initialize = function(e2) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, t3.prototype.initialize.call(this, e2)];
            case 1:
              return n2.sent(), [4, Zi(this.localStore)];
            case 2:
              return n2.sent(), [4, this.Jo.initialize(this, e2)];
            case 3:
              return n2.sent(), [4, cu(this.Jo.syncEngine)];
            case 4:
              return n2.sent(), [4, ts(this.Jo.remoteStore)];
            case 5:
              return n2.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.Ho = function(t4) {
      return Bi(this.persistence, new Vi(), t4.initialUser, this.D);
    }, e.prototype.zo = function(t4) {
      var e2 = this.persistence.referenceDelegate.garbageCollector;
      return new gi(e2, t4.asyncQueue);
    }, e.prototype.Go = function(t4) {
      var e2 = Pi(t4.databaseInfo.databaseId, t4.databaseInfo.persistenceKey), n2 = void 0 !== this.cacheSizeBytes ? ni.withCacheSize(this.cacheSizeBytes) : ni.DEFAULT;
      return new Li(this.synchronizeTabs, e2, t4.clientId, n2, t4.asyncQueue, ko(), Co(), this.D, this.sharedClientState, !!this.forceOwnership);
    }, e.prototype.jo = function(t4) {
      return new To();
    }, e;
  }(fu)
);
var du = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(
        this,
        e2,
        n2,
        /* forceOwnership= */
        false
      ) || this).Jo = e2, r2.cacheSizeBytes = n2, r2.synchronizeTabs = true, r2;
    }
    return __extends(e, t3), e.prototype.initialize = function(e2) {
      return __awaiter(this, void 0, void 0, function() {
        var n2, r2 = this;
        return __generator(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, t3.prototype.initialize.call(this, e2)];
            case 1:
              return i.sent(), n2 = this.Jo.syncEngine, this.sharedClientState instanceof Eo ? (this.sharedClientState.syncEngine = {
                wi: eu.bind(null, n2),
                _i: su.bind(null, n2),
                mi: uu.bind(null, n2),
                gn: ou.bind(null, n2),
                di: tu.bind(null, n2)
              }, [4, this.sharedClientState.start()]) : [3, 3];
            case 2:
              i.sent(), i.label = 3;
            case 3:
              return [4, this.persistence.en(function(t4) {
                return __awaiter(r2, void 0, void 0, function() {
                  return __generator(this, function(e3) {
                    switch (e3.label) {
                      case 0:
                        return [4, nu(this.Jo.syncEngine, t4)];
                      case 1:
                        return e3.sent(), this.gcScheduler && (t4 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t4 || this.gcScheduler.stop()), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              })];
            case 4:
              return i.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.jo = function(t4) {
      var e2 = ko();
      if (!Eo.At(e2))
        throw new G2(j.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
      var n2 = Pi(t4.databaseInfo.databaseId, t4.databaseInfo.persistenceKey);
      return new Eo(e2, t4.asyncQueue, n2, t4.clientId, t4.initialUser);
    }, e;
  }(lu)
);
var pu = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.initialize = function(t4, e) {
      return __awaiter(this, void 0, void 0, function() {
        var n2 = this;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              return this.localStore ? [3, 2] : (this.localStore = t4.localStore, this.sharedClientState = t4.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(
                e,
                /* startAsPrimary=*/
                !t4.synchronizeTabs
              ), this.sharedClientState.onlineStateHandler = function(t5) {
                return qs(
                  n2.syncEngine,
                  t5,
                  1
                  /* SharedClientState */
                );
              }, this.remoteStore.remoteSyncer.handleCredentialChange = Xs.bind(null, this.syncEngine), [4, us(this.remoteStore, this.syncEngine.isPrimaryClient)]);
            case 1:
              r2.sent(), r2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.createEventManager = function(t4) {
      return new vs();
    }, t3.prototype.createDatastore = function(t4) {
      var e, n2 = xo(t4.databaseInfo.databaseId), r2 = (e = t4.databaseInfo, new Ao(e));
      return function(t5, e2, n3) {
        return new Mo(t5, e2, n3);
      }(t4.credentials, r2, n2);
    }, t3.prototype.createRemoteStore = function(t4) {
      var e, n2, r2, i, o, s = this;
      return e = this.localStore, n2 = this.datastore, r2 = t4.asyncQueue, i = function(t5) {
        return qs(
          s.syncEngine,
          t5,
          0
          /* RemoteStore */
        );
      }, o = So.At() ? new So() : new _o(), new qo(e, n2, r2, i, o);
    }, t3.prototype.createSyncEngine = function(t4, e) {
      return function(t5, e2, n2, r2, i, o, s) {
        var u = new Ls(t5, e2, n2, r2, i, o);
        return s && (u.Uo = true), u;
      }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t4.initialUser, t4.maxConcurrentLimboResolutions, e);
    }, t3.prototype.terminate = function() {
      return function(t4) {
        return __awaiter(this, void 0, void 0, function() {
          var e;
          return __generator(this, function(n2) {
            switch (n2.label) {
              case 0:
                return e = C(t4), _("RemoteStore", "RemoteStore shutting down."), e.Qr.add(
                  5
                  /* Shutdown */
                ), [4, Uo(e)];
              case 1:
                return n2.sent(), e.Wr.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
                // triggering spurious listener events with cached data, etc.
                e.jr.set(
                  "Unknown"
                  /* Unknown */
                ), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }(this.remoteStore);
    }, t3;
  }()
);
function yu(t3, e) {
  void 0 === e && (e = 10240);
  var n2 = 0;
  return {
    read: function() {
      return __awaiter(this, void 0, void 0, function() {
        var r2;
        return __generator(this, function(i) {
          return n2 < t3.byteLength ? (r2 = {
            value: t3.slice(n2, n2 + e),
            done: false
          }, [2, (n2 += e, r2)]) : [2, {
            done: true
          }];
        });
      });
    },
    cancel: function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          return [
            2
            /*return*/
          ];
        });
      });
    },
    releaseLock: function() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var vu = (
  /** @class */
  function() {
    function t3(t4) {
      this.observer = t4, /**
           * When set to true, will not raise future events. Necessary to deal with
           * async detachment of listener.
           */
      this.muted = false;
    }
    return t3.prototype.next = function(t4) {
      this.observer.next && this.Yo(this.observer.next, t4);
    }, t3.prototype.error = function(t4) {
      this.observer.error ? this.Yo(this.observer.error, t4) : console.error("Uncaught Error in snapshot listener:", t4);
    }, t3.prototype.Xo = function() {
      this.muted = true;
    }, t3.prototype.Yo = function(t4, e) {
      var n2 = this;
      this.muted || setTimeout(function() {
        n2.muted || t4(e);
      }, 0);
    }, t3;
  }()
);
var mu = (
  /** @class */
  function() {
    function t3(t4, e) {
      var n2 = this;
      this.Zo = t4, this.D = e, /** Cached bundle metadata. */
      this.metadata = new Ir(), /**
           * Internal buffer to hold bundle content, accumulating incomplete element
           * content.
           */
      this.buffer = new Uint8Array(), this.tc = new TextDecoder("utf-8"), // Read the metadata (which is the first element).
      this.ec().then(function(t5) {
        t5 && t5.ho() ? n2.metadata.resolve(t5.payload.metadata) : n2.metadata.reject(new Error("The first element of the bundle is not a metadata, it is\n             " + JSON.stringify(null == t5 ? void 0 : t5.payload)));
      }, function(t5) {
        return n2.metadata.reject(t5);
      });
    }
    return t3.prototype.close = function() {
      return this.Zo.cancel();
    }, t3.prototype.getMetadata = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          return [2, this.metadata.promise];
        });
      });
    }, t3.prototype.Wo = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.getMetadata()];
            case 1:
              return [2, (t4.sent(), this.ec())];
          }
        });
      });
    }, /**
     * Reads from the head of internal buffer, and pulling more data from
     * underlying stream if a complete element cannot be found, until an
     * element(including the prefixed length and the JSON string) is found.
     *
     * Once a complete element is read, it is dropped from internal buffer.
     *
     * Returns either the bundled element, or null if we have reached the end of
     * the stream.
     */
    t3.prototype.ec = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e, n2, r2;
        return __generator(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, this.nc()];
            case 1:
              return null === (t4 = i.sent()) ? [2, null] : (e = this.tc.decode(t4), n2 = Number(e), isNaN(n2) && this.sc("length string (" + e + ") is not valid number"), [4, this.ic(n2)]);
            case 2:
              return r2 = i.sent(), [2, new Ts(JSON.parse(r2), t4.length + n2)];
          }
        });
      });
    }, /** First index of '{' from the underlying buffer. */
    t3.prototype.rc = function() {
      return this.buffer.findIndex(function(t4) {
        return t4 === "{".charCodeAt(0);
      });
    }, /**
     * Reads from the beginning of the internal buffer, until the first '{', and
     * return the content.
     *
     * If reached end of the stream, returns a null.
     */
    t3.prototype.nc = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.rc() < 0 ? [4, this.oc()] : [3, 3];
            case 1:
              if (n2.sent())
                return [3, 3];
              n2.label = 2;
            case 2:
              return [3, 0];
            case 3:
              return 0 === this.buffer.length ? [2, null] : (
                // Broke out of the loop because underlying stream is closed, but still
                // cannot find an open bracket.
                ((t4 = this.rc()) < 0 && this.sc("Reached the end of bundle when a length string is expected."), e = this.buffer.slice(0, t4), [2, (this.buffer = this.buffer.slice(t4), e)])
              );
          }
        });
      });
    }, /**
     * Reads from a specified position from the internal buffer, for a specified
     * number of bytes, pulling more data from the underlying stream if needed.
     *
     * Returns a string decoded from the read bytes.
     */
    t3.prototype.ic = function(t4) {
      return __awaiter(this, void 0, void 0, function() {
        var e;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return this.buffer.length < t4 ? [4, this.oc()] : [3, 3];
            case 1:
              n2.sent() && this.sc("Reached the end of bundle when more is expected."), n2.label = 2;
            case 2:
              return [3, 0];
            case 3:
              return e = this.tc.decode(this.buffer.slice(0, t4)), [2, (this.buffer = this.buffer.slice(t4), e)];
          }
        });
      });
    }, t3.prototype.sc = function(t4) {
      throw this.Zo.cancel(), new Error("Invalid bundle format: " + t4);
    }, /**
     * Pulls more data from underlying stream to internal buffer.
     * Returns a boolean indicating whether the stream is finished.
     */
    t3.prototype.oc = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              return [4, this.Zo.read()];
            case 1:
              return (t4 = n2.sent()).done || ((e = new Uint8Array(this.buffer.length + t4.value.length)).set(this.buffer), e.set(t4.value, this.buffer.length), this.buffer = e), [2, t4.done];
          }
        });
      });
    }, t3;
  }()
);
var gu = (
  /** @class */
  function() {
    function t3(t4) {
      this.datastore = t4, // The version of each document that was read during this transaction.
      this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, /**
           * A deferred usage error that occurred previously in this transaction that
           * will cause the transaction to fail once it actually commits.
           */
      this.lastWriteError = null, /**
           * Set of documents that have been written in the transaction.
           *
           * When there's more than one write to the same key in a transaction, any
           * writes after the first are handled differently.
           */
      this.writtenDocs = /* @__PURE__ */ new Set();
    }
    return t3.prototype.lookup = function(t4) {
      return __awaiter(this, void 0, void 0, function() {
        var e, n2 = this;
        return __generator(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (this.ensureCommitNotCalled(), this.mutations.length > 0)
                throw new G2(j.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
              return [4, function(t5, e2) {
                return __awaiter(this, void 0, void 0, function() {
                  var n3, r3, i, o, s, u;
                  return __generator(this, function(a) {
                    switch (a.label) {
                      case 0:
                        return n3 = C(t5), r3 = Ln(n3.D) + "/documents", i = {
                          documents: e2.map(function(t6) {
                            return An(n3.D, t6);
                          })
                        }, [4, n3.Ui("BatchGetDocuments", r3, i)];
                      case 1:
                        return o = a.sent(), s = /* @__PURE__ */ new Map(), o.forEach(function(t6) {
                          var e3 = function(t7, e4) {
                            return "found" in e4 ? function(t8, e5) {
                              k2(!!e5.found), e5.found.name, e5.found.updateTime;
                              var n4 = kn(t8, e5.found.name), r4 = Sn(e5.found.updateTime), i2 = new se({
                                mapValue: {
                                  fields: e5.found.fields
                                }
                              });
                              return new gt(n4, r4, i2, {});
                            }(t7, e4) : "missing" in e4 ? function(t8, e5) {
                              k2(!!e5.missing), k2(!!e5.readTime);
                              var n4 = kn(t8, e5.missing), r4 = Sn(e5.readTime);
                              return new wt(n4, r4);
                            }(t7, e4) : A2();
                          }(n3.D, t6);
                          s.set(e3.key.toString(), e3);
                        }), u = [], [2, (e2.forEach(function(t6) {
                          var e3 = s.get(t6.toString());
                          k2(!!e3), u.push(e3);
                        }), u)];
                    }
                  });
                });
              }(this.datastore, t4)];
            case 1:
              return [2, ((e = r2.sent()).forEach(function(t5) {
                t5 instanceof wt || t5 instanceof gt ? n2.recordVersion(t5) : A2();
              }), e)];
          }
        });
      });
    }, t3.prototype.set = function(t4, e) {
      this.write(e.toMutation(t4, this.precondition(t4))), this.writtenDocs.add(t4.toString());
    }, t3.prototype.update = function(t4, e) {
      try {
        this.write(e.toMutation(t4, this.preconditionForUpdate(t4)));
      } catch (t5) {
        this.lastWriteError = t5;
      }
      this.writtenDocs.add(t4.toString());
    }, t3.prototype.delete = function(t4) {
      this.write(new je(t4, this.precondition(t4))), this.writtenDocs.add(t4.toString());
    }, t3.prototype.commit = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              if (this.ensureCommitNotCalled(), this.lastWriteError)
                throw this.lastWriteError;
              return t4 = this.readVersions, // For each mutation, note that the doc was written.
              this.mutations.forEach(function(e2) {
                t4.delete(e2.key.toString());
              }), // For each document that was read but not written to, we want to perform
              // a `verify` operation.
              t4.forEach(function(t5, n3) {
                var r2 = H2.fromPath(n3);
                e.mutations.push(new Ge(r2, e.precondition(r2)));
              }), [4, function(t5, e2) {
                return __awaiter(this, void 0, void 0, function() {
                  var n3, r2, i;
                  return __generator(this, function(o) {
                    switch (o.label) {
                      case 0:
                        return n3 = C(t5), r2 = Ln(n3.D) + "/documents", i = {
                          writes: e2.map(function(t6) {
                            return Mn(n3.D, t6);
                          })
                        }, [4, n3.Mi("Commit", r2, i)];
                      case 1:
                        return o.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }(this.datastore, this.mutations)];
            case 1:
              return n2.sent(), this.committed = true, [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.recordVersion = function(t4) {
      var e;
      if (t4 instanceof gt)
        e = t4.version;
      else {
        if (!(t4 instanceof wt))
          throw A2();
        e = ie.min();
      }
      var n2 = this.readVersions.get(t4.key.toString());
      if (n2) {
        if (!e.isEqual(n2))
          throw new G2(j.ABORTED, "Document version changed between two reads.");
      } else
        this.readVersions.set(t4.key.toString(), e);
    }, /**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */
    t3.prototype.precondition = function(t4) {
      var e = this.readVersions.get(t4.toString());
      return !this.writtenDocs.has(t4.toString()) && e ? De.updateTime(e) : De.none();
    }, /**
     * Returns the precondition for a document if the operation is an update.
     */
    t3.prototype.preconditionForUpdate = function(t4) {
      var e = this.readVersions.get(t4.toString());
      if (!this.writtenDocs.has(t4.toString()) && e) {
        if (e.isEqual(ie.min()))
          throw new G2(j.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
        return De.updateTime(e);
      }
      return De.exists(true);
    }, t3.prototype.write = function(t4) {
      this.ensureCommitNotCalled(), this.mutations.push(t4);
    }, t3.prototype.ensureCommitNotCalled = function() {
    }, t3;
  }()
);
var wu = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this.asyncQueue = t4, this.datastore = e, this.updateFunction = n2, this.deferred = r2, this.cc = 5, this.rr = new Lo(
        this.asyncQueue,
        "transaction_retry"
        /* TransactionRetry */
      );
    }
    return t3.prototype.run = function() {
      this.ac();
    }, t3.prototype.ac = function() {
      var t4 = this;
      this.rr.Yi(function() {
        return __awaiter(t4, void 0, void 0, function() {
          var t5, e, n2 = this;
          return __generator(this, function(r2) {
            return t5 = new gu(this.datastore), (e = this.uc(t5)) && e.then(function(e2) {
              n2.asyncQueue.enqueueAndForget(function() {
                return t5.commit().then(function() {
                  n2.deferred.resolve(e2);
                }).catch(function(t6) {
                  n2.hc(t6);
                });
              });
            }).catch(function(t6) {
              n2.hc(t6);
            }), [
              2
              /*return*/
            ];
          });
        });
      });
    }, t3.prototype.uc = function(t4) {
      try {
        var e = this.updateFunction(t4);
        return !V2(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
      } catch (t5) {
        return this.deferred.reject(t5), null;
      }
    }, t3.prototype.hc = function(t4) {
      var e = this;
      this.cc > 0 && this.lc(t4) ? (this.cc -= 1, this.asyncQueue.enqueueAndForget(function() {
        return e.ac(), Promise.resolve();
      })) : this.deferred.reject(t4);
    }, t3.prototype.lc = function(t4) {
      if ("FirebaseError" === t4.name) {
        var e = t4.code;
        return "aborted" === e || "failed-precondition" === e || !ze(e);
      }
      return false;
    }, t3;
  }()
);
var bu = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      var r2 = this;
      this.credentials = t4, this.asyncQueue = e, this.databaseInfo = n2, this.user = lo.UNAUTHENTICATED, this.clientId = L2.u(), this.credentialListener = function() {
      }, this.receivedInitialUser = new Ir(), this.credentials.setChangeListener(function(t5) {
        _("FirestoreClient", "Received user=", t5.uid), r2.user = t5, r2.credentialListener(t5), r2.receivedInitialUser.resolve();
      });
    }
    return t3.prototype.getConfiguration = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(t4) {
          switch (t4.label) {
            case 0:
              return [4, this.receivedInitialUser.promise];
            case 1:
              return [2, (t4.sent(), {
                asyncQueue: this.asyncQueue,
                databaseInfo: this.databaseInfo,
                clientId: this.clientId,
                credentials: this.credentials,
                initialUser: this.user,
                maxConcurrentLimboResolutions: 100
              })];
          }
        });
      });
    }, t3.prototype.setCredentialChangeListener = function(t4) {
      var e = this;
      this.credentialListener = t4, // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.receivedInitialUser.promise.then(function() {
        return e.credentialListener(e.user);
      });
    }, /**
     * Checks that the client has not been terminated. Ensures that other methods on
     * this class cannot be called after the client is terminated.
     */
    t3.prototype.verifyNotTerminated = function() {
      if (this.asyncQueue.isShuttingDown)
        throw new G2(j.FAILED_PRECONDITION, "The client has already been terminated.");
    }, t3.prototype.terminate = function() {
      var t4 = this;
      this.asyncQueue.enterRestrictedMode();
      var e = new Ir();
      return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(function() {
        return __awaiter(t4, void 0, void 0, function() {
          var t5, n2;
          return __generator(this, function(r2) {
            switch (r2.label) {
              case 0:
                return r2.trys.push([0, 5, , 6]), this.onlineComponents ? [4, this.onlineComponents.terminate()] : [3, 2];
              case 1:
                r2.sent(), r2.label = 2;
              case 2:
                return this.offlineComponents ? [4, this.offlineComponents.terminate()] : [3, 4];
              case 3:
                r2.sent(), r2.label = 4;
              case 4:
                return this.credentials.removeChangeListener(), e.resolve(), [3, 6];
              case 5:
                return t5 = r2.sent(), n2 = fs(t5, "Failed to shutdown persistence"), e.reject(n2), [3, 6];
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }), e.promise;
    }, t3;
  }()
);
function Iu(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2, i = this;
    return __generator(this, function(o) {
      switch (o.label) {
        case 0:
          return t3.asyncQueue.verifyOperationInProgress(), _("FirestoreClient", "Initializing OfflineComponentProvider"), [4, t3.getConfiguration()];
        case 1:
          return n2 = o.sent(), [4, e.initialize(n2)];
        case 2:
          return o.sent(), r2 = n2.initialUser, t3.setCredentialChangeListener(function(n3) {
            r2.isEqual(n3) || (r2 = n3, t3.asyncQueue.enqueueRetryable(function() {
              return __awaiter(i, void 0, void 0, function() {
                return __generator(this, function(t4) {
                  switch (t4.label) {
                    case 0:
                      return [4, ji(e.localStore, n3)];
                    case 1:
                      return t4.sent(), [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }));
          }), // When a user calls clearPersistence() in one client, all other clients
          // need to be terminated to allow the delete to succeed.
          e.persistence.setDatabaseDeletedListener(function() {
            return t3.terminate();
          }), t3.offlineComponents = e, [
            2
            /*return*/
          ];
      }
    });
  });
}
function Eu(t3, e) {
  return __awaiter(this, void 0, void 0, function() {
    var n2, r2;
    return __generator(this, function(i) {
      switch (i.label) {
        case 0:
          return t3.asyncQueue.verifyOperationInProgress(), [4, Tu(t3)];
        case 1:
          return n2 = i.sent(), _("FirestoreClient", "Initializing OnlineComponentProvider"), [4, t3.getConfiguration()];
        case 2:
          return r2 = i.sent(), [4, e.initialize(n2, r2)];
        case 3:
          return i.sent(), // The CredentialChangeListener of the online component provider takes
          // precedence over the offline component provider.
          t3.setCredentialChangeListener(function(n3) {
            return t3.asyncQueue.enqueueRetryable(function() {
              return function(t4, e2) {
                return __awaiter(this, void 0, void 0, function() {
                  var n4, r3;
                  return __generator(this, function(i2) {
                    switch (i2.label) {
                      case 0:
                        return (n4 = C(t4)).asyncQueue.verifyOperationInProgress(), _("RemoteStore", "RemoteStore received new credentials"), r3 = Wo(n4), // Tear down and re-create our network streams. This will ensure we get a
                        // fresh auth token for the new user and re-fill the write pipeline with
                        // new mutations from the LocalStore (since mutations are per-user).
                        n4.Qr.add(
                          3
                          /* CredentialChange */
                        ), [4, Uo(n4)];
                      case 1:
                        return i2.sent(), r3 && // Don't set the network status to Unknown if we are offline.
                        n4.jr.set(
                          "Unknown"
                          /* Unknown */
                        ), [4, n4.remoteSyncer.handleCredentialChange(e2)];
                      case 2:
                        return i2.sent(), n4.Qr.delete(
                          3
                          /* CredentialChange */
                        ), [4, Vo(n4)];
                      case 3:
                        return i2.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }(e.remoteStore, n3);
            });
          }), t3.onlineComponents = e, [
            2
            /*return*/
          ];
      }
    });
  });
}
function Tu(t3) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      switch (e.label) {
        case 0:
          return t3.offlineComponents ? [3, 2] : (_("FirestoreClient", "Using default OfflineComponentProvider"), [4, Iu(t3, new fu())]);
        case 1:
          e.sent(), e.label = 2;
        case 2:
          return [2, t3.offlineComponents];
      }
    });
  });
}
function _u(t3) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(e) {
      switch (e.label) {
        case 0:
          return t3.onlineComponents ? [3, 2] : (_("FirestoreClient", "Using default OnlineComponentProvider"), [4, Eu(t3, new pu())]);
        case 1:
          e.sent(), e.label = 2;
        case 2:
          return [2, t3.onlineComponents];
      }
    });
  });
}
function Su(t3) {
  return Tu(t3).then(function(t4) {
    return t4.persistence;
  });
}
function Du(t3) {
  return Tu(t3).then(function(t4) {
    return t4.localStore;
  });
}
function Nu(t3) {
  return _u(t3).then(function(t4) {
    return t4.remoteStore;
  });
}
function Au(t3) {
  return _u(t3).then(function(t4) {
    return t4.syncEngine;
  });
}
function ku(t3) {
  return __awaiter(this, void 0, void 0, function() {
    var e, n2;
    return __generator(this, function(r2) {
      switch (r2.label) {
        case 0:
          return [4, _u(t3)];
        case 1:
          return e = r2.sent(), [2, ((n2 = e.eventManager).onListen = Rs.bind(null, e.syncEngine), n2.onUnlisten = Ps.bind(null, e.syncEngine), n2)];
      }
    });
  });
}
function Cu(t3, e, n2) {
  var r2 = this;
  void 0 === n2 && (n2 = {});
  var i = new Ir();
  return t3.asyncQueue.enqueueAndForget(function() {
    return __awaiter(r2, void 0, void 0, function() {
      var r3;
      return __generator(this, function(o) {
        switch (o.label) {
          case 0:
            return r3 = function(t4, e2, n3, r4, i2) {
              var o2 = new vu({
                next: function(o3) {
                  e2.enqueueAndForget(function() {
                    return gs(t4, s);
                  });
                  var u = o3.docs.has(n3);
                  !u && o3.fromCache ? (
                    // TODO(dimond): If we're online and the document doesn't
                    // exist then we resolve with a doc.exists set to false. If
                    // we're offline however, we reject the Promise in this
                    // case. Two options: 1) Cache the negative response from
                    // the server so we can deliver that even when you're
                    // offline 2) Actually reject the Promise in the online case
                    // if the document doesn't exist.
                    i2.reject(new G2(j.UNAVAILABLE, "Failed to get document because the client is offline."))
                  ) : u && o3.fromCache && r4 && "server" === r4.source ? i2.reject(new G2(j.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i2.resolve(o3);
                },
                error: function(t5) {
                  return i2.reject(t5);
                }
              }), s = new Es(Gt(n3.path), o2, {
                includeMetadataChanges: true,
                uo: true
              });
              return ms(t4, s);
            }, [4, ku(t3)];
          case 1:
            return [2, r3.apply(void 0, [o.sent(), t3.asyncQueue, e, n2, i])];
        }
      });
    });
  }), i.promise;
}
function xu(t3, e, n2) {
  var r2 = this;
  void 0 === n2 && (n2 = {});
  var i = new Ir();
  return t3.asyncQueue.enqueueAndForget(function() {
    return __awaiter(r2, void 0, void 0, function() {
      var r3;
      return __generator(this, function(o) {
        switch (o.label) {
          case 0:
            return r3 = function(t4, e2, n3, r4, i2) {
              var o2 = new vu({
                next: function(n4) {
                  e2.enqueueAndForget(function() {
                    return gs(t4, s);
                  }), n4.fromCache && "server" === r4.source ? i2.reject(new G2(j.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i2.resolve(n4);
                },
                error: function(t5) {
                  return i2.reject(t5);
                }
              }), s = new Es(n3, o2, {
                includeMetadataChanges: true,
                uo: true
              });
              return ms(t4, s);
            }, [4, ku(t3)];
          case 1:
            return [2, r3.apply(void 0, [o.sent(), t3.asyncQueue, e, n2, i])];
        }
      });
    });
  }), i.promise;
}
var Lu = (
  /**
       * Constructs a DatabaseInfo using the provided host, databaseId and
       * persistenceKey.
       *
       * @param databaseId - The database to use.
       * @param persistenceKey - A unique identifier for this Firestore's local
       * storage (used in conjunction with the databaseId).
       * @param host - The Firestore backend host to connect to.
       * @param ssl - Whether to use SSL when connecting.
       * @param forceLongPolling - Whether to use the forceLongPolling option
       * when using WebChannel as the network transport.
       * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
       * option when using WebChannel as the network transport.
       */
  function(t3, e, n2, r2, i, o) {
    this.databaseId = t3, this.persistenceKey = e, this.host = n2, this.ssl = r2, this.forceLongPolling = i, this.autoDetectLongPolling = o;
  }
);
var Ru = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.projectId = t4, this.database = e || "(default)";
    }
    return Object.defineProperty(t3.prototype, "isDefaultDatabase", {
      get: function() {
        return "(default)" === this.database;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.isEqual = function(e) {
      return e instanceof t3 && e.projectId === this.projectId && e.database === this.database;
    }, t3;
  }()
);
var Ou = /* @__PURE__ */ new Map();
var Pu = function(t3, e) {
  this.user = e, this.type = "OAuth", this.authHeaders = {}, // Set the headers using Object Literal notation to avoid minification
  this.authHeaders.Authorization = "Bearer " + t3;
};
var Mu = (
  /** @class */
  function() {
    function t3() {
      this.changeListener = null;
    }
    return t3.prototype.getToken = function() {
      return Promise.resolve(null);
    }, t3.prototype.invalidateToken = function() {
    }, t3.prototype.setChangeListener = function(t4) {
      this.changeListener = t4, // Fire with initial user.
      t4(lo.UNAUTHENTICATED);
    }, t3.prototype.removeChangeListener = function() {
      this.changeListener = null;
    }, t3;
  }()
);
var Fu = (
  /** @class */
  function() {
    function t3(t4) {
      var e = this;
      this.fc = null, /** Tracks the current User. */
      this.currentUser = lo.UNAUTHENTICATED, this.receivedInitialUser = false, /**
           * Counter used to detect if the token changed while a getToken request was
           * outstanding.
           */
      this.dc = 0, /** The listener registered with setChangeListener(). */
      this.changeListener = null, this.forceRefresh = false, this.fc = function() {
        e.dc++, e.currentUser = e.wc(), e.receivedInitialUser = true, e.changeListener && e.changeListener(e.currentUser);
      }, this.dc = 0, this.auth = t4.getImmediate({
        optional: true
      }), this.auth ? this.auth.addAuthTokenListener(this.fc) : (
        // if auth is not available, invoke tokenListener once with null token
        (this.fc(null), t4.get().then(function(t5) {
          e.auth = t5, e.fc && // tokenListener can be removed by removeChangeListener()
          e.auth.addAuthTokenListener(e.fc);
        }, function() {
        }))
      );
    }
    return t3.prototype.getToken = function() {
      var t4 = this, e = this.dc, n2 = this.forceRefresh;
      return this.forceRefresh = false, this.auth ? this.auth.getToken(n2).then(function(n3) {
        return t4.dc !== e ? (_("FirebaseCredentialsProvider", "getToken aborted due to token change."), t4.getToken()) : n3 ? (k2("string" == typeof n3.accessToken), new Pu(n3.accessToken, t4.currentUser)) : null;
      }) : Promise.resolve(null);
    }, t3.prototype.invalidateToken = function() {
      this.forceRefresh = true;
    }, t3.prototype.setChangeListener = function(t4) {
      this.changeListener = t4, // Fire the initial event
      this.receivedInitialUser && t4(this.currentUser);
    }, t3.prototype.removeChangeListener = function() {
      this.auth && this.auth.removeAuthTokenListener(this.fc), this.fc = null, this.changeListener = null;
    }, // Auth.getUid() can return null even with a user logged in. It is because
    // getUid() is synchronous, but the auth code populating Uid is asynchronous.
    // This method should only be called in the AuthTokenListener callback
    // to guarantee to get the actual user.
    t3.prototype.wc = function() {
      var t4 = this.auth && this.auth.getUid();
      return k2(null === t4 || "string" == typeof t4), new lo(t4);
    }, t3;
  }()
);
var qu = (
  /** @class */
  function() {
    function t3(t4, e) {
      this._c = t4, this.mc = e, this.type = "FirstParty", this.user = lo.FIRST_PARTY;
    }
    return Object.defineProperty(t3.prototype, "authHeaders", {
      get: function() {
        var t4 = {
          "X-Goog-AuthUser": this.mc
        }, e = this._c.auth.getAuthHeaderValueForFirstParty([]);
        return e && (t4.Authorization = e), t4;
      },
      enumerable: false,
      configurable: true
    }), t3;
  }()
);
var Vu = (
  /** @class */
  function() {
    function t3(t4, e) {
      this._c = t4, this.mc = e;
    }
    return t3.prototype.getToken = function() {
      return Promise.resolve(new qu(this._c, this.mc));
    }, t3.prototype.setChangeListener = function(t4) {
      t4(lo.FIRST_PARTY);
    }, t3.prototype.removeChangeListener = function() {
    }, t3.prototype.invalidateToken = function() {
    }, t3;
  }()
);
function Uu(t3, e, n2) {
  if (!n2)
    throw new G2(j.INVALID_ARGUMENT, "Function " + t3 + "() cannot be called with an empty " + e + ".");
}
function Bu(t3, e) {
  if (void 0 === e)
    return {
      merge: false
    };
  if (void 0 !== e.mergeFields && void 0 !== e.merge)
    throw new G2(j.INVALID_ARGUMENT, "Invalid options passed to function " + t3 + '(): You cannot specify both "merge" and "mergeFields".');
  return e;
}
function ju(t3, e, n2, r2) {
  if (true === e && true === r2)
    throw new G2(j.INVALID_ARGUMENT, t3 + " and " + n2 + " cannot be used together.");
}
function Gu(t3) {
  if (!H2.isDocumentKey(t3))
    throw new G2(j.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + t3 + " has " + t3.length + ".");
}
function Ku(t3) {
  if (H2.isDocumentKey(t3))
    throw new G2(j.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + t3 + " has " + t3.length + ".");
}
function zu(t3) {
  if (void 0 === t3)
    return "undefined";
  if (null === t3)
    return "null";
  if ("string" == typeof t3)
    return t3.length > 20 && (t3 = t3.substring(0, 20) + "..."), JSON.stringify(t3);
  if ("number" == typeof t3 || "boolean" == typeof t3)
    return "" + t3;
  if ("object" == typeof t3) {
    if (t3 instanceof Array)
      return "an array";
    var e = (
      /** Hacky method to try to get the constructor name for an object. */
      function(t4) {
        if (t4.constructor) {
          var e2 = /function\s+([^\s(]+)\s*\(/.exec(t4.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t3)
    );
    return e ? "a custom " + e + " object" : "an object";
  }
  return "function" == typeof t3 ? "a function" : A2();
}
function Qu(t3, e) {
  if ("_delegate" in t3 && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (t3 = t3._delegate), !(t3 instanceof e)) {
    if (e.name === t3.constructor.name)
      throw new G2(j.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    var n2 = zu(t3);
    throw new G2(j.INVALID_ARGUMENT, "Expected type '" + e.name + "', but it was: " + n2);
  }
  return t3;
}
function Wu(t3, e) {
  if (e <= 0)
    throw new G2(j.INVALID_ARGUMENT, "Function " + t3 + "() requires a positive number, but it was: " + e + ".");
}
var Hu = (
  /** @class */
  function() {
    function t3(t4) {
      var e;
      if (void 0 === t4.host) {
        if (void 0 !== t4.ssl)
          throw new G2(j.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
        this.host = "firestore.googleapis.com", this.ssl = true;
      } else
        this.host = t4.host, this.ssl = null === (e = t4.ssl) || void 0 === e || e;
      if (this.credentials = t4.credentials, this.ignoreUndefinedProperties = !!t4.ignoreUndefinedProperties, void 0 === t4.cacheSizeBytes)
        this.cacheSizeBytes = 41943040;
      else {
        if (-1 !== t4.cacheSizeBytes && t4.cacheSizeBytes < 1048576)
          throw new G2(j.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
        this.cacheSizeBytes = t4.cacheSizeBytes;
      }
      this.experimentalForceLongPolling = !!t4.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t4.experimentalAutoDetectLongPolling, ju("experimentalForceLongPolling", t4.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t4.experimentalAutoDetectLongPolling);
    }
    return t3.prototype.isEqual = function(t4) {
      return this.host === t4.host && this.ssl === t4.ssl && this.credentials === t4.credentials && this.cacheSizeBytes === t4.cacheSizeBytes && this.experimentalForceLongPolling === t4.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t4.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t4.ignoreUndefinedProperties;
    }, t3;
  }()
);
var Yu = (
  /** @class */
  function() {
    function t3(t4, e) {
      this._persistenceKey = "(lite)", this._settings = new Hu({}), this._settingsFrozen = false, t4 instanceof Ru ? (this._databaseId = t4, this._credentials = new Mu()) : (this._app = t4, this._databaseId = function(t5) {
        if (!Object.prototype.hasOwnProperty.apply(t5.options, ["projectId"]))
          throw new G2(j.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
        return new Ru(t5.options.projectId);
      }(t4), this._credentials = new Fu(e));
    }
    return Object.defineProperty(t3.prototype, "app", {
      /**
       * The {@link FirebaseApp} associated with this `Firestore` service
       * instance.
       */
      get: function() {
        if (!this._app)
          throw new G2(j.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "_initialized", {
      get: function() {
        return this._settingsFrozen;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "_terminated", {
      get: function() {
        return void 0 !== this._terminateTask;
      },
      enumerable: false,
      configurable: true
    }), t3.prototype._setSettings = function(t4) {
      if (this._settingsFrozen)
        throw new G2(j.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
      this._settings = new Hu(t4), void 0 !== t4.credentials && (this._credentials = function(t5) {
        if (!t5)
          return new Mu();
        switch (t5.type) {
          case "gapi":
            var e = t5.client;
            return k2(!("object" != typeof e || null === e || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new Vu(e, t5.sessionIndex || "0");
          case "provider":
            return t5.client;
          default:
            throw new G2(j.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
        }
      }(t4.credentials));
    }, t3.prototype._getSettings = function() {
      return this._settings;
    }, t3.prototype._freezeSettings = function() {
      return this._settingsFrozen = true, this._settings;
    }, t3.prototype._delete = function() {
      return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
    }, t3.prototype.toJSON = function() {
      return {
        app: this._app,
        databaseId: this._databaseId,
        settings: this._settings
      };
    }, /**
     * Terminates all components used by this client. Subclasses can override
     * this method to clean up their own dependencies, but must also call this
     * method.
     *
     * Only ever called once.
     */
    t3.prototype._terminate = function() {
      return t4 = this, (e = Ou.get(t4)) && (_("ComponentProvider", "Removing Datastore"), Ou.delete(t4), e.terminate()), Promise.resolve();
      var t4, e;
    }, t3;
  }()
);
var Ju = function(t3) {
  this._delegate = t3;
};
var Xu = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this._converter = e, this._key = n2, /** The type of this Firestore reference. */
      this.type = "document", this.firestore = t4;
    }
    return Object.defineProperty(t3.prototype, "_path", {
      get: function() {
        return this._key.path;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "id", {
      /**
       * The document's identifier within its collection.
       */
      get: function() {
        return this._key.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "path", {
      /**
       * A string representing the path of the referenced document (relative
       * to the root of the database).
       */
      get: function() {
        return this._key.path.canonicalString();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "parent", {
      /**
       * The collection this `DocumentReference` belongs to.
       */
      get: function() {
        return new Zu(this.firestore, this._converter, this._key.path.popLast());
      },
      enumerable: false,
      configurable: true
    }), t3.prototype.withConverter = function(e) {
      return new t3(this.firestore, e, this._key);
    }, t3;
  }()
);
var $u = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this._converter = e, this._query = n2, /** The type of this Firestore reference. */
      this.type = "query", this.firestore = t4;
    }
    return t3.prototype.withConverter = function(e) {
      return new t3(this.firestore, e, this._query);
    }, t3;
  }()
);
var Zu = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this, e2, n2, Gt(r2)) || this).firestore = e2, i._path = r2, i.type = "collection", i;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "id", {
      /** The collection's identifier. */
      get: function() {
        return this._query.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "path", {
      /**
       * A string representing the path of the referenced collection (relative
       * to the root of the database).
       */
      get: function() {
        return this._query.path.canonicalString();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "parent", {
      /**
       * A reference to the containing `DocumentReference` if this is a
       * subcollection. If this isn't a subcollection, the reference is null.
       */
      get: function() {
        var t4 = this._path.popLast();
        return t4.isEmpty() ? null : new Xu(
          this.firestore,
          /* converter= */
          null,
          new H2(t4)
        );
      },
      enumerable: false,
      configurable: true
    }), e.prototype.withConverter = function(t4) {
      return new e(this.firestore, t4, this._path);
    }, e;
  }($u)
);
function ta2(t3, e) {
  for (var n2, r2 = [], i = 2; i < arguments.length; i++)
    r2[i - 2] = arguments[i];
  if (t3 instanceof Ju && (t3 = t3._delegate), Uu("collection", "path", e), t3 instanceof Yu)
    return Ku(n2 = z2.fromString.apply(z2, __spreadArray([e], r2))), new Zu(
      t3,
      /* converter= */
      null,
      n2
    );
  if (!(t3 instanceof Xu || t3 instanceof Zu))
    throw new G2(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
  return Ku(n2 = z2.fromString.apply(z2, __spreadArray([t3.path], r2)).child(z2.fromString(e))), new Zu(
    t3.firestore,
    /* converter= */
    null,
    n2
  );
}
function ea2(t3, e) {
  for (var n2, r2 = [], i = 2; i < arguments.length; i++)
    r2[i - 2] = arguments[i];
  if (t3 instanceof Ju && (t3 = t3._delegate), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  1 === arguments.length && (e = L2.u()), Uu("doc", "path", e), t3 instanceof Yu)
    return Gu(n2 = z2.fromString.apply(z2, __spreadArray([e], r2))), new Xu(
      t3,
      /* converter= */
      null,
      new H2(n2)
    );
  if (!(t3 instanceof Xu || t3 instanceof Zu))
    throw new G2(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
  return Gu(n2 = t3._path.child(z2.fromString.apply(z2, __spreadArray([e], r2)))), new Xu(t3.firestore, t3 instanceof Zu ? t3._converter : null, new H2(n2));
}
function na2(t3, e) {
  return t3 instanceof Ju && (t3 = t3._delegate), e instanceof Ju && (e = e._delegate), (t3 instanceof Xu || t3 instanceof Zu) && (e instanceof Xu || e instanceof Zu) && t3.firestore === e.firestore && t3.path === e.path && t3._converter === e._converter;
}
function ra2(t3, e) {
  return t3 instanceof Ju && (t3 = t3._delegate), e instanceof Ju && (e = e._delegate), t3 instanceof $u && e instanceof $u && t3.firestore === e.firestore && $t(t3._query, e._query) && t3._converter === e._converter;
}
var ia = (
  /** @class */
  function() {
    function t3() {
      var t4 = this;
      this.yc = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
      // retried with backoff.
      this.gc = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
      // be changed again.
      this.Ec = false, // Operations scheduled to be queued in the future. Operations are
      // automatically removed after they are run or canceled.
      this.Tc = [], // visible for testing
      this.Ic = null, // Flag set while there's an outstanding AsyncQueue operation, used for
      // assertion sanity-checks.
      this.Ac = false, // List of TimerIds to fast-forward delays for.
      this.Rc = [], // Backoff timer used to schedule retries for retryable operations
      this.rr = new Lo(
        this,
        "async_queue_retry"
        /* AsyncQueueRetry */
      ), // Visibility handler that triggers an immediate retry of all retryable
      // operations. Meant to speed up recovery when we regain file system access
      // after page comes into foreground.
      this.bc = function() {
        var e2 = Co();
        e2 && _("AsyncQueue", "Visibility state changed to " + e2.visibilityState), t4.rr.Zi();
      };
      var e = Co();
      e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.bc);
    }
    return Object.defineProperty(t3.prototype, "isShuttingDown", {
      get: function() {
        return this.Ec;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Adds a new operation to the queue without waiting for it to complete (i.e.
     * we ignore the Promise result).
     */
    t3.prototype.enqueueAndForget = function(t4) {
      this.enqueue(t4);
    }, t3.prototype.enqueueAndForgetEvenWhileRestricted = function(t4) {
      this.vc(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.Pc(t4);
    }, t3.prototype.enterRestrictedMode = function() {
      if (!this.Ec) {
        this.Ec = true;
        var t4 = Co();
        t4 && "function" == typeof t4.removeEventListener && t4.removeEventListener("visibilitychange", this.bc);
      }
    }, t3.prototype.enqueue = function(t4) {
      return this.vc(), this.Ec ? new Promise(function(t5) {
      }) : this.Pc(t4);
    }, t3.prototype.enqueueRetryable = function(t4) {
      var e = this;
      this.enqueueAndForget(function() {
        return e.gc.push(t4), e.Vc();
      });
    }, /**
     * Runs the next operation from the retryable queue. If the operation fails,
     * reschedules with backoff.
     */
    t3.prototype.Vc = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4, e = this;
        return __generator(this, function(n2) {
          switch (n2.label) {
            case 0:
              if (0 === this.gc.length)
                return [3, 5];
              n2.label = 1;
            case 1:
              return n2.trys.push([1, 3, , 4]), [4, this.gc[0]()];
            case 2:
              return n2.sent(), this.gc.shift(), this.rr.reset(), [3, 4];
            case 3:
              if (!Nr(t4 = n2.sent()))
                throw t4;
              return _("AsyncQueue", "Operation failed with retryable error: " + t4), [3, 4];
            case 4:
              this.gc.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
              // This is necessary to run retryable operations that failed during
              // their initial attempt since we don't know whether they are already
              // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
              // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
              // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
              // call scheduled here.
              // Since `backoffAndRun()` cancels an existing backoff and schedules a
              // new backoff on every call, there is only ever a single additional
              // operation in the queue.
              this.rr.Yi(function() {
                return e.Vc();
              }), n2.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, t3.prototype.Pc = function(t4) {
      var e = this, n2 = this.yc.then(function() {
        return e.Ac = true, t4().catch(function(t5) {
          throw e.Ic = t5, e.Ac = false, S2(
            "INTERNAL UNHANDLED ERROR: ",
            /**
            * Chrome includes Error.message in Error.stack. Other browsers do not.
            * This returns expected output of message + stack when available.
            * @param error - Error or FirestoreError
            */
            function(t6) {
              var e2 = t6.message || "";
              return t6.stack && (e2 = t6.stack.includes(t6.message) ? t6.stack : t6.message + "\n" + t6.stack), e2;
            }(t5)
          ), t5;
        }).then(function(t5) {
          return e.Ac = false, t5;
        });
      });
      return this.yc = n2, n2;
    }, t3.prototype.enqueueAfterDelay = function(t4, e, n2) {
      var r2 = this;
      this.vc(), // Fast-forward delays for timerIds that have been overriden.
      this.Rc.indexOf(t4) > -1 && (e = 0);
      var i = hs.createAndSchedule(this, t4, e, n2, function(t5) {
        return r2.Sc(t5);
      });
      return this.Tc.push(i), i;
    }, t3.prototype.vc = function() {
      this.Ic && A2();
    }, t3.prototype.verifyOperationInProgress = function() {
    }, /**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */
    t3.prototype.Dc = function() {
      return __awaiter(this, void 0, void 0, function() {
        var t4;
        return __generator(this, function(e) {
          switch (e.label) {
            case 0:
              return [4, t4 = this.yc];
            case 1:
              e.sent(), e.label = 2;
            case 2:
              if (t4 !== this.yc)
                return [3, 0];
              e.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, /**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */
    t3.prototype.Cc = function(t4) {
      for (var e = 0, n2 = this.Tc; e < n2.length; e++) {
        if (n2[e].timerId === t4)
          return true;
      }
      return false;
    }, /**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId - Delayed operations up to and including this TimerId
     * will be drained. Pass TimerId.All to run all delayed operations.
     * @returns a Promise that resolves once all operations have been run.
     */
    t3.prototype.xc = function(t4) {
      var e = this;
      return this.Dc().then(function() {
        e.Tc.sort(function(t5, e2) {
          return t5.targetTimeMs - e2.targetTimeMs;
        });
        for (var n2 = 0, r2 = e.Tc; n2 < r2.length; n2++) {
          var i = r2[n2];
          if (i.skipDelay(), "all" !== t4 && i.timerId === t4)
            break;
        }
        return e.Dc();
      });
    }, /**
     * For Tests: Skip all subsequent delays for a timer id.
     */
    t3.prototype.Nc = function(t4) {
      this.Rc.push(t4);
    }, /** Called once a DelayedOperation is run or canceled. */
    t3.prototype.Sc = function(t4) {
      var e = this.Tc.indexOf(t4);
      this.Tc.splice(e, 1);
    }, t3;
  }()
);
function oa2(t3) {
  return function(t4, e) {
    if ("object" != typeof t4 || null === t4)
      return false;
    for (var n2 = t4, r2 = 0, i = ["next", "error", "complete"]; r2 < i.length; r2++) {
      var o = i[r2];
      if (o in n2 && "function" == typeof n2[o])
        return true;
    }
    return false;
  }(t3);
}
var sa2 = (
  /** @class */
  function() {
    function t3() {
      this._progressObserver = {}, this._taskCompletionResolver = new Ir(), this._lastProgress = {
        taskState: "Running",
        totalBytes: 0,
        totalDocuments: 0,
        bytesLoaded: 0,
        documentsLoaded: 0
      };
    }
    return t3.prototype.onProgress = function(t4, e, n2) {
      this._progressObserver = {
        next: t4,
        error: e,
        complete: n2
      };
    }, /**
     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.
     *
     * @param onRejected - Called when an error occurs during bundle loading.
     */
    t3.prototype.catch = function(t4) {
      return this._taskCompletionResolver.promise.catch(t4);
    }, /**
     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.
     *
     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.
     *   The update will always have its `taskState` set to `"Success"`.
     * @param onRejected - Called when an error occurs during bundle loading.
     */
    t3.prototype.then = function(t4, e) {
      return this._taskCompletionResolver.promise.then(t4, e);
    }, /**
     * Notifies all observers that bundle loading has completed, with a provided
     * `LoadBundleTaskProgress` object.
     *
     * @private
     */
    t3.prototype._completeWith = function(t4) {
      this._updateProgress(t4), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t4);
    }, /**
     * Notifies all observers that bundle loading has failed, with a provided
     * `Error` as the reason.
     *
     * @private
     */
    t3.prototype._failWith = function(t4) {
      this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t4), this._taskCompletionResolver.reject(t4);
    }, /**
     * Notifies a progress update of loading a bundle.
     * @param progress - The new progress.
     *
     * @private
     */
    t3.prototype._updateProgress = function(t4) {
      this._lastProgress = t4, this._progressObserver.next && this._progressObserver.next(t4);
    }, t3;
  }()
);
var ua2 = -1;
var aa2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2, n2) || this)._queue = new ia(), r2._persistenceKey = "name" in e2 ? e2.name : "[DEFAULT]", r2;
    }
    return __extends(e, t3), e.prototype._terminate = function() {
      return this._firestoreClient || // The client must be initialized to ensure that all subsequent API
      // usage throws an exception.
      ha2(this), this._firestoreClient.terminate();
    }, e;
  }(Yu)
);
function ca2(t3) {
  return t3._firestoreClient || ha2(t3), t3._firestoreClient.verifyNotTerminated(), t3._firestoreClient;
}
function ha2(t3) {
  var e = t3._freezeSettings(), n2 = function(t4, e2, n3) {
    return new Lu(t4, e2, n3.host, n3.ssl, n3.experimentalForceLongPolling, n3.experimentalAutoDetectLongPolling);
  }(t3._databaseId, t3._persistenceKey, e);
  t3._firestoreClient = new bu(t3._credentials, t3._queue, n2);
}
function fa2(t3, e, n2) {
  var r2 = this, i = new Ir();
  return t3.asyncQueue.enqueue(function() {
    return __awaiter(r2, void 0, void 0, function() {
      var r3;
      return __generator(this, function(o) {
        switch (o.label) {
          case 0:
            return o.trys.push([0, 3, , 4]), [4, Iu(t3, n2)];
          case 1:
            return o.sent(), [4, Eu(t3, e)];
          case 2:
            return o.sent(), i.resolve(), [3, 4];
          case 3:
            if (!/**
            * Decides whether the provided error allows us to gracefully disable
            * persistence (as opposed to crashing the client).
            */
            function(t4) {
              return "FirebaseError" === t4.name ? t4.code === j.FAILED_PRECONDITION || t4.code === j.UNIMPLEMENTED : !("undefined" != typeof DOMException && t4 instanceof DOMException) || (22 === t4.code || 20 === t4.code || // Firefox Private Browsing mode disables IndexedDb and returns
              // INVALID_STATE for any usage.
              11 === t4.code);
            }(r3 = o.sent()))
              throw r3;
            return console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + r3), i.reject(r3), [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }).then(function() {
    return i.promise;
  });
}
function la(t3) {
  if (t3._initialized || t3._terminated)
    throw new G2(j.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var da2 = (
  /** @class */
  function() {
    function t3() {
      for (var t4 = [], e = 0; e < arguments.length; e++)
        t4[e] = arguments[e];
      for (var n2 = 0; n2 < t4.length; ++n2)
        if (0 === t4[n2].length)
          throw new G2(j.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
      this._internalPath = new W2(t4);
    }
    return t3.prototype.isEqual = function(t4) {
      return this._internalPath.isEqual(t4._internalPath);
    }, t3;
  }()
);
var pa2 = (
  /** @class */
  function() {
    function t3(t4) {
      this._byteString = t4;
    }
    return t3.fromBase64String = function(e) {
      try {
        return new t3(Y2.fromBase64String(e));
      } catch (e2) {
        throw new G2(j.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e2);
      }
    }, /**
     * Creates a new `Bytes` object from the given Uint8Array.
     *
     * @param array - The Uint8Array used to create the `Bytes` object.
     */
    t3.fromUint8Array = function(e) {
      return new t3(Y2.fromUint8Array(e));
    }, /**
     * Returns the underlying bytes as a Base64-encoded string.
     *
     * @returns The Base64-encoded string created from the `Bytes` object.
     */
    t3.prototype.toBase64 = function() {
      return this._byteString.toBase64();
    }, /**
     * Returns the underlying bytes in a new `Uint8Array`.
     *
     * @returns The Uint8Array created from the `Bytes` object.
     */
    t3.prototype.toUint8Array = function() {
      return this._byteString.toUint8Array();
    }, /**
     * Returns a string representation of the `Bytes` object.
     *
     * @returns A string representation of the `Bytes` object.
     */
    t3.prototype.toString = function() {
      return "Bytes(base64: " + this.toBase64() + ")";
    }, /**
     * Returns true if this `Bytes` object is equal to the provided one.
     *
     * @param other - The `Bytes` object to compare against.
     * @returns true if this `Bytes` object is equal to the provided one.
     */
    t3.prototype.isEqual = function(t4) {
      return this._byteString.isEqual(t4._byteString);
    }, t3;
  }()
);
var ya = (
  /**
       * @param _methodName - The public API endpoint that returns this class.
       */
  function(t3) {
    this._methodName = t3;
  }
);
var va = (
  /** @class */
  function() {
    function t3(t4, e) {
      if (!isFinite(t4) || t4 < -90 || t4 > 90)
        throw new G2(j.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t4);
      if (!isFinite(e) || e < -180 || e > 180)
        throw new G2(j.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
      this._lat = t4, this._long = e;
    }
    return Object.defineProperty(t3.prototype, "latitude", {
      /**
       * The latitude of this `GeoPoint` instance.
       */
      get: function() {
        return this._lat;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "longitude", {
      /**
       * The longitude of this `GeoPoint` instance.
       */
      get: function() {
        return this._long;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Returns true if this `GeoPoint` is equal to the provided one.
     *
     * @param other - The `GeoPoint` to compare against.
     * @returns true if this `GeoPoint` is equal to the provided one.
     */
    t3.prototype.isEqual = function(t4) {
      return this._lat === t4._lat && this._long === t4._long;
    }, t3.prototype.toJSON = function() {
      return {
        latitude: this._lat,
        longitude: this._long
      };
    }, /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    t3.prototype._compareTo = function(t4) {
      return R2(this._lat, t4._lat) || R2(this._long, t4._long);
    }, t3;
  }()
);
var ma2 = /^__.*__$/;
var ga = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.data = t4, this.fieldMask = e, this.fieldTransforms = n2;
    }
    return t3.prototype.toMutation = function(t4, e) {
      return null !== this.fieldMask ? new Pe(t4, this.data, this.fieldMask, e, this.fieldTransforms) : new Oe(t4, this.data, e, this.fieldTransforms);
    }, t3;
  }()
);
var wa = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.data = t4, this.fieldMask = e, this.fieldTransforms = n2;
    }
    return t3.prototype.toMutation = function(t4, e) {
      return new Pe(t4, this.data, this.fieldMask, e, this.fieldTransforms);
    }, t3;
  }()
);
function ba2(t3) {
  switch (t3) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw A2();
  }
}
var Ia2 = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i, o) {
      this.settings = t4, this.databaseId = e, this.D = n2, this.ignoreUndefinedProperties = r2, // Minor hack: If fieldTransforms is undefined, we assume this is an
      // external call and we need to validate the entire path.
      void 0 === i && this.$c(), this.fieldTransforms = i || [], this.fieldMask = o || [];
    }
    return Object.defineProperty(t3.prototype, "path", {
      get: function() {
        return this.settings.path;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "Fc", {
      get: function() {
        return this.settings.Fc;
      },
      enumerable: false,
      configurable: true
    }), /** Returns a new context with the specified settings overwritten. */
    t3.prototype.Oc = function(e) {
      return new t3(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.D, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
    }, t3.prototype.kc = function(t4) {
      var e, n2 = null === (e = this.path) || void 0 === e ? void 0 : e.child(t4), r2 = this.Oc({
        path: n2,
        Mc: false
      });
      return r2.Lc(t4), r2;
    }, t3.prototype.Bc = function(t4) {
      var e, n2 = null === (e = this.path) || void 0 === e ? void 0 : e.child(t4), r2 = this.Oc({
        path: n2,
        Mc: false
      });
      return r2.$c(), r2;
    }, t3.prototype.qc = function(t4) {
      return this.Oc({
        path: void 0,
        Mc: true
      });
    }, t3.prototype.Uc = function(t4) {
      return Ba2(t4, this.settings.methodName, this.settings.Qc || false, this.path, this.settings.Kc);
    }, /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
    t3.prototype.contains = function(t4) {
      return void 0 !== this.fieldMask.find(function(e) {
        return t4.isPrefixOf(e);
      }) || void 0 !== this.fieldTransforms.find(function(e) {
        return t4.isPrefixOf(e.field);
      });
    }, t3.prototype.$c = function() {
      if (this.path)
        for (var t4 = 0; t4 < this.path.length; t4++)
          this.Lc(this.path.get(t4));
    }, t3.prototype.Lc = function(t4) {
      if (0 === t4.length)
        throw this.Uc("Document fields must not be empty");
      if (ba2(this.Fc) && ma2.test(t4))
        throw this.Uc('Document fields cannot begin and end with "__"');
    }, t3;
  }()
);
var Ea2 = (
  /** @class */
  function() {
    function t3(t4, e, n2) {
      this.databaseId = t4, this.ignoreUndefinedProperties = e, this.D = n2 || xo(t4);
    }
    return t3.prototype.Wc = function(t4, e, n2, r2) {
      return void 0 === r2 && (r2 = false), new Ia2({
        Fc: t4,
        methodName: e,
        Kc: n2,
        path: W2.emptyPath(),
        Mc: false,
        Qc: r2
      }, this.databaseId, this.D, this.ignoreUndefinedProperties);
    }, t3;
  }()
);
function Ta2(t3) {
  var e = t3._freezeSettings(), n2 = xo(t3._databaseId);
  return new Ea2(t3._databaseId, !!e.ignoreUndefinedProperties, n2);
}
function _a3(t3, e, n2, r2, i, o) {
  void 0 === o && (o = {});
  var s = t3.Wc(o.merge || o.mergeFields ? 2 : 0, e, n2, i);
  Fa2("Data must be an object, but it was:", s, r2);
  var u, a, c = Pa(r2, s);
  if (o.merge)
    u = new oe(s.fieldMask), a = s.fieldTransforms;
  else if (o.mergeFields) {
    for (var h2 = [], f = 0, l = o.mergeFields; f < l.length; f++) {
      var d = qa2(e, l[f], n2);
      if (!s.contains(d))
        throw new G2(j.INVALID_ARGUMENT, "Field '" + d + "' is specified in your field mask but missing from your input data.");
      ja2(h2, d) || h2.push(d);
    }
    u = new oe(h2), a = s.fieldTransforms.filter(function(t4) {
      return u.covers(t4.field);
    });
  } else
    u = null, a = s.fieldTransforms;
  return new ga(new se(c), u, a);
}
var Sa = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype._toFieldTransform = function(t4) {
      if (2 !== t4.Fc)
        throw 1 === t4.Fc ? t4.Uc(this._methodName + "() can only appear at the top level of your update data") : t4.Uc(this._methodName + "() cannot be used with set() unless you pass {merge:true}");
      return t4.fieldMask.push(t4.path), null;
    }, e.prototype.isEqual = function(t4) {
      return t4 instanceof e;
    }, e;
  }(ya)
);
function Da2(t3, e, n2) {
  return new Ia2({
    Fc: 3,
    Kc: e.settings.Kc,
    methodName: t3._methodName,
    Mc: n2
  }, e.databaseId, e.D, e.ignoreUndefinedProperties);
}
var Na = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype._toFieldTransform = function(t4) {
      return new _e(t4.path, new ve());
    }, e.prototype.isEqual = function(t4) {
      return t4 instanceof e;
    }, e;
  }(ya)
);
var Aa2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2) || this).jc = n2, r2;
    }
    return __extends(e, t3), e.prototype._toFieldTransform = function(t4) {
      var e2 = Da2(
        this,
        t4,
        /*array=*/
        true
      ), n2 = this.jc.map(function(t5) {
        return Oa(t5, e2);
      }), r2 = new me(n2);
      return new _e(t4.path, r2);
    }, e.prototype.isEqual = function(t4) {
      return this === t4;
    }, e;
  }(ya)
);
var ka2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2) || this).jc = n2, r2;
    }
    return __extends(e, t3), e.prototype._toFieldTransform = function(t4) {
      var e2 = Da2(
        this,
        t4,
        /*array=*/
        true
      ), n2 = this.jc.map(function(t5) {
        return Oa(t5, e2);
      }), r2 = new we(n2);
      return new _e(t4.path, r2);
    }, e.prototype.isEqual = function(t4) {
      return this === t4;
    }, e;
  }(ya)
);
var Ca2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2) || this).Gc = n2, r2;
    }
    return __extends(e, t3), e.prototype._toFieldTransform = function(t4) {
      var e2 = new Ie(t4.D, fe(t4.D, this.Gc));
      return new _e(t4.path, e2);
    }, e.prototype.isEqual = function(t4) {
      return this === t4;
    }, e;
  }(ya)
);
function xa(t3, e, n2, r2) {
  var i = t3.Wc(1, e, n2);
  Fa2("Data must be an object, but it was:", i, r2);
  var o = [], s = new ue();
  F2(r2, function(t4, r3) {
    var u2 = Ua2(e, t4, n2);
    r3 instanceof Ju && (r3 = r3._delegate);
    var a = i.Bc(u2);
    if (r3 instanceof Sa)
      o.push(u2);
    else {
      var c = Oa(r3, a);
      null != c && (o.push(u2), s.set(u2, c));
    }
  });
  var u = new oe(o);
  return new wa(s.v(), u, i.fieldTransforms);
}
function La2(t3, e, n2, r2, i, o) {
  var s = t3.Wc(1, e, n2), u = [qa2(e, r2, n2)], a = [i];
  if (o.length % 2 != 0)
    throw new G2(j.INVALID_ARGUMENT, "Function " + e + "() needs to be called with an even number of arguments that alternate between field names and values.");
  for (var c = 0; c < o.length; c += 2)
    u.push(qa2(e, o[c])), a.push(o[c + 1]);
  for (var h2 = [], f = new ue(), l = u.length - 1; l >= 0; --l)
    if (!ja2(h2, u[l])) {
      var d = u[l], p2 = a[l];
      p2 instanceof Ju && (p2 = p2._delegate);
      var y2 = s.Bc(d);
      if (p2 instanceof Sa)
        h2.push(d);
      else {
        var v2 = Oa(p2, y2);
        null != v2 && (h2.push(d), f.set(d, v2));
      }
    }
  var m = new oe(h2);
  return new wa(f.v(), m, s.fieldTransforms);
}
function Ra2(t3, e, n2, r2) {
  return void 0 === r2 && (r2 = false), Oa(n2, t3.Wc(r2 ? 4 : 3, e));
}
function Oa(t3, e) {
  if (
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    t3 instanceof Ju && (t3 = t3._delegate), Ma2(t3)
  )
    return Fa2("Unsupported field value:", e, t3), Pa(t3, e);
  if (t3 instanceof ya)
    return function(t4, e2) {
      if (!ba2(e2.Fc))
        throw e2.Uc(t4._methodName + "() can only be used with update() and set()");
      if (!e2.path)
        throw e2.Uc(t4._methodName + "() is not currently supported inside arrays");
      var n2 = t4._toFieldTransform(e2);
      n2 && e2.fieldTransforms.push(n2);
    }(t3, e), null;
  if (void 0 === t3 && e.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.fieldMask.push(e.path), t3 instanceof Array
  ) {
    if (e.settings.Mc && 4 !== e.Fc)
      throw e.Uc("Nested arrays are not supported");
    return function(t4, e2) {
      for (var n2 = [], r2 = 0, i = 0, o = t4; i < o.length; i++) {
        var s = Oa(o[i], e2.qc(r2));
        null == s && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (s = {
          nullValue: "NULL_VALUE"
        }), n2.push(s), r2++;
      }
      return {
        arrayValue: {
          values: n2
        }
      };
    }(t3, e);
  }
  return function(t4, e2) {
    if (t4 instanceof Ju && (t4 = t4._delegate), null === t4)
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t4)
      return fe(e2.D, t4);
    if ("boolean" == typeof t4)
      return {
        booleanValue: t4
      };
    if ("string" == typeof t4)
      return {
        stringValue: t4
      };
    if (t4 instanceof Date) {
      var n2 = tt.fromDate(t4);
      return {
        timestampValue: En(e2.D, n2)
      };
    }
    if (t4 instanceof tt) {
      n2 = new tt(t4.seconds, 1e3 * Math.floor(t4.nanoseconds / 1e3));
      return {
        timestampValue: En(e2.D, n2)
      };
    }
    if (t4 instanceof va)
      return {
        geoPointValue: {
          latitude: t4.latitude,
          longitude: t4.longitude
        }
      };
    if (t4 instanceof pa2)
      return {
        bytesValue: Tn(e2.D, t4._byteString)
      };
    if (t4 instanceof Xu) {
      n2 = e2.databaseId;
      var r2 = t4.firestore._databaseId;
      if (!r2.isEqual(n2))
        throw e2.Uc("Document reference is for database " + r2.projectId + "/" + r2.database + " but should be for database " + n2.projectId + "/" + n2.database);
      return {
        referenceValue: Dn(t4.firestore._databaseId || e2.databaseId, t4._key.path)
      };
    }
    throw e2.Uc("Unsupported field value: " + zu(t4));
  }(t3, e);
}
function Pa(t3, e) {
  var n2 = {};
  return q2(t3) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.fieldMask.push(e.path)
  ) : F2(t3, function(t4, r2) {
    var i = Oa(r2, e.kc(t4));
    null != i && (n2[t4] = i);
  }), {
    mapValue: {
      fields: n2
    }
  };
}
function Ma2(t3) {
  return !("object" != typeof t3 || null === t3 || t3 instanceof Array || t3 instanceof Date || t3 instanceof tt || t3 instanceof va || t3 instanceof pa2 || t3 instanceof Xu || t3 instanceof ya);
}
function Fa2(t3, e, n2) {
  if (!Ma2(n2) || !function(t4) {
    return "object" == typeof t4 && null !== t4 && (Object.getPrototypeOf(t4) === Object.prototype || null === Object.getPrototypeOf(t4));
  }(n2)) {
    var r2 = zu(n2);
    throw "an object" === r2 ? e.Uc(t3 + " a custom object") : e.Uc(t3 + " " + r2);
  }
}
function qa2(t3, e, n2) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    e instanceof Ju && (e = e._delegate), e instanceof da2
  )
    return e._internalPath;
  if ("string" == typeof e)
    return Ua2(t3, e);
  throw Ba2(
    "Field path arguments must be of type string or FieldPath.",
    t3,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n2
  );
}
var Va2 = new RegExp("[~\\*/\\[\\]]");
function Ua2(t3, e, n2) {
  if (e.search(Va2) >= 0)
    throw Ba2(
      "Invalid field path (" + e + "). Paths must not contain '~', '*', '/', '[', or ']'",
      t3,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n2
    );
  try {
    return new (da2.bind.apply(da2, __spreadArray([void 0], e.split("."))))()._internalPath;
  } catch (r2) {
    throw Ba2(
      "Invalid field path (" + e + "). Paths must not be empty, begin with '.', end with '.', or contain '..'",
      t3,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n2
    );
  }
}
function Ba2(t3, e, n2, r2, i) {
  var o = r2 && !r2.isEmpty(), s = void 0 !== i, u = "Function " + e + "() called with invalid data";
  n2 && (u += " (via `toFirestore()`)");
  var a = "";
  return (o || s) && (a += " (found", o && (a += " in field " + r2), s && (a += " in document " + i), a += ")"), new G2(j.INVALID_ARGUMENT, (u += ". ") + t3 + a);
}
function ja2(t3, e) {
  return t3.some(function(t4) {
    return t4.isEqual(e);
  });
}
var Ga2 = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2, i) {
      this._firestore = t4, this._userDataWriter = e, this._key = n2, this._document = r2, this._converter = i;
    }
    return Object.defineProperty(t3.prototype, "id", {
      /** Property of the `DocumentSnapshot` that provides the document's ID. */
      get: function() {
        return this._key.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "ref", {
      /**
       * The `DocumentReference` for the document included in the `DocumentSnapshot`.
       */
      get: function() {
        return new Xu(this._firestore, this._converter, this._key);
      },
      enumerable: false,
      configurable: true
    }), /**
     * Signals whether or not the document at the snapshot's location exists.
     *
     * @returns true if the document exists.
     */
    t3.prototype.exists = function() {
      return null !== this._document;
    }, /**
     * Retrieves all fields in the document as an `Object`. Returns `undefined` if
     * the document doesn't exist.
     *
     * @returns An `Object` containing all fields in the document or `undefined`
     * if the document doesn't exist.
     */
    t3.prototype.data = function() {
      if (this._document) {
        if (this._converter) {
          var t4 = new Ka2(
            this._firestore,
            this._userDataWriter,
            this._key,
            this._document,
            /* converter= */
            null
          );
          return this._converter.fromFirestore(t4);
        }
        return this._userDataWriter.convertValue(this._document.toProto());
      }
    }, /**
     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
     * document or field doesn't exist.
     *
     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
     * field.
     * @returns The data at the specified field location or undefined if no such
     * field exists in the document.
     */
    // We are using `any` here to avoid an explicit cast by our users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    t3.prototype.get = function(t4) {
      if (this._document) {
        var e = this._document.data().field(za2("DocumentSnapshot.get", t4));
        if (null !== e)
          return this._userDataWriter.convertValue(e);
      }
    }, t3;
  }()
);
var Ka2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.data = function() {
      return t3.prototype.data.call(this);
    }, e;
  }(Ga2)
);
function za2(t3, e) {
  return "string" == typeof e ? Ua2(t3, e) : e instanceof Ju ? e._delegate._internalPath : e._internalPath;
}
var Qa2 = (
  /** @class */
  function() {
    function t3(t4, e) {
      this.hasPendingWrites = t4, this.fromCache = e;
    }
    return t3.prototype.isEqual = function(t4) {
      return this.hasPendingWrites === t4.hasPendingWrites && this.fromCache === t4.fromCache;
    }, t3;
  }()
);
var Wa2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2, i, o, s) {
      var u = this;
      return (u = t3.call(this, e2, n2, r2, i, s) || this)._firestore = e2, u._firestoreImpl = e2, u.metadata = o, u;
    }
    return __extends(e, t3), e.prototype.exists = function() {
      return t3.prototype.exists.call(this);
    }, /**
     * Retrieves all fields in the document as an `Object`. Returns `undefined` if
     * the document doesn't exist.
     *
     * By default, `FieldValue.serverTimestamp()` values that have not yet been
     * set to their final value will be returned as `null`. You can override
     * this by passing an options object.
     *
     * @param options - An options object to configure how data is retrieved from
     * the snapshot (for example the desired behavior for server timestamps that
     * have not yet been set to their final value).
     * @returns An `Object` containing all fields in the document or `undefined` if
     * the document doesn't exist.
     */
    e.prototype.data = function(t4) {
      if (void 0 === t4 && (t4 = {}), this._document) {
        if (this._converter) {
          var e2 = new Ha2(
            this._firestore,
            this._userDataWriter,
            this._key,
            this._document,
            this.metadata,
            /* converter= */
            null
          );
          return this._converter.fromFirestore(e2, t4);
        }
        return this._userDataWriter.convertValue(this._document.toProto(), t4.serverTimestamps);
      }
    }, /**
     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
     * document or field doesn't exist.
     *
     * By default, a `FieldValue.serverTimestamp()` that has not yet been set to
     * its final value will be returned as `null`. You can override this by
     * passing an options object.
     *
     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
     * field.
     * @param options - An options object to configure how the field is retrieved
     * from the snapshot (for example the desired behavior for server timestamps
     * that have not yet been set to their final value).
     * @returns The data at the specified field location or undefined if no such
     * field exists in the document.
     */
    // We are using `any` here to avoid an explicit cast by our users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.prototype.get = function(t4, e2) {
      if (void 0 === e2 && (e2 = {}), this._document) {
        var n2 = this._document.data().field(za2("DocumentSnapshot.get", t4));
        if (null !== n2)
          return this._userDataWriter.convertValue(n2, e2.serverTimestamps);
      }
    }, e;
  }(Ga2)
);
var Ha2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.data = function(e2) {
      return void 0 === e2 && (e2 = {}), t3.prototype.data.call(this, e2);
    }, e;
  }(Wa2)
);
var Ya2 = (
  /** @class */
  function() {
    function t3(t4, e, n2, r2) {
      this._firestore = t4, this._userDataWriter = e, this._snapshot = r2, this.metadata = new Qa2(r2.hasPendingWrites, r2.fromCache), this.query = n2;
    }
    return Object.defineProperty(t3.prototype, "docs", {
      /** An array of all the documents in the `QuerySnapshot`. */
      get: function() {
        var t4 = [];
        return this.forEach(function(e) {
          return t4.push(e);
        }), t4;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "size", {
      /** The number of documents in the `QuerySnapshot`. */
      get: function() {
        return this._snapshot.docs.size;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t3.prototype, "empty", {
      /** True if there are no documents in the `QuerySnapshot`. */
      get: function() {
        return 0 === this.size;
      },
      enumerable: false,
      configurable: true
    }), /**
     * Enumerates all of the documents in the `QuerySnapshot`.
     *
     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
     * each document in the snapshot.
     * @param thisArg - The `this` binding for the callback.
     */
    t3.prototype.forEach = function(t4, e) {
      var n2 = this;
      this._snapshot.docs.forEach(function(r2) {
        t4.call(e, new Ha2(n2._firestore, n2._userDataWriter, r2.key, r2, new Qa2(n2._snapshot.mutatedKeys.has(r2.key), n2._snapshot.fromCache), n2.query._converter));
      });
    }, /**
     * Returns an array of the documents changes since the last snapshot. If this
     * is the first snapshot, all documents will be in the list as 'added'
     * changes.
     *
     * @param options - `SnapshotListenOptions` that control whether metadata-only
     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger
     * snapshot events.
     */
    t3.prototype.docChanges = function(t4) {
      void 0 === t4 && (t4 = {});
      var e = !!t4.includeMetadataChanges;
      if (e && this._snapshot.excludesMetadataChanges)
        throw new G2(j.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
      return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = /** Calculates the array of DocumentChanges for a given ViewSnapshot. */
      function(t5, e2) {
        if (t5._snapshot.oldDocs.isEmpty()) {
          var n2 = 0;
          return t5._snapshot.docChanges.map(function(e3) {
            var r3 = new Ha2(t5._firestore, t5._userDataWriter, e3.doc.key, e3.doc, new Qa2(t5._snapshot.mutatedKeys.has(e3.doc.key), t5._snapshot.fromCache), t5.query._converter);
            return e3.doc, {
              type: "added",
              doc: r3,
              oldIndex: -1,
              newIndex: n2++
            };
          });
        }
        var r2 = t5._snapshot.oldDocs;
        return t5._snapshot.docChanges.filter(function(t6) {
          return e2 || 3 !== t6.type;
        }).map(function(e3) {
          var n3 = new Ha2(t5._firestore, t5._userDataWriter, e3.doc.key, e3.doc, new Qa2(t5._snapshot.mutatedKeys.has(e3.doc.key), t5._snapshot.fromCache), t5.query._converter), i = -1, o = -1;
          return 0 !== e3.type && (i = r2.indexOf(e3.doc.key), r2 = r2.delete(e3.doc.key)), 1 !== e3.type && (o = (r2 = r2.add(e3.doc)).indexOf(e3.doc.key)), {
            type: Ja2(e3.type),
            doc: n3,
            oldIndex: i,
            newIndex: o
          };
        });
      }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
    }, t3;
  }()
);
function Ja2(t3) {
  switch (t3) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return A2();
  }
}
function Xa2(t3, e) {
  return t3 instanceof Wa2 && e instanceof Wa2 ? t3._firestore === e._firestore && t3._key.isEqual(e._key) && (null === t3._document ? null === e._document : t3._document.isEqual(e._document)) && t3._converter === e._converter : t3 instanceof Ya2 && e instanceof Ya2 && t3._firestore === e._firestore && ra2(t3.query, e.query) && t3.metadata.isEqual(e.metadata) && t3._snapshot.isEqual(e._snapshot);
}
function $a2(t3) {
  if (zt(t3) && 0 === t3.explicitOrderBy.length)
    throw new G2(j.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Za2 = function() {
};
function tc(t3) {
  for (var e = [], n2 = 1; n2 < arguments.length; n2++)
    e[n2 - 1] = arguments[n2];
  for (var r2 = 0, i = e; r2 < i.length; r2++) {
    var o = i[r2];
    t3 = o._apply(t3);
  }
  return t3;
}
var ec2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).zc = e2, i.Hc = n2, i.Jc = r2, i.type = "where", i;
    }
    return __extends(e, t3), e.prototype._apply = function(t4) {
      var e2 = Ta2(t4.firestore), n2 = function(t5, e3, n3, r2, i, o, s) {
        var u;
        if (i.isKeyField()) {
          if ("array-contains" === o || "array-contains-any" === o)
            throw new G2(j.INVALID_ARGUMENT, "Invalid Query. You can't perform '" + o + "' queries on FieldPath.documentId().");
          if ("in" === o || "not-in" === o) {
            ac2(s, o);
            for (var a = [], c = 0, h2 = s; c < h2.length; c++) {
              var f = h2[c];
              a.push(uc2(r2, t5, f));
            }
            u = {
              arrayValue: {
                values: a
              }
            };
          } else
            u = uc2(r2, t5, s);
        } else
          "in" !== o && "not-in" !== o && "array-contains-any" !== o || ac2(s, o), u = Ra2(
            n3,
            "where",
            s,
            /* allowArrays= */
            "in" === o || "not-in" === o
          );
        var l = Dt.create(i, o, u);
        return function(t6, e4) {
          if (e4.g()) {
            var n4 = Wt(t6);
            if (null !== n4 && !n4.isEqual(e4.field))
              throw new G2(j.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '" + n4.toString() + "' and '" + e4.field.toString() + "'");
            var r3 = Qt(t6);
            null !== r3 && cc2(t6, e4.field, r3);
          }
          var i2 = function(t7, e5) {
            for (var n5 = 0, r4 = t7.filters; n5 < r4.length; n5++) {
              var i3 = r4[n5];
              if (e5.indexOf(i3.op) >= 0)
                return i3.op;
            }
            return null;
          }(
            t6,
            /**
            * Given an operator, returns the set of operators that cannot be used with it.
            *
            * Operators in a query must adhere to the following set of rules:
            * 1. Only one array operator is allowed.
            * 2. Only one disjunctive operator is allowed.
            * 3. NOT_EQUAL cannot be used with another NOT_EQUAL operator.
            * 4. NOT_IN cannot be used with array, disjunctive, or NOT_EQUAL operators.
            *
            * Array operators: ARRAY_CONTAINS, ARRAY_CONTAINS_ANY
            * Disjunctive operators: IN, ARRAY_CONTAINS_ANY, NOT_IN
            */
            function(t7) {
              switch (t7) {
                case "!=":
                  return [
                    "!=",
                    "not-in"
                    /* NOT_IN */
                  ];
                case "array-contains":
                  return [
                    "array-contains",
                    "array-contains-any",
                    "not-in"
                    /* NOT_IN */
                  ];
                case "in":
                  return [
                    "array-contains-any",
                    "in",
                    "not-in"
                    /* NOT_IN */
                  ];
                case "array-contains-any":
                  return [
                    "array-contains",
                    "array-contains-any",
                    "in",
                    "not-in"
                    /* NOT_IN */
                  ];
                case "not-in":
                  return [
                    "array-contains",
                    "array-contains-any",
                    "in",
                    "not-in",
                    "!="
                    /* NOT_EQUAL */
                  ];
                default:
                  return [];
              }
            }(e4.op)
          );
          if (null !== i2)
            throw i2 === e4.op ? new G2(j.INVALID_ARGUMENT, "Invalid query. You cannot use more than one '" + e4.op.toString() + "' filter.") : new G2(j.INVALID_ARGUMENT, "Invalid query. You cannot use '" + e4.op.toString() + "' filters with '" + i2.toString() + "' filters.");
        }(t5, l), l;
      }(t4._query, 0, e2, t4.firestore._databaseId, this.zc, this.Hc, this.Jc);
      return new $u(t4.firestore, t4._converter, function(t5, e3) {
        var n3 = t5.filters.concat([e3]);
        return new Bt(t5.path, t5.collectionGroup, t5.explicitOrderBy.slice(), n3, t5.limit, t5.limitType, t5.startAt, t5.endAt);
      }(t4._query, n2));
    }, e;
  }(Za2)
);
var nc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this) || this).zc = e2, r2.Yc = n2, r2.type = "orderBy", r2;
    }
    return __extends(e, t3), e.prototype._apply = function(t4) {
      var e2 = function(t5, e3, n2) {
        if (null !== t5.startAt)
          throw new G2(j.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
        if (null !== t5.endAt)
          throw new G2(j.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
        var r2 = new Ft(e3, n2);
        return function(t6, e4) {
          if (null === Qt(t6)) {
            var n3 = Wt(t6);
            null !== n3 && cc2(t6, n3, e4.field);
          }
        }(t5, r2), r2;
      }(t4._query, this.zc, this.Yc);
      return new $u(t4.firestore, t4._converter, function(t5, e3) {
        var n2 = t5.explicitOrderBy.concat([e3]);
        return new Bt(t5.path, t5.collectionGroup, n2, t5.filters.slice(), t5.limit, t5.limitType, t5.startAt, t5.endAt);
      }(t4._query, e2));
    }, e;
  }(Za2)
);
var rc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).type = e2, i.Xc = n2, i.Zc = r2, i;
    }
    return __extends(e, t3), e.prototype._apply = function(t4) {
      return new $u(t4.firestore, t4._converter, Xt(t4._query, this.Xc, this.Zc));
    }, e;
  }(Za2)
);
var ic2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).type = e2, i.ta = n2, i.ea = r2, i;
    }
    return __extends(e, t3), e.prototype._apply = function(t4) {
      var e2 = sc2(t4, this.type, this.ta, this.ea);
      return new $u(t4.firestore, t4._converter, function(t5, e3) {
        return new Bt(t5.path, t5.collectionGroup, t5.explicitOrderBy.slice(), t5.filters.slice(), t5.limit, t5.limitType, e3, t5.endAt);
      }(t4._query, e2));
    }, e;
  }(Za2)
);
var oc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this) || this).type = e2, i.ta = n2, i.ea = r2, i;
    }
    return __extends(e, t3), e.prototype._apply = function(t4) {
      var e2 = sc2(t4, this.type, this.ta, this.ea);
      return new $u(t4.firestore, t4._converter, function(t5, e3) {
        return new Bt(t5.path, t5.collectionGroup, t5.explicitOrderBy.slice(), t5.filters.slice(), t5.limit, t5.limitType, t5.startAt, e3);
      }(t4._query, e2));
    }, e;
  }(Za2)
);
function sc2(t3, e, n2, r2) {
  if (n2[0] instanceof Ju && (n2[0] = n2[0]._delegate), n2[0] instanceof Ga2)
    return function(t4, e2, n3, r3, i2) {
      if (!r3)
        throw new G2(j.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + n3 + "().");
      for (var o = [], s = 0, u = Yt(t4); s < u.length; s++) {
        var a = u[s];
        if (a.field.isKeyField())
          o.push(ft(e2, r3.key));
        else {
          var c = r3.field(a.field);
          if (et(c))
            throw new G2(j.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + a.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (null === c) {
            var h2 = a.field.canonicalString();
            throw new G2(j.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a document for which the field '" + h2 + "' (used as the orderBy) does not exist.");
          }
          o.push(c);
        }
      }
      return new Pt(o, i2);
    }(t3._query, t3.firestore._databaseId, e, n2[0]._document, r2);
  var i = Ta2(t3.firestore);
  return function(t4, e2, n3, r3, i2, o) {
    var s = t4.explicitOrderBy;
    if (i2.length > s.length)
      throw new G2(j.INVALID_ARGUMENT, "Too many arguments provided to " + r3 + "(). The number of arguments must be less than or equal to the number of orderBy() clauses");
    for (var u = [], a = 0; a < i2.length; a++) {
      var c = i2[a];
      if (s[a].field.isKeyField()) {
        if ("string" != typeof c)
          throw new G2(j.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + r3 + "(), but got a " + typeof c);
        if (!Ht(t4) && -1 !== c.indexOf("/"))
          throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to " + r3 + "() must be a plain document ID, but '" + c + "' contains a slash.");
        var h2 = t4.path.child(z2.fromString(c));
        if (!H2.isDocumentKey(h2))
          throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to " + r3 + "() must result in a valid document path, but '" + h2 + "' is not because it contains an odd number of segments.");
        var f = new H2(h2);
        u.push(ft(e2, f));
      } else {
        var l = Ra2(n3, r3, c);
        u.push(l);
      }
    }
    return new Pt(u, o);
  }(t3._query, t3.firestore._databaseId, i, e, n2, r2);
}
function uc2(t3, e, n2) {
  if (n2 instanceof Ju && (n2 = n2._delegate), "string" == typeof n2) {
    if ("" === n2)
      throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Ht(e) && -1 !== n2.indexOf("/"))
      throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '" + n2 + "' contains a '/' character.");
    var r2 = e.path.child(z2.fromString(n2));
    if (!H2.isDocumentKey(r2))
      throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '" + r2 + "' is not because it has an odd number of segments (" + r2.length + ").");
    return ft(t3, new H2(r2));
  }
  if (n2 instanceof Xu)
    return ft(t3, n2._key);
  throw new G2(j.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: " + zu(n2) + ".");
}
function ac2(t3, e) {
  if (!Array.isArray(t3) || 0 === t3.length)
    throw new G2(j.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for '" + e.toString() + "' filters.");
  if (t3.length > 10)
    throw new G2(j.INVALID_ARGUMENT, "Invalid Query. '" + e.toString() + "' filters support a maximum of 10 elements in the value array.");
}
function cc2(t3, e, n2) {
  if (!n2.isEqual(e))
    throw new G2(j.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '" + e.toString() + "' and so you must also use '" + e.toString() + "' as your first argument to orderBy(), but your first orderBy() is on field '" + n2.toString() + "' instead.");
}
var hc2 = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.convertValue = function(t4, e) {
      switch (void 0 === e && (e = "none"), it(t4)) {
        case 0:
          return null;
        case 1:
          return t4.booleanValue;
        case 2:
          return $(t4.integerValue || t4.doubleValue);
        case 3:
          return this.convertTimestamp(t4.timestampValue);
        case 4:
          return this.convertServerTimestamp(t4, e);
        case 5:
          return t4.stringValue;
        case 6:
          return this.convertBytes(Z2(t4.bytesValue));
        case 7:
          return this.convertReference(t4.referenceValue);
        case 8:
          return this.convertGeoPoint(t4.geoPointValue);
        case 9:
          return this.convertArray(t4.arrayValue, e);
        case 10:
          return this.convertObject(t4.mapValue, e);
        default:
          throw A2();
      }
    }, t3.prototype.convertObject = function(t4, e) {
      var n2 = this, r2 = {};
      return F2(t4.fields || {}, function(t5, i) {
        r2[t5] = n2.convertValue(i, e);
      }), r2;
    }, t3.prototype.convertGeoPoint = function(t4) {
      return new va($(t4.latitude), $(t4.longitude));
    }, t3.prototype.convertArray = function(t4, e) {
      var n2 = this;
      return (t4.values || []).map(function(t5) {
        return n2.convertValue(t5, e);
      });
    }, t3.prototype.convertServerTimestamp = function(t4, e) {
      switch (e) {
        case "previous":
          var n2 = nt(t4);
          return null == n2 ? null : this.convertValue(n2, e);
        case "estimate":
          return this.convertTimestamp(rt(t4));
        default:
          return null;
      }
    }, t3.prototype.convertTimestamp = function(t4) {
      var e = X2(t4);
      return new tt(e.seconds, e.nanos);
    }, t3.prototype.convertDocumentKey = function(t4, e) {
      var n2 = z2.fromString(t4);
      k2(Xn(n2));
      var r2 = new Ru(n2.get(1), n2.get(3)), i = new H2(n2.popFirst(5));
      return r2.isEqual(e) || // TODO(b/64130202): Somehow support foreign references.
      S2("Document " + i + " contains a document reference within a different database (" + r2.projectId + "/" + r2.database + ") which is not supported. It will be treated as a reference in the current database (" + e.projectId + "/" + e.database + ") instead."), i;
    }, t3;
  }()
);
function fc2(t3, e, n2) {
  return t3 ? n2 && (n2.merge || n2.mergeFields) ? t3.toFirestore(e, n2) : t3.toFirestore(e) : e;
}
var lc2 = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).firestore = e2, n2;
    }
    return __extends(e, t3), e.prototype.convertBytes = function(t4) {
      return new pa2(t4);
    }, e.prototype.convertReference = function(t4) {
      var e2 = this.convertDocumentKey(t4, this.firestore._databaseId);
      return new Xu(
        this.firestore,
        /* converter= */
        null,
        e2
      );
    }, e;
  }(hc2)
);
var dc2 = (
  /** @class */
  function() {
    function t3(t4, e) {
      this._firestore = t4, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Ta2(t4);
    }
    return t3.prototype.set = function(t4, e, n2) {
      this._verifyNotCommitted();
      var r2 = pc2(t4, this._firestore), i = fc2(r2._converter, e, n2), o = _a3(this._dataReader, "WriteBatch.set", r2._key, i, null !== r2._converter, n2);
      return this._mutations.push(o.toMutation(r2._key, De.none())), this;
    }, t3.prototype.update = function(t4, e, n2) {
      for (var r2 = [], i = 3; i < arguments.length; i++)
        r2[i - 3] = arguments[i];
      this._verifyNotCommitted();
      var o, s = pc2(t4, this._firestore);
      return e instanceof Ju && (e = e._delegate), o = "string" == typeof e || e instanceof da2 ? La2(this._dataReader, "WriteBatch.update", s._key, e, n2, r2) : xa(this._dataReader, "WriteBatch.update", s._key, e), this._mutations.push(o.toMutation(s._key, De.exists(true))), this;
    }, /**
     * Deletes the document referred to by the provided {@link DocumentReference}.
     *
     * @param documentRef - A reference to the document to be deleted.
     * @returns This `WriteBatch` instance. Used for chaining method calls.
     */
    t3.prototype.delete = function(t4) {
      this._verifyNotCommitted();
      var e = pc2(t4, this._firestore);
      return this._mutations = this._mutations.concat(new je(e._key, De.none())), this;
    }, /**
     * Commits all of the writes in this write batch as a single atomic unit.
     *
     * The result of these writes will only be reflected in document reads that
     * occur after the returned Promise resolves. If the client is offline, the
     * write fails. If you would like to see local modifications or buffer writes
     * until the client is online, use the full Firestore SDK.
     *
     * @returns A Promise resolved once all of the writes in the batch have been
     * successfully written to the backend as an atomic unit (note that it won't
     * resolve while you're offline).
     */
    t3.prototype.commit = function() {
      return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
    }, t3.prototype._verifyNotCommitted = function() {
      if (this._committed)
        throw new G2(j.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
    }, t3;
  }()
);
function pc2(t3, e) {
  if (t3 instanceof Ju && (t3 = t3._delegate), t3.firestore !== e)
    throw new G2(j.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t3;
}
var yc2 = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).firestore = e2, n2;
    }
    return __extends(e, t3), e.prototype.convertBytes = function(t4) {
      return new pa2(t4);
    }, e.prototype.convertReference = function(t4) {
      var e2 = this.convertDocumentKey(t4, this.firestore._databaseId);
      return new Xu(
        this.firestore,
        /* converter= */
        null,
        e2
      );
    }, e;
  }(hc2)
);
function vc2(t3, e, n2) {
  for (var r2 = [], i = 3; i < arguments.length; i++)
    r2[i - 3] = arguments[i];
  t3 = Qu(t3, Xu);
  var o = Qu(t3.firestore, aa2), s = Ta2(o);
  return e instanceof Ju && (e = e._delegate), gc2(o, [("string" == typeof e || e instanceof da2 ? La2(s, "updateDoc", t3._key, e, n2, r2) : xa(s, "updateDoc", t3._key, e)).toMutation(t3._key, De.exists(true))]);
}
function mc2(t3) {
  for (var e, n2, r2, i = [], o = 1; o < arguments.length; o++)
    i[o - 1] = arguments[o];
  t3 instanceof Ju && (t3 = t3._delegate);
  var s = {
    includeMetadataChanges: false
  }, u = 0;
  "object" != typeof i[u] || oa2(i[u]) || (s = i[u], u++);
  var a, c, h2, f = {
    includeMetadataChanges: s.includeMetadataChanges
  };
  if (oa2(i[u])) {
    var l = i[u];
    i[u] = null === (e = l.next) || void 0 === e ? void 0 : e.bind(l), i[u + 1] = null === (n2 = l.error) || void 0 === n2 ? void 0 : n2.bind(l), i[u + 2] = null === (r2 = l.complete) || void 0 === r2 ? void 0 : r2.bind(l);
  }
  if (t3 instanceof Xu)
    c = Qu(t3.firestore, aa2), h2 = Gt(t3._key.path), a = {
      next: function(e2) {
        i[u] && i[u](wc2(c, t3, e2));
      },
      error: i[u + 1],
      complete: i[u + 2]
    };
  else {
    var d = Qu(t3, $u);
    c = Qu(d.firestore, aa2), h2 = d._query;
    var p2 = new yc2(c);
    a = {
      next: function(t4) {
        i[u] && i[u](new Ya2(c, p2, d, t4));
      },
      error: i[u + 1],
      complete: i[u + 2]
    }, $a2(t3._query);
  }
  return function(t4, e2, n3, r3) {
    var i2 = this, o2 = new vu(r3), s2 = new Es(e2, o2, n3);
    return t4.asyncQueue.enqueueAndForget(function() {
      return __awaiter(i2, void 0, void 0, function() {
        var e3;
        return __generator(this, function(n4) {
          switch (n4.label) {
            case 0:
              return e3 = ms, [4, ku(t4)];
            case 1:
              return [2, e3.apply(void 0, [n4.sent(), s2])];
          }
        });
      });
    }), function() {
      o2.Xo(), t4.asyncQueue.enqueueAndForget(function() {
        return __awaiter(i2, void 0, void 0, function() {
          var e3;
          return __generator(this, function(n4) {
            switch (n4.label) {
              case 0:
                return e3 = gs, [4, ku(t4)];
              case 1:
                return [2, e3.apply(void 0, [n4.sent(), s2])];
            }
          });
        });
      });
    };
  }(ca2(c), h2, f, a);
}
function gc2(t3, e) {
  return function(t4, e2) {
    var n2 = this, r2 = new Ir();
    return t4.asyncQueue.enqueueAndForget(function() {
      return __awaiter(n2, void 0, void 0, function() {
        var n3;
        return __generator(this, function(i) {
          switch (i.label) {
            case 0:
              return n3 = Ms, [4, Au(t4)];
            case 1:
              return [2, n3.apply(void 0, [i.sent(), e2, r2])];
          }
        });
      });
    }), r2.promise;
  }(ca2(t3), e);
}
function wc2(t3, e, n2) {
  var r2 = n2.docs.get(e._key), i = new yc2(t3);
  return new Wa2(t3, i, e._key, r2, new Qa2(n2.hasPendingWrites, n2.fromCache), e._converter);
}
var bc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2, n2) || this)._firestore = e2, r2;
    }
    return __extends(e, t3), e.prototype.get = function(e2) {
      var n2 = this, r2 = pc2(e2, this._firestore), i = new yc2(this._firestore);
      return t3.prototype.get.call(this, e2).then(function(t4) {
        return new Wa2(n2._firestore, i, r2._key, t4._document, new Qa2(
          /* hasPendingWrites= */
          false,
          /* fromCache= */
          false
        ), r2._converter);
      });
    }, e;
  }(
    /** @class */
    function() {
      function t3(t4, e) {
        this._firestore = t4, this._transaction = e, this._dataReader = Ta2(t4);
      }
      return t3.prototype.get = function(t4) {
        var e = this, n2 = pc2(t4, this._firestore), r2 = new lc2(this._firestore);
        return this._transaction.lookup([n2._key]).then(function(t5) {
          if (!t5 || 1 !== t5.length)
            return A2();
          var i = t5[0];
          if (i instanceof wt)
            return new Ga2(e._firestore, r2, n2._key, null, n2._converter);
          if (i instanceof gt)
            return new Ga2(e._firestore, r2, i.key, i, n2._converter);
          throw A2();
        });
      }, t3.prototype.set = function(t4, e, n2) {
        var r2 = pc2(t4, this._firestore), i = fc2(r2._converter, e, n2), o = _a3(this._dataReader, "Transaction.set", r2._key, i, null !== r2._converter, n2);
        return this._transaction.set(r2._key, o), this;
      }, t3.prototype.update = function(t4, e, n2) {
        for (var r2 = [], i = 3; i < arguments.length; i++)
          r2[i - 3] = arguments[i];
        var o, s = pc2(t4, this._firestore);
        return e instanceof Ju && (e = e._delegate), o = "string" == typeof e || e instanceof da2 ? La2(this._dataReader, "Transaction.update", s._key, e, n2, r2) : xa(this._dataReader, "Transaction.update", s._key, e), this._transaction.update(s._key, o), this;
      }, /**
       * Deletes the document referred to by the provided {@link DocumentReference}.
       *
       * @param documentRef - A reference to the document to be deleted.
       * @returns This `Transaction` instance. Used for chaining method calls.
       */
      t3.prototype.delete = function(t4) {
        var e = pc2(t4, this._firestore);
        return this._transaction.delete(e._key), this;
      }, t3;
    }()
  )
);
function Ic2() {
  if ("undefined" == typeof Uint8Array)
    throw new G2(j.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
}
function Ec2() {
  if ("undefined" == typeof atob)
    throw new G2(j.UNIMPLEMENTED, "Blobs are unavailable in Firestore in this environment.");
}
var Tc2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.fromBase64String = function(t4) {
      return Ec2(), new e(pa2.fromBase64String(t4));
    }, e.fromUint8Array = function(t4) {
      return Ic2(), new e(pa2.fromUint8Array(t4));
    }, e.prototype.toBase64 = function() {
      return Ec2(), this._delegate.toBase64();
    }, e.prototype.toUint8Array = function() {
      return Ic2(), this._delegate.toUint8Array();
    }, e.prototype.isEqual = function(t4) {
      return this._delegate.isEqual(t4._delegate);
    }, e.prototype.toString = function() {
      return "Blob(base64: " + this.toBase64() + ")";
    }, e;
  }(Ju)
);
var _c = (
  /** @class */
  function() {
    function t3() {
    }
    return t3.prototype.enableIndexedDbPersistence = function(t4, e) {
      return function(t5, e2) {
        la(t5 = Qu(t5, aa2));
        var n2 = ca2(t5), r2 = t5._freezeSettings(), i = new pu();
        return fa2(n2, i, new lu(i, r2.cacheSizeBytes, null == e2 ? void 0 : e2.forceOwnership));
      }(t4._delegate, {
        forceOwnership: e
      });
    }, t3.prototype.enableMultiTabIndexedDbPersistence = function(t4) {
      return function(t5) {
        la(t5 = Qu(t5, aa2));
        var e = ca2(t5), n2 = t5._freezeSettings(), r2 = new pu();
        return fa2(e, r2, new du(r2, n2.cacheSizeBytes));
      }(t4._delegate);
    }, t3.prototype.clearIndexedDbPersistence = function(t4) {
      return function(t5) {
        var e = this;
        if (t5._initialized && !t5._terminated)
          throw new G2(j.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
        var n2 = new Ir();
        return t5._queue.enqueueAndForgetEvenWhileRestricted(function() {
          return __awaiter(e, void 0, void 0, function() {
            var e2;
            return __generator(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return r2.trys.push([0, 2, , 3]), [4, function(t6) {
                    return __awaiter(this, void 0, void 0, function() {
                      var e3;
                      return __generator(this, function(n3) {
                        switch (n3.label) {
                          case 0:
                            return _r.At() ? (e3 = t6 + "main", [4, _r.delete(e3)]) : [2, Promise.resolve()];
                          case 1:
                            return n3.sent(), [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  }(Pi(t5._databaseId, t5._persistenceKey))];
                case 1:
                  return r2.sent(), n2.resolve(), [3, 3];
                case 2:
                  return e2 = r2.sent(), n2.reject(e2), [3, 3];
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }), n2.promise;
      }(t4._delegate);
    }, t3;
  }()
);
var Sc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this, n2) || this).na = r2, i.INTERNAL = {
        delete: function() {
          return i.terminate();
        }
      }, e2 instanceof Ru || (i.sa = e2), i;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "_databaseId", {
      get: function() {
        return this._delegate._databaseId;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.settings = function(t4) {
      t4.merge && // Remove the property from the settings once the merge is completed
      delete (t4 = Object.assign(Object.assign({}, this._delegate._getSettings()), t4)).merge, this._delegate._setSettings(t4);
    }, e.prototype.useEmulator = function(t4, e2) {
      !function(t5, e3, n2) {
        var r2 = (t5 = Qu(t5, Yu))._getSettings();
        "firestore.googleapis.com" !== r2.host && r2.host !== e3 && D2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t5._setSettings(Object.assign(Object.assign({}, r2), {
          host: e3 + ":" + n2,
          ssl: false
        }));
      }(this._delegate, t4, e2);
    }, e.prototype.enableNetwork = function() {
      return function(t4) {
        var e2 = this;
        return t4.asyncQueue.enqueue(function() {
          return __awaiter(e2, void 0, void 0, function() {
            var e3, n2;
            return __generator(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, Su(t4)];
                case 1:
                  return e3 = r2.sent(), [4, Nu(t4)];
                case 2:
                  return n2 = r2.sent(), [2, (e3.setNetworkEnabled(true), function(t5) {
                    var e4 = C(t5);
                    return e4.Qr.delete(
                      0
                      /* UserDisabled */
                    ), Vo(e4);
                  }(n2))];
              }
            });
          });
        });
      }(ca2(Qu(this._delegate, aa2)));
    }, e.prototype.disableNetwork = function() {
      return function(t4) {
        var e2 = this;
        return t4.asyncQueue.enqueue(function() {
          return __awaiter(e2, void 0, void 0, function() {
            var e3, n2;
            return __generator(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, Su(t4)];
                case 1:
                  return e3 = r2.sent(), [4, Nu(t4)];
                case 2:
                  return n2 = r2.sent(), [2, (e3.setNetworkEnabled(false), function(t5) {
                    return __awaiter(this, void 0, void 0, function() {
                      var e4;
                      return __generator(this, function(n3) {
                        switch (n3.label) {
                          case 0:
                            return (e4 = C(t5)).Qr.add(
                              0
                              /* UserDisabled */
                            ), [4, Uo(e4)];
                          case 1:
                            return n3.sent(), // Set the OnlineState to Offline so get()s return from cache, etc.
                            e4.jr.set(
                              "Offline"
                              /* Offline */
                            ), [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  }(n2))];
              }
            });
          });
        });
      }(ca2(Qu(this._delegate, aa2)));
    }, e.prototype.enablePersistence = function(t4) {
      var e2 = false, n2 = false;
      return t4 && ju("synchronizeTabs", e2 = !!t4.synchronizeTabs, "experimentalForceOwningTab", n2 = !!t4.experimentalForceOwningTab), e2 ? this.na.enableMultiTabIndexedDbPersistence(this) : this.na.enableIndexedDbPersistence(this, n2);
    }, e.prototype.clearPersistence = function() {
      return this.na.clearIndexedDbPersistence(this);
    }, e.prototype.terminate = function() {
      return this.sa && (this.sa._removeServiceInstance("firestore"), this.sa._removeServiceInstance("firestore-exp")), this._delegate._delete();
    }, e.prototype.waitForPendingWrites = function() {
      return function(t4) {
        var e2 = this, n2 = new Ir();
        return t4.asyncQueue.enqueueAndForget(function() {
          return __awaiter(e2, void 0, void 0, function() {
            var e3;
            return __generator(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return e3 = js, [4, Au(t4)];
                case 1:
                  return [2, e3.apply(void 0, [r2.sent(), n2])];
              }
            });
          });
        }), n2.promise;
      }(ca2(Qu(this._delegate, aa2)));
    }, e.prototype.onSnapshotsInSync = function(t4) {
      return function(t5, e2) {
        return function(t6, e3) {
          var n2 = this, r2 = new vu(e3);
          return t6.asyncQueue.enqueueAndForget(function() {
            return __awaiter(n2, void 0, void 0, function() {
              var e4;
              return __generator(this, function(n3) {
                switch (n3.label) {
                  case 0:
                    return e4 = function(t7, e5) {
                      C(t7).Zr.add(e5), // Immediately fire an initial event, indicating all existing listeners
                      // are in-sync.
                      e5.next();
                    }, [4, ku(t6)];
                  case 1:
                    return [2, e4.apply(void 0, [n3.sent(), r2])];
                }
              });
            });
          }), function() {
            r2.Xo(), t6.asyncQueue.enqueueAndForget(function() {
              return __awaiter(n2, void 0, void 0, function() {
                var e4;
                return __generator(this, function(n3) {
                  switch (n3.label) {
                    case 0:
                      return e4 = function(t7, e5) {
                        C(t7).Zr.delete(e5);
                      }, [4, ku(t6)];
                    case 1:
                      return [2, e4.apply(void 0, [n3.sent(), r2])];
                  }
                });
              });
            });
          };
        }(ca2(t5 = Qu(t5, aa2)), oa2(e2) ? e2 : {
          next: e2
        });
      }(this._delegate, t4);
    }, Object.defineProperty(e.prototype, "app", {
      get: function() {
        if (!this.sa)
          throw new G2(j.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this.sa;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.collection = function(t4) {
      try {
        return new Uc2(this, ta2(this._delegate, t4));
      } catch (t5) {
        throw Lc2(t5, "collection()", "Firestore.collection()");
      }
    }, e.prototype.doc = function(t4) {
      try {
        return new xc(this, ea2(this._delegate, t4));
      } catch (t5) {
        throw Lc2(t5, "doc()", "Firestore.doc()");
      }
    }, e.prototype.collectionGroup = function(t4) {
      try {
        return new Fc2(this, function(t5, e2) {
          if (t5 = Qu(t5, Yu), Uu("collectionGroup", "collection id", e2), e2.indexOf("/") >= 0)
            throw new G2(j.INVALID_ARGUMENT, "Invalid collection ID '" + e2 + "' passed to function collectionGroup(). Collection IDs must not contain '/'.");
          return new $u(
            t5,
            /* converter= */
            null,
            /**
            * Creates a new Query for a collection group query that matches all documents
            * within the provided collection group.
            */
            function(t6) {
              return new Bt(z2.emptyPath(), t6);
            }(e2)
          );
        }(this._delegate, t4));
      } catch (t5) {
        throw Lc2(t5, "collectionGroup()", "Firestore.collectionGroup()");
      }
    }, e.prototype.runTransaction = function(t4) {
      var e2 = this;
      return function(t5, e3) {
        return function(t6, e4) {
          var n2 = this, r2 = new Ir();
          return t6.asyncQueue.enqueueAndForget(function() {
            return __awaiter(n2, void 0, void 0, function() {
              var n3;
              return __generator(this, function(i) {
                switch (i.label) {
                  case 0:
                    return [4, function(t7) {
                      return _u(t7).then(function(t8) {
                        return t8.datastore;
                      });
                    }(t6)];
                  case 1:
                    return n3 = i.sent(), new wu(t6.asyncQueue, n3, e4, r2).run(), [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }), r2.promise;
        }(ca2(t5), function(n2) {
          return e3(new bc2(t5, n2));
        });
      }(this._delegate, function(n2) {
        return t4(new Ac2(e2, n2));
      });
    }, e.prototype.batch = function() {
      var t4 = this;
      return ca2(this._delegate), new kc2(new dc2(this._delegate, function(e2) {
        return gc2(t4._delegate, e2);
      }));
    }, e.prototype.loadBundle = function(t4) {
      throw new G2(j.FAILED_PRECONDITION, '"loadBundle()" does not exist, have you imported "firebase/firestore/bundle"?');
    }, e.prototype.namedQuery = function(t4) {
      throw new G2(j.FAILED_PRECONDITION, '"namedQuery()" does not exist, have you imported "firebase/firestore/bundle"?');
    }, e;
  }(Ju)
);
var Dc2 = (
  /** @class */
  function(t3) {
    function e(e2) {
      var n2 = this;
      return (n2 = t3.call(this) || this).firestore = e2, n2;
    }
    return __extends(e, t3), e.prototype.convertBytes = function(t4) {
      return new Tc2(new pa2(t4));
    }, e.prototype.convertReference = function(t4) {
      var e2 = this.convertDocumentKey(t4, this.firestore._databaseId);
      return xc.ia(
        e2,
        this.firestore,
        /* converter= */
        null
      );
    }, e;
  }(hc2)
);
function Nc2(t3) {
  var e;
  e = t3, E2.setLogLevel(e);
}
var Ac2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this)._firestore = e2, r2._userDataWriter = new Dc2(e2), r2;
    }
    return __extends(e, t3), e.prototype.get = function(t4) {
      var e2 = this, n2 = Bc2(t4);
      return this._delegate.get(n2).then(function(t5) {
        return new Pc2(e2._firestore, new Wa2(e2._firestore._delegate, e2._userDataWriter, t5._key, t5._document, t5.metadata, n2._converter));
      });
    }, e.prototype.set = function(t4, e2, n2) {
      var r2 = Bc2(t4);
      return n2 ? (Bu("Transaction.set", n2), this._delegate.set(r2, e2, n2)) : this._delegate.set(r2, e2), this;
    }, e.prototype.update = function(t4, e2, n2) {
      for (var r2, i = [], o = 3; o < arguments.length; o++)
        i[o - 3] = arguments[o];
      var s = Bc2(t4);
      return 2 === arguments.length ? this._delegate.update(s, e2) : (r2 = this._delegate).update.apply(r2, __spreadArray([s, e2, n2], i)), this;
    }, e.prototype.delete = function(t4) {
      var e2 = Bc2(t4);
      return this._delegate.delete(e2), this;
    }, e;
  }(Ju)
);
var kc2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.set = function(t4, e2, n2) {
      var r2 = Bc2(t4);
      return n2 ? (Bu("WriteBatch.set", n2), this._delegate.set(r2, e2, n2)) : this._delegate.set(r2, e2), this;
    }, e.prototype.update = function(t4, e2, n2) {
      for (var r2, i = [], o = 3; o < arguments.length; o++)
        i[o - 3] = arguments[o];
      var s = Bc2(t4);
      return 2 === arguments.length ? this._delegate.update(s, e2) : (r2 = this._delegate).update.apply(r2, __spreadArray([s, e2, n2], i)), this;
    }, e.prototype.delete = function(t4) {
      var e2 = Bc2(t4);
      return this._delegate.delete(e2), this;
    }, e.prototype.commit = function() {
      return this._delegate.commit();
    }, e;
  }(Ju)
);
var Cc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2, r2) {
      var i = this;
      return (i = t3.call(this, r2) || this)._firestore = e2, i._userDataWriter = n2, i;
    }
    return __extends(e, t3), e.prototype.fromFirestore = function(t4, e2) {
      var n2 = new Ha2(
        this._firestore._delegate,
        this._userDataWriter,
        t4._key,
        t4._document,
        t4.metadata,
        /* converter= */
        null
      );
      return this._delegate.fromFirestore(new Mc2(this._firestore, n2), null != e2 ? e2 : {});
    }, e.prototype.toFirestore = function(t4, e2) {
      return e2 ? this._delegate.toFirestore(t4, e2) : this._delegate.toFirestore(t4);
    }, // Use the same instance of `FirestoreDataConverter` for the given instances
    // of `Firestore` and `PublicFirestoreDataConverter` so that isEqual() will
    // compare equal for two objects created with the same converter instance.
    e.ra = function(t4, n2) {
      var r2 = e.oa, i = r2.get(t4);
      i || (i = /* @__PURE__ */ new WeakMap(), r2.set(t4, i));
      var o = i.get(n2);
      return o || (o = new e(t4, new Dc2(t4), n2), i.set(n2, o)), o;
    }, e;
  }(Ju)
);
Cc2.oa = /* @__PURE__ */ new WeakMap();
var xc = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this).firestore = e2, r2._userDataWriter = new Dc2(e2), r2;
    }
    return __extends(e, t3), e.ca = function(t4, n2, r2) {
      if (t4.length % 2 != 0)
        throw new G2(j.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + t4.canonicalString() + " has " + t4.length);
      return new e(n2, new Xu(n2._delegate, r2, new H2(t4)));
    }, e.ia = function(t4, n2, r2) {
      return new e(n2, new Xu(n2._delegate, r2, t4));
    }, Object.defineProperty(e.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "parent", {
      get: function() {
        return new Uc2(this.firestore, this._delegate.parent);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "path", {
      get: function() {
        return this._delegate.path;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.collection = function(t4) {
      try {
        return new Uc2(this.firestore, ta2(this._delegate, t4));
      } catch (t5) {
        throw Lc2(t5, "collection()", "DocumentReference.collection()");
      }
    }, e.prototype.isEqual = function(t4) {
      return t4 instanceof Ju && (t4 = t4._delegate), t4 instanceof Xu && na2(this._delegate, t4);
    }, e.prototype.set = function(t4, e2) {
      e2 = Bu("DocumentReference.set", e2);
      try {
        return function(t5, e3, n2) {
          t5 = Qu(t5, Xu);
          var r2 = Qu(t5.firestore, aa2), i = fc2(t5._converter, e3, n2);
          return gc2(r2, [_a3(Ta2(r2), "setDoc", t5._key, i, null !== t5._converter, n2).toMutation(t5._key, De.none())]);
        }(this._delegate, t4, e2);
      } catch (t5) {
        throw Lc2(t5, "setDoc()", "DocumentReference.set()");
      }
    }, e.prototype.update = function(t4, e2) {
      for (var n2 = [], r2 = 2; r2 < arguments.length; r2++)
        n2[r2 - 2] = arguments[r2];
      try {
        return 1 === arguments.length ? vc2(this._delegate, t4) : vc2.apply(void 0, __spreadArray([this._delegate, t4, e2], n2));
      } catch (t5) {
        throw Lc2(t5, "updateDoc()", "DocumentReference.update()");
      }
    }, e.prototype.delete = function() {
      return gc2(Qu((t4 = this._delegate).firestore, aa2), [new je(t4._key, De.none())]);
      var t4;
    }, e.prototype.onSnapshot = function() {
      for (var t4 = this, e2 = [], n2 = 0; n2 < arguments.length; n2++)
        e2[n2] = arguments[n2];
      var r2 = Rc2(e2), i = Oc2(e2, function(e3) {
        return new Pc2(t4.firestore, new Wa2(t4.firestore._delegate, t4._userDataWriter, e3._key, e3._document, e3.metadata, t4._delegate._converter));
      });
      return mc2(this._delegate, r2, i);
    }, e.prototype.get = function(t4) {
      var e2 = this;
      return ("cache" === (null == t4 ? void 0 : t4.source) ? function(t5) {
        t5 = Qu(t5, Xu);
        var e3 = Qu(t5.firestore, aa2), n2 = ca2(e3), r2 = new yc2(e3);
        return function(t6, e4) {
          var n3 = this, r3 = new Ir();
          return t6.asyncQueue.enqueueAndForget(function() {
            return __awaiter(n3, void 0, void 0, function() {
              var n4;
              return __generator(this, function(i) {
                switch (i.label) {
                  case 0:
                    return n4 = function(t7, e5, n5) {
                      return __awaiter(this, void 0, void 0, function() {
                        var r4, i2;
                        return __generator(this, function(o) {
                          switch (o.label) {
                            case 0:
                              return o.trys.push([0, 2, , 3]), [4, function(t8, e6) {
                                var n6 = C(t8);
                                return n6.persistence.runTransaction("read document", "readonly", function(t9) {
                                  return n6.Kn.In(t9, e6);
                                });
                              }(t7, e5)];
                            case 1:
                              return (i2 = o.sent()) instanceof gt ? n5.resolve(i2) : i2 instanceof wt ? n5.resolve(null) : n5.reject(new G2(j.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")), [3, 3];
                            case 2:
                              return r4 = o.sent(), i2 = fs(r4, "Failed to get document '" + e5 + " from cache"), n5.reject(i2), [3, 3];
                            case 3:
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    }, [4, Du(t6)];
                  case 1:
                    return [2, n4.apply(void 0, [i.sent(), e4, r3])];
                }
              });
            });
          }), r3.promise;
        }(n2, t5._key).then(function(n3) {
          return new Wa2(e3, r2, t5._key, n3, new Qa2(
            n3 instanceof gt && n3.hasLocalMutations,
            /* fromCache= */
            true
          ), t5._converter);
        });
      }(this._delegate) : "server" === (null == t4 ? void 0 : t4.source) ? function(t5) {
        t5 = Qu(t5, Xu);
        var e3 = Qu(t5.firestore, aa2);
        return Cu(ca2(e3), t5._key, {
          source: "server"
        }).then(function(n2) {
          return wc2(e3, t5, n2);
        });
      }(this._delegate) : function(t5) {
        t5 = Qu(t5, Xu);
        var e3 = Qu(t5.firestore, aa2);
        return Cu(ca2(e3), t5._key).then(function(n2) {
          return wc2(e3, t5, n2);
        });
      }(this._delegate)).then(function(t5) {
        return new Pc2(e2.firestore, new Wa2(e2.firestore._delegate, e2._userDataWriter, t5._key, t5._document, t5.metadata, e2._delegate._converter));
      });
    }, e.prototype.withConverter = function(t4) {
      return new e(this.firestore, t4 ? this._delegate.withConverter(Cc2.ra(this.firestore, t4)) : this._delegate.withConverter(null));
    }, e;
  }(Ju)
);
function Lc2(t3, e, n2) {
  return t3.message = t3.message.replace(e, n2), t3;
}
function Rc2(t3) {
  for (var e = 0, n2 = t3; e < n2.length; e++) {
    var r2 = n2[e];
    if ("object" == typeof r2 && !oa2(r2))
      return r2;
  }
  return {};
}
function Oc2(t3, e) {
  var n2, r2, i;
  return {
    next: function(t4) {
      i.next && i.next(e(t4));
    },
    error: null === (n2 = (i = oa2(t3[0]) ? t3[0] : oa2(t3[1]) ? t3[1] : "function" == typeof t3[0] ? {
      next: t3[0],
      error: t3[1],
      complete: t3[2]
    } : {
      next: t3[1],
      error: t3[2],
      complete: t3[3]
    }).error) || void 0 === n2 ? void 0 : n2.bind(i),
    complete: null === (r2 = i.complete) || void 0 === r2 ? void 0 : r2.bind(i)
  };
}
var Pc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this)._firestore = e2, r2;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "ref", {
      get: function() {
        return new xc(this._firestore, this._delegate.ref);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "exists", {
      get: function() {
        return this._delegate.exists();
      },
      enumerable: false,
      configurable: true
    }), e.prototype.data = function(t4) {
      return this._delegate.data(t4);
    }, e.prototype.get = function(t4, e2) {
      return this._delegate.get(t4, e2);
    }, e.prototype.isEqual = function(t4) {
      return Xa2(this._delegate, t4._delegate);
    }, e;
  }(Ju)
);
var Mc2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.prototype.data = function(t4) {
      return this._delegate.data(t4);
    }, e;
  }(Pc2)
);
var Fc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this).firestore = e2, r2._userDataWriter = new Dc2(e2), r2;
    }
    return __extends(e, t3), e.prototype.where = function(t4, n2, r2) {
      try {
        return new e(this.firestore, tc(this._delegate, function(t5, e2, n3) {
          var r3 = e2, i = za2("where", t5);
          return new ec2(i, r3, n3);
        }(t4, n2, r2)));
      } catch (t5) {
        throw Lc2(t5, /(orderBy|where)\(\)/, "Query.$1()");
      }
    }, e.prototype.orderBy = function(t4, n2) {
      try {
        return new e(this.firestore, tc(this._delegate, function(t5, e2) {
          void 0 === e2 && (e2 = "asc");
          var n3 = e2, r2 = za2("orderBy", t5);
          return new nc2(r2, n3);
        }(t4, n2)));
      } catch (t5) {
        throw Lc2(t5, /(orderBy|where)\(\)/, "Query.$1()");
      }
    }, e.prototype.limit = function(t4) {
      try {
        return new e(this.firestore, tc(this._delegate, function(t5) {
          return Wu("limit", t5), new rc2(
            "limit",
            t5,
            "F"
            /* First */
          );
        }(t4)));
      } catch (t5) {
        throw Lc2(t5, "limit()", "Query.limit()");
      }
    }, e.prototype.limitToLast = function(t4) {
      try {
        return new e(this.firestore, tc(this._delegate, function(t5) {
          return Wu("limitToLast", t5), new rc2(
            "limitToLast",
            t5,
            "L"
            /* Last */
          );
        }(t4)));
      } catch (t5) {
        throw Lc2(t5, "limitToLast()", "Query.limitToLast()");
      }
    }, e.prototype.startAt = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      try {
        return new e(this.firestore, tc(this._delegate, (function() {
          for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
            t5[e2] = arguments[e2];
          return new ic2(
            "startAt",
            t5,
            /*before=*/
            true
          );
        }).apply(void 0, t4)));
      } catch (t5) {
        throw Lc2(t5, "startAt()", "Query.startAt()");
      }
    }, e.prototype.startAfter = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      try {
        return new e(this.firestore, tc(this._delegate, (function() {
          for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
            t5[e2] = arguments[e2];
          return new ic2(
            "startAfter",
            t5,
            /*before=*/
            false
          );
        }).apply(void 0, t4)));
      } catch (t5) {
        throw Lc2(t5, "startAfter()", "Query.startAfter()");
      }
    }, e.prototype.endBefore = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      try {
        return new e(this.firestore, tc(this._delegate, (function() {
          for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
            t5[e2] = arguments[e2];
          return new oc2(
            "endBefore",
            t5,
            /*before=*/
            true
          );
        }).apply(void 0, t4)));
      } catch (t5) {
        throw Lc2(t5, "endBefore()", "Query.endBefore()");
      }
    }, e.prototype.endAt = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      try {
        return new e(this.firestore, tc(this._delegate, (function() {
          for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
            t5[e2] = arguments[e2];
          return new oc2(
            "endAt",
            t5,
            /*before=*/
            false
          );
        }).apply(void 0, t4)));
      } catch (t5) {
        throw Lc2(t5, "endAt()", "Query.endAt()");
      }
    }, e.prototype.isEqual = function(t4) {
      return ra2(this._delegate, t4._delegate);
    }, e.prototype.get = function(t4) {
      var e2 = this;
      return ("cache" === (null == t4 ? void 0 : t4.source) ? (
        /**
        * Executes the query and returns the results as a `QuerySnapshot` from cache.
        * Returns an error if the document is not currently cached.
        *
        * @returns A Promise that will be resolved with the results of the query.
        */
        function(t5) {
          t5 = Qu(t5, $u);
          var e3 = Qu(t5.firestore, aa2), n2 = ca2(e3), r2 = new yc2(e3);
          return function(t6, e4) {
            var n3 = this, r3 = new Ir();
            return t6.asyncQueue.enqueueAndForget(function() {
              return __awaiter(n3, void 0, void 0, function() {
                var n4;
                return __generator(this, function(i) {
                  switch (i.label) {
                    case 0:
                      return n4 = function(t7, e5, n5) {
                        return __awaiter(this, void 0, void 0, function() {
                          var r4, i2, o, s, u;
                          return __generator(this, function(a) {
                            switch (a.label) {
                              case 0:
                                return a.trys.push([0, 2, , 3]), [4, Ji(
                                  t7,
                                  e5,
                                  /* usePreviousResults= */
                                  true
                                )];
                              case 1:
                                return u = a.sent(), r4 = new ks(e5, u.jn), i2 = r4.Io(u.documents), o = r4.applyChanges(
                                  i2,
                                  /* updateLimboDocuments= */
                                  false
                                ), n5.resolve(o.snapshot), [3, 3];
                              case 2:
                                return s = a.sent(), u = fs(s, "Failed to execute query '" + e5 + " against cache"), n5.reject(u), [3, 3];
                              case 3:
                                return [
                                  2
                                  /*return*/
                                ];
                            }
                          });
                        });
                      }, [4, Du(t6)];
                    case 1:
                      return [2, n4.apply(void 0, [i.sent(), e4, r3])];
                  }
                });
              });
            }), r3.promise;
          }(n2, t5._query).then(function(n3) {
            return new Ya2(e3, r2, t5, n3);
          });
        }(this._delegate)
      ) : "server" === (null == t4 ? void 0 : t4.source) ? function(t5) {
        t5 = Qu(t5, $u);
        var e3 = Qu(t5.firestore, aa2), n2 = ca2(e3), r2 = new yc2(e3);
        return xu(n2, t5._query, {
          source: "server"
        }).then(function(n3) {
          return new Ya2(e3, r2, t5, n3);
        });
      }(this._delegate) : function(t5) {
        t5 = Qu(t5, $u);
        var e3 = Qu(t5.firestore, aa2), n2 = ca2(e3), r2 = new yc2(e3);
        return $a2(t5._query), xu(n2, t5._query).then(function(n3) {
          return new Ya2(e3, r2, t5, n3);
        });
      }(this._delegate)).then(function(t5) {
        return new Vc2(e2.firestore, new Ya2(e2.firestore._delegate, e2._userDataWriter, e2._delegate, t5._snapshot));
      });
    }, e.prototype.onSnapshot = function() {
      for (var t4 = this, e2 = [], n2 = 0; n2 < arguments.length; n2++)
        e2[n2] = arguments[n2];
      var r2 = Rc2(e2), i = Oc2(e2, function(e3) {
        return new Vc2(t4.firestore, new Ya2(t4.firestore._delegate, t4._userDataWriter, t4._delegate, e3._snapshot));
      });
      return mc2(this._delegate, r2, i);
    }, e.prototype.withConverter = function(t4) {
      return new e(this.firestore, t4 ? this._delegate.withConverter(Cc2.ra(this.firestore, t4)) : this._delegate.withConverter(null));
    }, e;
  }(Ju)
);
var qc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this)._firestore = e2, r2;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "type", {
      get: function() {
        return this._delegate.type;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "doc", {
      get: function() {
        return new Mc2(this._firestore, this._delegate.doc);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "oldIndex", {
      get: function() {
        return this._delegate.oldIndex;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "newIndex", {
      get: function() {
        return this._delegate.newIndex;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(Ju)
);
var Vc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, n2) || this)._firestore = e2, r2;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "query", {
      get: function() {
        return new Fc2(this._firestore, this._delegate.query);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "size", {
      get: function() {
        return this._delegate.size;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "empty", {
      get: function() {
        return this._delegate.empty;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "docs", {
      get: function() {
        var t4 = this;
        return this._delegate.docs.map(function(e2) {
          return new Mc2(t4._firestore, e2);
        });
      },
      enumerable: false,
      configurable: true
    }), e.prototype.docChanges = function(t4) {
      var e2 = this;
      return this._delegate.docChanges(t4).map(function(t5) {
        return new qc2(e2._firestore, t5);
      });
    }, e.prototype.forEach = function(t4, e2) {
      var n2 = this;
      this._delegate.forEach(function(r2) {
        t4.call(e2, new Mc2(n2._firestore, r2));
      });
    }, e.prototype.isEqual = function(t4) {
      return Xa2(this._delegate, t4._delegate);
    }, e;
  }(Ju)
);
var Uc2 = (
  /** @class */
  function(t3) {
    function e(e2, n2) {
      var r2 = this;
      return (r2 = t3.call(this, e2, n2) || this).firestore = e2, r2._delegate = n2, r2;
    }
    return __extends(e, t3), Object.defineProperty(e.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "path", {
      get: function() {
        return this._delegate.path;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "parent", {
      get: function() {
        var t4 = this._delegate.parent;
        return t4 ? new xc(this.firestore, t4) : null;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.doc = function(t4) {
      try {
        return new xc(this.firestore, void 0 === t4 ? ea2(this._delegate) : ea2(this._delegate, t4));
      } catch (t5) {
        throw Lc2(t5, "doc()", "CollectionReference.doc()");
      }
    }, e.prototype.add = function(t4) {
      var e2 = this;
      return function(t5, e3) {
        var n2 = Qu(t5.firestore, aa2), r2 = ea2(t5), i = fc2(t5._converter, e3);
        return gc2(n2, [_a3(Ta2(t5.firestore), "addDoc", r2._key, i, null !== t5._converter, {}).toMutation(r2._key, De.exists(false))]).then(function() {
          return r2;
        });
      }(this._delegate, t4).then(function(t5) {
        return new xc(e2.firestore, t5);
      });
    }, e.prototype.isEqual = function(t4) {
      return na2(this._delegate, t4._delegate);
    }, e.prototype.withConverter = function(t4) {
      return new e(this.firestore, t4 ? this._delegate.withConverter(Cc2.ra(this.firestore, t4)) : this._delegate.withConverter(null));
    }, e;
  }(Fc2)
);
function Bc2(t3) {
  return t3 instanceof Ju && (t3 = t3._delegate), Qu(t3, Xu);
}
var jc2 = (
  /** @class */
  function(t3) {
    function e() {
      for (var e2 = [], n2 = 0; n2 < arguments.length; n2++)
        e2[n2] = arguments[n2];
      return t3.call(this, new (da2.bind.apply(da2, __spreadArray([void 0], e2)))()) || this;
    }
    return __extends(e, t3), e.documentId = function() {
      return new e(W2.keyField().canonicalString());
    }, e.prototype.isEqual = function(t4) {
      return t4 instanceof Ju && (t4 = t4._delegate), t4 instanceof da2 && this._delegate._internalPath.isEqual(t4._internalPath);
    }, e;
  }(Ju)
);
var Gc2 = (
  /** @class */
  function(t3) {
    function e() {
      return null !== t3 && t3.apply(this, arguments) || this;
    }
    return __extends(e, t3), e.serverTimestamp = function() {
      var t4 = new Na("serverTimestamp");
      return t4._methodName = "FieldValue.serverTimestamp", new e(t4);
    }, e.delete = function() {
      var t4 = new Sa("deleteField");
      return t4._methodName = "FieldValue.delete", new e(t4);
    }, e.arrayUnion = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      var r2 = (
        /**
        * Returns a special value that can be used with {@link setDoc} or {@link
        * updateDoc} that tells the server to union the given elements with any array
        * value that already exists on the server. Each specified element that doesn't
        * already exist in the array will be added to the end. If the field being
        * modified is not already an array it will be overwritten with an array
        * containing exactly the specified elements.
        *
        * @param elements - The elements to union into the array.
        * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or
        * `updateDoc()`.
        */
        (function() {
          for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
            t5[e2] = arguments[e2];
          return new Aa2("arrayUnion", t5);
        }).apply(void 0, t4)
      );
      return r2._methodName = "FieldValue.arrayUnion", new e(r2);
    }, e.arrayRemove = function() {
      for (var t4 = [], n2 = 0; n2 < arguments.length; n2++)
        t4[n2] = arguments[n2];
      var r2 = (function() {
        for (var t5 = [], e2 = 0; e2 < arguments.length; e2++)
          t5[e2] = arguments[e2];
        return new ka2("arrayRemove", t5);
      }).apply(void 0, t4);
      return r2._methodName = "FieldValue.arrayRemove", new e(r2);
    }, e.increment = function(t4) {
      var n2 = function(t5) {
        return new Ca2("increment", t5);
      }(t4);
      return n2._methodName = "FieldValue.increment", new e(n2);
    }, e.prototype.isEqual = function(t4) {
      return this._delegate.isEqual(t4._delegate);
    }, e;
  }(Ju)
);
function Kc2(t3) {
  return function(t4, e) {
    var n2 = ca2(t4 = Qu(t4, aa2)), r2 = new sa2();
    return function(t5, e2, n3, r3) {
      var i = this, o = function(t6, e3) {
        return function(t7, e4) {
          return new mu(t7, e4);
        }(function(t7, e4) {
          if (t7 instanceof Uint8Array)
            return yu(t7, e4);
          if (t7 instanceof ArrayBuffer)
            return yu(new Uint8Array(t7), e4);
          if (t7 instanceof ReadableStream)
            return t7.getReader();
          throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
        }("string" == typeof t6 ? new TextEncoder().encode(t6) : t6), e3);
      }(n3, xo(e2));
      t5.asyncQueue.enqueueAndForget(function() {
        return __awaiter(i, void 0, void 0, function() {
          var e3;
          return __generator(this, function(n4) {
            switch (n4.label) {
              case 0:
                return e3 = hu, [4, Au(t5)];
              case 1:
                return e3.apply(void 0, [n4.sent(), o, r3]), [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    }(n2, t4._databaseId, e, r2), r2;
  }(this._delegate, t3);
}
function zc2(t3) {
  var e, n2, r2 = this;
  return (e = this._delegate, n2 = t3, function(t4, e2) {
    var n3 = this;
    return t4.asyncQueue.enqueue(function() {
      return __awaiter(n3, void 0, void 0, function() {
        var n4;
        return __generator(this, function(r3) {
          switch (r3.label) {
            case 0:
              return n4 = function(t5, e3) {
                var n5 = C(t5);
                return n5.persistence.runTransaction("Get named query", "readonly", function(t6) {
                  return n5.He.getNamedQuery(t6, e3);
                });
              }, [4, Du(t4)];
            case 1:
              return [2, n4.apply(void 0, [r3.sent(), e2])];
          }
        });
      });
    });
  }(ca2(e = Qu(e, aa2)), n2).then(function(t4) {
    return t4 ? new $u(e, null, t4.query) : null;
  })).then(function(t4) {
    return t4 ? new Fc2(r2, t4) : null;
  });
}

// node_modules/@firebase/firestore/dist/esm5/index.js
var L3 = {
  Firestore: Sc2,
  GeoPoint: va,
  Timestamp: tt,
  Blob: Tc2,
  Transaction: Ac2,
  WriteBatch: kc2,
  DocumentReference: xc,
  DocumentSnapshot: Pc2,
  Query: Fc2,
  QueryDocumentSnapshot: Mc2,
  QuerySnapshot: Vc2,
  CollectionReference: Uc2,
  FieldPath: jc2,
  FieldValue: Gc2,
  setLogLevel: Nc2,
  CACHE_SIZE_UNLIMITED: ua2
};
function P3(e) {
  !/**
  * Configures Firestore as part of the Firebase SDK by calling registerService.
  *
  * @param firebase - The FirebaseNamespace to register Firestore with
  * @param firestoreFactory - A factory function that returns a new Firestore
  *    instance.
  */
  function(e2, r2) {
    e2.INTERNAL.registerComponent(new Component(
      "firestore",
      function(e3) {
        var t3 = e3.getProvider("app").getImmediate();
        return r2(t3, e3.getProvider("auth-internal"));
      },
      "PUBLIC"
      /* PUBLIC */
    ).setServiceProps(Object.assign({}, L3)));
  }(e, function(e2, s) {
    return new Sc2(e2, new aa2(e2, s), new _c());
  }), e.registerVersion("@firebase/firestore", "2.2.1");
}
P3(index_esm_default);

// node_modules/@firebase/firestore/dist/esm5/bundle.js
function t2(o) {
  o.prototype.loadBundle = Kc2, o.prototype.namedQuery = zc2;
}
t2(Sc2);

// node_modules/@firebase/functions/dist/index.esm.js
var errorCodeMap = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var HttpsErrorImpl = (
  /** @class */
  function(_super) {
    __extends(HttpsErrorImpl2, _super);
    function HttpsErrorImpl2(code, message, details) {
      var _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, HttpsErrorImpl2.prototype);
      _this.code = code;
      _this.details = details;
      return _this;
    }
    return HttpsErrorImpl2;
  }(Error)
);
function codeForHTTPStatus(status) {
  if (status >= 200 && status < 300) {
    return "ok";
  }
  switch (status) {
    case 0:
      return "internal";
    case 400:
      return "invalid-argument";
    case 401:
      return "unauthenticated";
    case 403:
      return "permission-denied";
    case 404:
      return "not-found";
    case 409:
      return "aborted";
    case 429:
      return "resource-exhausted";
    case 499:
      return "cancelled";
    case 500:
      return "internal";
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline-exceeded";
  }
  return "unknown";
}
function _errorForResponse(status, bodyJSON, serializer2) {
  var code = codeForHTTPStatus(status);
  var description = code;
  var details = void 0;
  try {
    var errorJSON = bodyJSON && bodyJSON.error;
    if (errorJSON) {
      var status_1 = errorJSON.status;
      if (typeof status_1 === "string") {
        if (!errorCodeMap[status_1]) {
          return new HttpsErrorImpl("internal", "internal");
        }
        code = errorCodeMap[status_1];
        description = status_1;
      }
      var message = errorJSON.message;
      if (typeof message === "string") {
        description = message;
      }
      details = errorJSON.details;
      if (details !== void 0) {
        details = serializer2.decode(details);
      }
    }
  } catch (e) {
  }
  if (code === "ok") {
    return null;
  }
  return new HttpsErrorImpl(code, description, details);
}
var ContextProvider = (
  /** @class */
  function() {
    function ContextProvider2(authProvider, messagingProvider) {
      var _this = this;
      this.auth = null;
      this.messaging = null;
      this.auth = authProvider.getImmediate({ optional: true });
      this.messaging = messagingProvider.getImmediate({
        optional: true
      });
      if (!this.auth) {
        authProvider.get().then(function(auth) {
          return _this.auth = auth;
        }, function() {
        });
      }
      if (!this.messaging) {
        messagingProvider.get().then(function(messaging) {
          return _this.messaging = messaging;
        }, function() {
        });
      }
    }
    ContextProvider2.prototype.getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var token, e_1;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              if (!this.auth) {
                return [2, void 0];
              }
              _a9.label = 1;
            case 1:
              _a9.trys.push([1, 3, , 4]);
              return [4, this.auth.getToken()];
            case 2:
              token = _a9.sent();
              if (!token) {
                return [2, void 0];
              }
              return [2, token.accessToken];
            case 3:
              e_1 = _a9.sent();
              return [2, void 0];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    ContextProvider2.prototype.getInstanceIdToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
            return [2, void 0];
          }
          try {
            return [2, this.messaging.getToken()];
          } catch (e) {
            return [2, void 0];
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    ContextProvider2.prototype.getContext = function() {
      return __awaiter(this, void 0, void 0, function() {
        var authToken, instanceIdToken;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.getAuthToken()];
            case 1:
              authToken = _a9.sent();
              return [4, this.getInstanceIdToken()];
            case 2:
              instanceIdToken = _a9.sent();
              return [2, { authToken, instanceIdToken }];
          }
        });
      });
    };
    return ContextProvider2;
  }()
);
var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
function mapValues(o, f) {
  var result = {};
  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      result[key] = f(o[key]);
    }
  }
  return result;
}
var Serializer = (
  /** @class */
  function() {
    function Serializer2() {
    }
    Serializer2.prototype.encode = function(data) {
      var _this = this;
      if (data == null) {
        return null;
      }
      if (data instanceof Number) {
        data = data.valueOf();
      }
      if (typeof data === "number" && isFinite(data)) {
        return data;
      }
      if (data === true || data === false) {
        return data;
      }
      if (Object.prototype.toString.call(data) === "[object String]") {
        return data;
      }
      if (Array.isArray(data)) {
        return data.map(function(x3) {
          return _this.encode(x3);
        });
      }
      if (typeof data === "function" || typeof data === "object") {
        return mapValues(data, function(x3) {
          return _this.encode(x3);
        });
      }
      throw new Error("Data cannot be encoded in JSON: " + data);
    };
    Serializer2.prototype.decode = function(json) {
      var _this = this;
      if (json == null) {
        return json;
      }
      if (json["@type"]) {
        switch (json["@type"]) {
          case LONG_TYPE:
          case UNSIGNED_LONG_TYPE: {
            var value = Number(json["value"]);
            if (isNaN(value)) {
              throw new Error("Data cannot be decoded from JSON: " + json);
            }
            return value;
          }
          default: {
            throw new Error("Data cannot be decoded from JSON: " + json);
          }
        }
      }
      if (Array.isArray(json)) {
        return json.map(function(x3) {
          return _this.decode(x3);
        });
      }
      if (typeof json === "function" || typeof json === "object") {
        return mapValues(json, function(x3) {
          return _this.decode(x3);
        });
      }
      return json;
    };
    return Serializer2;
  }()
);
function failAfter(millis) {
  var timer;
  var promise = new Promise(function(_2, reject) {
    timer = setTimeout(function() {
      reject(new HttpsErrorImpl("deadline-exceeded", "deadline-exceeded"));
    }, millis);
  });
  return {
    timer,
    promise
  };
}
var Service = (
  /** @class */
  function() {
    function Service2(app_, authProvider, messagingProvider, regionOrCustomDomain_, fetchImpl) {
      var _this = this;
      if (regionOrCustomDomain_ === void 0) {
        regionOrCustomDomain_ = "us-central1";
      }
      this.app_ = app_;
      this.fetchImpl = fetchImpl;
      this.serializer = new Serializer();
      this.emulatorOrigin = null;
      this.INTERNAL = {
        delete: function() {
          return Promise.resolve(_this.deleteService());
        }
      };
      this.contextProvider = new ContextProvider(authProvider, messagingProvider);
      this.cancelAllRequests = new Promise(function(resolve) {
        _this.deleteService = function() {
          return resolve();
        };
      });
      try {
        var url = new URL(regionOrCustomDomain_);
        this.customDomain = url.origin;
        this.region = "us-central1";
      } catch (e) {
        this.customDomain = null;
        this.region = regionOrCustomDomain_;
      }
    }
    Object.defineProperty(Service2.prototype, "app", {
      get: function() {
        return this.app_;
      },
      enumerable: false,
      configurable: true
    });
    Service2.prototype._url = function(name10) {
      var projectId = this.app_.options.projectId;
      if (this.emulatorOrigin !== null) {
        var origin_1 = this.emulatorOrigin;
        return origin_1 + "/" + projectId + "/" + this.region + "/" + name10;
      }
      if (this.customDomain !== null) {
        return this.customDomain + "/" + name10;
      }
      return "https://" + this.region + "-" + projectId + ".cloudfunctions.net/" + name10;
    };
    Service2.prototype.useEmulator = function(host, port) {
      this.emulatorOrigin = "http://" + host + ":" + port;
    };
    Service2.prototype.useFunctionsEmulator = function(origin) {
      this.emulatorOrigin = origin;
    };
    Service2.prototype.httpsCallable = function(name10, options) {
      var _this = this;
      return function(data) {
        return _this.call(name10, data, options || {});
      };
    };
    Service2.prototype.postJSON = function(url, body, headers) {
      return __awaiter(this, void 0, void 0, function() {
        var response, e_1, json, e_2;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              headers["Content-Type"] = "application/json";
              _a9.label = 1;
            case 1:
              _a9.trys.push([1, 3, , 4]);
              return [4, this.fetchImpl(url, {
                method: "POST",
                body: JSON.stringify(body),
                headers
              })];
            case 2:
              response = _a9.sent();
              return [3, 4];
            case 3:
              e_1 = _a9.sent();
              return [2, {
                status: 0,
                json: null
              }];
            case 4:
              json = null;
              _a9.label = 5;
            case 5:
              _a9.trys.push([5, 7, , 8]);
              return [4, response.json()];
            case 6:
              json = _a9.sent();
              return [3, 8];
            case 7:
              e_2 = _a9.sent();
              return [3, 8];
            case 8:
              return [2, {
                status: response.status,
                json
              }];
          }
        });
      });
    };
    Service2.prototype.call = function(name10, data, options) {
      return __awaiter(this, void 0, void 0, function() {
        var url, body, headers, context, timeout, _a9, timer, failAfterPromise, response, error2, responseData, decodedData;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              url = this._url(name10);
              data = this.serializer.encode(data);
              body = { data };
              headers = {};
              return [4, this.contextProvider.getContext()];
            case 1:
              context = _b.sent();
              if (context.authToken) {
                headers["Authorization"] = "Bearer " + context.authToken;
              }
              if (context.instanceIdToken) {
                headers["Firebase-Instance-ID-Token"] = context.instanceIdToken;
              }
              timeout = options.timeout || 7e4;
              _a9 = failAfter(timeout), timer = _a9.timer, failAfterPromise = _a9.promise;
              return [4, Promise.race([
                clearTimeoutWrapper(timer, this.postJSON(url, body, headers)),
                failAfterPromise,
                clearTimeoutWrapper(timer, this.cancelAllRequests)
              ])];
            case 2:
              response = _b.sent();
              if (!response) {
                throw new HttpsErrorImpl("cancelled", "Firebase Functions instance was deleted.");
              }
              error2 = _errorForResponse(response.status, response.json, this.serializer);
              if (error2) {
                throw error2;
              }
              if (!response.json) {
                throw new HttpsErrorImpl("internal", "Response is not valid JSON object.");
              }
              responseData = response.json.data;
              if (typeof responseData === "undefined") {
                responseData = response.json.result;
              }
              if (typeof responseData === "undefined") {
                throw new HttpsErrorImpl("internal", "Response is missing data field.");
              }
              decodedData = this.serializer.decode(responseData);
              return [2, { data: decodedData }];
          }
        });
      });
    };
    return Service2;
  }()
);
function clearTimeoutWrapper(timer, promise) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, promise];
        case 1:
          result = _a9.sent();
          clearTimeout(timer);
          return [2, result];
      }
    });
  });
}
var FUNCTIONS_TYPE = "functions";
function registerFunctions(instance, fetchImpl) {
  var namespaceExports = {
    // no-inline
    Functions: Service
  };
  function factory3(container, _a9) {
    var regionOrCustomDomain = _a9.instanceIdentifier;
    var app = container.getProvider("app").getImmediate();
    var authProvider = container.getProvider("auth-internal");
    var messagingProvider = container.getProvider("messaging");
    return new Service(app, authProvider, messagingProvider, regionOrCustomDomain, fetchImpl);
  }
  instance.INTERNAL.registerComponent(new Component(
    FUNCTIONS_TYPE,
    factory3,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
}
var name3 = "@firebase/functions";
var version3 = "0.6.4";
registerFunctions(index_esm_default, fetch.bind(self));
index_esm_default.registerVersion(name3, version3);

// node_modules/idb/lib/idb.mjs
function toArray(arr) {
  return Array.prototype.slice.call(arr);
}
function promisifyRequest(request) {
  return new Promise(function(resolve, reject) {
    request.onsuccess = function() {
      resolve(request.result);
    };
    request.onerror = function() {
      reject(request.error);
    };
  });
}
function promisifyRequestCall(obj, method, args) {
  var request;
  var p2 = new Promise(function(resolve, reject) {
    request = obj[method].apply(obj, args);
    promisifyRequest(request).then(resolve, reject);
  });
  p2.request = request;
  return p2;
}
function promisifyCursorRequestCall(obj, method, args) {
  var p2 = promisifyRequestCall(obj, method, args);
  return p2.then(function(value) {
    if (!value)
      return;
    return new Cursor(value, p2.request);
  });
}
function proxyProperties(ProxyClass, targetProp, properties) {
  properties.forEach(function(prop) {
    Object.defineProperty(ProxyClass.prototype, prop, {
      get: function() {
        return this[targetProp][prop];
      },
      set: function(val) {
        this[targetProp][prop] = val;
      }
    });
  });
}
function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return this[targetProp][prop].apply(this[targetProp], arguments);
    };
  });
}
function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyCursorRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function Index2(index) {
  this._index = index;
}
proxyProperties(Index2, "_index", [
  "name",
  "keyPath",
  "multiEntry",
  "unique"
]);
proxyRequestMethods(Index2, "_index", IDBIndex, [
  "get",
  "getKey",
  "getAll",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(Index2, "_index", IDBIndex, [
  "openCursor",
  "openKeyCursor"
]);
function Cursor(cursor, request) {
  this._cursor = cursor;
  this._request = request;
}
proxyProperties(Cursor, "_cursor", [
  "direction",
  "key",
  "primaryKey",
  "value"
]);
proxyRequestMethods(Cursor, "_cursor", IDBCursor, [
  "update",
  "delete"
]);
["advance", "continue", "continuePrimaryKey"].forEach(function(methodName) {
  if (!(methodName in IDBCursor.prototype))
    return;
  Cursor.prototype[methodName] = function() {
    var cursor = this;
    var args = arguments;
    return Promise.resolve().then(function() {
      cursor._cursor[methodName].apply(cursor._cursor, args);
      return promisifyRequest(cursor._request).then(function(value) {
        if (!value)
          return;
        return new Cursor(value, cursor._request);
      });
    });
  };
});
function ObjectStore(store) {
  this._store = store;
}
ObjectStore.prototype.createIndex = function() {
  return new Index2(this._store.createIndex.apply(this._store, arguments));
};
ObjectStore.prototype.index = function() {
  return new Index2(this._store.index.apply(this._store, arguments));
};
proxyProperties(ObjectStore, "_store", [
  "name",
  "keyPath",
  "indexNames",
  "autoIncrement"
]);
proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "put",
  "add",
  "delete",
  "clear",
  "get",
  "getAll",
  "getKey",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "openCursor",
  "openKeyCursor"
]);
proxyMethods(ObjectStore, "_store", IDBObjectStore, [
  "deleteIndex"
]);
function Transaction(idbTransaction) {
  this._tx = idbTransaction;
  this.complete = new Promise(function(resolve, reject) {
    idbTransaction.oncomplete = function() {
      resolve();
    };
    idbTransaction.onerror = function() {
      reject(idbTransaction.error);
    };
    idbTransaction.onabort = function() {
      reject(idbTransaction.error);
    };
  });
}
Transaction.prototype.objectStore = function() {
  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};
proxyProperties(Transaction, "_tx", [
  "objectStoreNames",
  "mode"
]);
proxyMethods(Transaction, "_tx", IDBTransaction, [
  "abort"
]);
function UpgradeDB(db2, oldVersion, transaction) {
  this._db = db2;
  this.oldVersion = oldVersion;
  this.transaction = new Transaction(transaction);
}
UpgradeDB.prototype.createObjectStore = function() {
  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};
proxyProperties(UpgradeDB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(UpgradeDB, "_db", IDBDatabase, [
  "deleteObjectStore",
  "close"
]);
function DB(db2) {
  this._db = db2;
}
DB.prototype.transaction = function() {
  return new Transaction(this._db.transaction.apply(this._db, arguments));
};
proxyProperties(DB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(DB, "_db", IDBDatabase, [
  "close"
]);
["openCursor", "openKeyCursor"].forEach(function(funcName) {
  [ObjectStore, Index2].forEach(function(Constructor) {
    if (!(funcName in Constructor.prototype))
      return;
    Constructor.prototype[funcName.replace("open", "iterate")] = function() {
      var args = toArray(arguments);
      var callback = args[args.length - 1];
      var nativeObject = this._store || this._index;
      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
      request.onsuccess = function() {
        callback(request.result);
      };
    };
  });
});
[Index2, ObjectStore].forEach(function(Constructor) {
  if (Constructor.prototype.getAll)
    return;
  Constructor.prototype.getAll = function(query, count) {
    var instance = this;
    var items = [];
    return new Promise(function(resolve) {
      instance.iterateCursor(query, function(cursor) {
        if (!cursor) {
          resolve(items);
          return;
        }
        items.push(cursor.value);
        if (count !== void 0 && items.length == count) {
          resolve(items);
          return;
        }
        cursor.continue();
      });
    });
  };
});
function openDb(name10, version10, upgradeCallback) {
  var p2 = promisifyRequestCall(indexedDB, "open", [name10, version10]);
  var request = p2.request;
  if (request) {
    request.onupgradeneeded = function(event) {
      if (upgradeCallback) {
        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
      }
    };
  }
  return p2.then(function(db2) {
    return new DB(db2);
  });
}
function deleteDb(name10) {
  return promisifyRequestCall(indexedDB, "deleteDatabase", [name10]);
}

// node_modules/@firebase/installations/dist/index.esm.js
var name4 = "@firebase/installations";
var version4 = "0.4.22";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = "w:" + version4;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var _a4;
var ERROR_DESCRIPTION_MAP = (_a4 = {}, _a4[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a4[
  "not-registered"
  /* NOT_REGISTERED */
] = "Firebase Installation is not registered.", _a4[
  "installation-not-found"
  /* INSTALLATION_NOT_FOUND */
] = "Firebase Installation not found.", _a4[
  "request-failed"
  /* REQUEST_FAILED */
] = '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', _a4[
  "app-offline"
  /* APP_OFFLINE */
] = "Could not process request. Application offline.", _a4[
  "delete-pending-registration"
  /* DELETE_PENDING_REGISTRATION */
] = "Can't delete installation while there is a pending registration request.", _a4);
var ERROR_FACTORY2 = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error2) {
  return error2 instanceof FirebaseError && error2.code.includes(
    "request-failed"
    /* REQUEST_FAILED */
  );
}
function getInstallationsEndpoint(_a9) {
  var projectId = _a9.projectId;
  return INSTALLATIONS_API_URL + "/projects/" + projectId + "/installations";
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
function getErrorFromResponse(requestName, response) {
  return __awaiter(this, void 0, void 0, function() {
    var responseJson, errorData;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, response.json()];
        case 1:
          responseJson = _a9.sent();
          errorData = responseJson.error;
          return [2, ERROR_FACTORY2.create("request-failed", {
            requestName,
            serverCode: errorData.code,
            serverMessage: errorData.message,
            serverStatus: errorData.status
          })];
      }
    });
  });
}
function getHeaders(_a9) {
  var apiKey = _a9.apiKey;
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, _a9) {
  var refreshToken = _a9.refreshToken;
  var headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
function retryIfServerError(fn2) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, fn2()];
        case 1:
          result = _a9.sent();
          if (result.status >= 500 && result.status < 600) {
            return [2, fn2()];
          }
          return [2, result];
      }
    });
  });
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return INTERNAL_AUTH_VERSION + " " + refreshToken;
}
function createInstallationRequest(appConfig, _a9) {
  var fid = _a9.fid;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, body, request, response, responseValue, registeredInstallationEntry;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getInstallationsEndpoint(appConfig);
          headers = getHeaders(appConfig);
          body = {
            fid,
            authVersion: INTERNAL_AUTH_VERSION,
            appId: appConfig.appId,
            sdkVersion: PACKAGE_VERSION
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok)
            return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          registeredInstallationEntry = {
            fid: responseValue.fid || fid,
            registrationStatus: 2,
            refreshToken: responseValue.refreshToken,
            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
          };
          return [2, registeredInstallationEntry];
        case 3:
          return [4, getErrorFromResponse("Create Installation", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function sleep(ms2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms2);
  });
}
function bufferToBase64UrlSafe(array) {
  var b64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array))));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    var fidByteArray = new Uint8Array(17);
    var crypto_1 = self.crypto || self.msCrypto;
    crypto_1.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    var fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a9) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  var b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return appConfig.appName + "!" + appConfig.appId;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  var key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) {
  getBroadcastChannel();
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    callbackSet = /* @__PURE__ */ new Set();
    fidChangeCallbacks.set(key, callbackSet);
  }
  callbackSet.add(callback);
}
function removeCallback(appConfig, callback) {
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    return;
  }
  callbackSet.delete(callback);
  if (callbackSet.size === 0) {
    fidChangeCallbacks.delete(key);
  }
  closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) {
  var e_1, _a9;
  var callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  try {
    for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
      var callback = callbacks_1_1.value;
      callback(fid);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (callbacks_1_1 && !callbacks_1_1.done && (_a9 = callbacks_1.return))
        _a9.call(callbacks_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function broadcastFidChange(key, fid) {
  var channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = function(e) {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, function(upgradeDB) {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
function set(appConfig, value) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tx, objectStore, oldValue;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db2 = _a9.sent();
          tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
          objectStore = tx.objectStore(OBJECT_STORE_NAME);
          return [4, objectStore.get(key)];
        case 2:
          oldValue = _a9.sent();
          return [4, objectStore.put(value, key)];
        case 3:
          _a9.sent();
          return [4, tx.complete];
        case 4:
          _a9.sent();
          if (!oldValue || oldValue.fid !== value.fid) {
            fidChanged(appConfig, value.fid);
          }
          return [2, value];
      }
    });
  });
}
function remove(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tx;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db2 = _a9.sent();
          tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME).delete(key)];
        case 2:
          _a9.sent();
          return [4, tx.complete];
        case 3:
          _a9.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function update(appConfig, updateFn) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tx, store, oldValue, newValue;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db2 = _a9.sent();
          tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
          store = tx.objectStore(OBJECT_STORE_NAME);
          return [4, store.get(key)];
        case 2:
          oldValue = _a9.sent();
          newValue = updateFn(oldValue);
          if (!(newValue === void 0))
            return [3, 4];
          return [4, store.delete(key)];
        case 3:
          _a9.sent();
          return [3, 6];
        case 4:
          return [4, store.put(newValue, key)];
        case 5:
          _a9.sent();
          _a9.label = 6;
        case 6:
          return [4, tx.complete];
        case 7:
          _a9.sent();
          if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
            fidChanged(appConfig, newValue.fid);
          }
          return [2, newValue];
      }
    });
  });
}
function getInstallationEntry(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise, installationEntry;
    var _a9;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(appConfig, function(oldEntry) {
            var installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
            var entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
            registrationPromise = entryWithPromise.registrationPromise;
            return entryWithPromise.installationEntry;
          })];
        case 1:
          installationEntry = _b.sent();
          if (!(installationEntry.fid === INVALID_FID))
            return [3, 3];
          _a9 = {};
          return [4, registrationPromise];
        case 2:
          return [2, (_a9.installationEntry = _b.sent(), _a9)];
        case 3:
          return [2, {
            installationEntry,
            registrationPromise
          }];
      }
    });
  });
}
function updateOrCreateInstallationEntry(oldEntry) {
  var entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
    /* NOT_STARTED */
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      var registrationPromiseWithError = Promise.reject(ERROR_FACTORY2.create(
        "app-offline"
        /* APP_OFFLINE */
      ));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    var inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    var registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
function registerInstallation(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var registeredInstallationEntry, e_1;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          _a9.trys.push([0, 2, , 7]);
          return [4, createInstallationRequest(appConfig, installationEntry)];
        case 1:
          registeredInstallationEntry = _a9.sent();
          return [2, set(appConfig, registeredInstallationEntry)];
        case 2:
          e_1 = _a9.sent();
          if (!(isServerError(e_1) && e_1.customData.serverCode === 409))
            return [3, 4];
          return [4, remove(appConfig)];
        case 3:
          _a9.sent();
          return [3, 6];
        case 4:
          return [4, set(appConfig, {
            fid: installationEntry.fid,
            registrationStatus: 0
            /* NOT_STARTED */
          })];
        case 5:
          _a9.sent();
          _a9.label = 6;
        case 6:
          throw e_1;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function waitUntilFidRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, _a9, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, updateInstallationRequest(appConfig)];
        case 1:
          entry = _b.sent();
          _b.label = 2;
        case 2:
          if (!(entry.registrationStatus === 1))
            return [3, 5];
          return [4, sleep(100)];
        case 3:
          _b.sent();
          return [4, updateInstallationRequest(appConfig)];
        case 4:
          entry = _b.sent();
          return [3, 2];
        case 5:
          if (!(entry.registrationStatus === 0))
            return [3, 7];
          return [4, getInstallationEntry(appConfig)];
        case 6:
          _a9 = _b.sent(), installationEntry = _a9.installationEntry, registrationPromise = _a9.registrationPromise;
          if (registrationPromise) {
            return [2, registrationPromise];
          } else {
            return [2, installationEntry];
          }
        case 7:
          return [2, entry];
      }
    });
  });
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!oldEntry) {
      throw ERROR_FACTORY2.create(
        "installation-not-found"
        /* INSTALLATION_NOT_FOUND */
      );
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
      /* NOT_STARTED */
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
function generateAuthTokenRequest(_a9, installationEntry) {
  var appConfig = _a9.appConfig, platformLoggerProvider = _a9.platformLoggerProvider;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, platformLogger, body, request, response, responseValue, completedAuthToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          platformLogger = platformLoggerProvider.getImmediate({
            optional: true
          });
          if (platformLogger) {
            headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
          }
          body = {
            installation: {
              sdkVersion: PACKAGE_VERSION
            }
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok)
            return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
          return [2, completedAuthToken];
        case 3:
          return [4, getErrorFromResponse("Generate Auth Token", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function getGenerateAuthTokenEndpoint(appConfig, _a9) {
  var fid = _a9.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid + "/authTokens:generate";
}
function refreshAuthToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var tokenPromise, entry, authToken, _a9;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(dependencies.appConfig, function(oldEntry) {
            if (!isEntryRegistered(oldEntry)) {
              throw ERROR_FACTORY2.create(
                "not-registered"
                /* NOT_REGISTERED */
              );
            }
            var oldAuthToken = oldEntry.authToken;
            if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
              return oldEntry;
            } else if (oldAuthToken.requestStatus === 1) {
              tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);
              return oldEntry;
            } else {
              if (!navigator.onLine) {
                throw ERROR_FACTORY2.create(
                  "app-offline"
                  /* APP_OFFLINE */
                );
              }
              var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
              tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);
              return inProgressEntry;
            }
          })];
        case 1:
          entry = _b.sent();
          if (!tokenPromise)
            return [3, 3];
          return [4, tokenPromise];
        case 2:
          _a9 = _b.sent();
          return [3, 4];
        case 3:
          _a9 = entry.authToken;
          _b.label = 4;
        case 4:
          authToken = _a9;
          return [2, authToken];
      }
    });
  });
}
function waitUntilAuthTokenRequest(dependencies, forceRefresh) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, authToken;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 1:
          entry = _a9.sent();
          _a9.label = 2;
        case 2:
          if (!(entry.authToken.requestStatus === 1))
            return [3, 5];
          return [4, sleep(100)];
        case 3:
          _a9.sent();
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 4:
          entry = _a9.sent();
          return [3, 2];
        case 5:
          authToken = entry.authToken;
          if (authToken.requestStatus === 0) {
            return [2, refreshAuthToken(dependencies, forceRefresh)];
          } else {
            return [2, authToken];
          }
      }
    });
  });
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY2.create(
        "not-registered"
        /* NOT_REGISTERED */
      );
    }
    var oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return __assign(__assign({}, oldEntry), { authToken: {
        requestStatus: 0
        /* NOT_STARTED */
      } });
    }
    return oldEntry;
  });
}
function fetchAuthTokenFromServer(dependencies, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          _a9.trys.push([0, 3, , 8]);
          return [4, generateAuthTokenRequest(dependencies, installationEntry)];
        case 1:
          authToken = _a9.sent();
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 2:
          _a9.sent();
          return [2, authToken];
        case 3:
          e_1 = _a9.sent();
          if (!(isServerError(e_1) && (e_1.customData.serverCode === 401 || e_1.customData.serverCode === 404)))
            return [3, 5];
          return [4, remove(dependencies.appConfig)];
        case 4:
          _a9.sent();
          return [3, 7];
        case 5:
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken: {
            requestStatus: 0
            /* NOT_STARTED */
          } });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 6:
          _a9.sent();
          _a9.label = 7;
        case 7:
          throw e_1;
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  var now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  var inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return __assign(__assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
function getId(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var _a9, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getInstallationEntry(dependencies.appConfig)];
        case 1:
          _a9 = _b.sent(), installationEntry = _a9.installationEntry, registrationPromise = _a9.registrationPromise;
          if (registrationPromise) {
            registrationPromise.catch(console.error);
          } else {
            refreshAuthToken(dependencies).catch(console.error);
          }
          return [2, installationEntry.fid];
      }
    });
  });
}
function getToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, completeInstallationRegistration(dependencies.appConfig)];
        case 1:
          _a9.sent();
          return [4, refreshAuthToken(dependencies, forceRefresh)];
        case 2:
          authToken = _a9.sent();
          return [2, authToken.token];
      }
    });
  });
}
function completeInstallationRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, getInstallationEntry(appConfig)];
        case 1:
          registrationPromise = _a9.sent().registrationPromise;
          if (!registrationPromise)
            return [3, 3];
          return [4, registrationPromise];
        case 2:
          _a9.sent();
          _a9.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteInstallationRequest(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, request, response;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          endpoint = getDeleteEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          request = {
            method: "DELETE",
            headers
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _a9.sent();
          if (!!response.ok)
            return [3, 3];
          return [4, getErrorFromResponse("Delete Installation", response)];
        case 2:
          throw _a9.sent();
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getDeleteEndpoint(appConfig, _a9) {
  var fid = _a9.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid;
}
function deleteInstallation(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var appConfig, entry;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          appConfig = dependencies.appConfig;
          return [4, update(appConfig, function(oldEntry) {
            if (oldEntry && oldEntry.registrationStatus === 0) {
              return void 0;
            }
            return oldEntry;
          })];
        case 1:
          entry = _a9.sent();
          if (!entry)
            return [3, 6];
          if (!(entry.registrationStatus === 1))
            return [3, 2];
          throw ERROR_FACTORY2.create(
            "delete-pending-registration"
            /* DELETE_PENDING_REGISTRATION */
          );
        case 2:
          if (!(entry.registrationStatus === 2))
            return [3, 6];
          if (!!navigator.onLine)
            return [3, 3];
          throw ERROR_FACTORY2.create(
            "app-offline"
            /* APP_OFFLINE */
          );
        case 3:
          return [4, deleteInstallationRequest(appConfig, entry)];
        case 4:
          _a9.sent();
          return [4, remove(appConfig)];
        case 5:
          _a9.sent();
          _a9.label = 6;
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function onIdChange(_a9, callback) {
  var appConfig = _a9.appConfig;
  addCallback(appConfig, callback);
  return function() {
    removeCallback(appConfig, callback);
  };
}
function extractAppConfig(app) {
  var e_1, _a9;
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!app.options[keyName]) {
        throw getMissingValueError(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a9 = configKeys_1.return))
        _a9.call(configKeys_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY2.create("missing-app-config-values", {
    valueName
  });
}
function registerInstallations(instance) {
  var installationsName = "installations";
  instance.INTERNAL.registerComponent(new Component(
    installationsName,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var appConfig = extractAppConfig(app);
      var platformLoggerProvider = container.getProvider("platform-logger");
      var dependencies = {
        appConfig,
        platformLoggerProvider
      };
      var installations = {
        app,
        getId: function() {
          return getId(dependencies);
        },
        getToken: function(forceRefresh) {
          return getToken(dependencies, forceRefresh);
        },
        delete: function() {
          return deleteInstallation(dependencies);
        },
        onIdChange: function(callback) {
          return onIdChange(dependencies, callback);
        }
      };
      return installations;
    },
    "PUBLIC"
    /* PUBLIC */
  ));
  instance.registerVersion(name4, version4);
}
registerInstallations(index_esm_default);

// node_modules/@firebase/messaging/dist/index.esm.js
var _a5;
var ERROR_MAP = (_a5 = {}, _a5[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a5[
  "only-available-in-window"
  /* AVAILABLE_IN_WINDOW */
] = "This method is available in a Window context.", _a5[
  "only-available-in-sw"
  /* AVAILABLE_IN_SW */
] = "This method is available in a service worker context.", _a5[
  "permission-default"
  /* PERMISSION_DEFAULT */
] = "The notification permission was not granted and dismissed instead.", _a5[
  "permission-blocked"
  /* PERMISSION_BLOCKED */
] = "The notification permission was not granted and blocked instead.", _a5[
  "unsupported-browser"
  /* UNSUPPORTED_BROWSER */
] = "This browser doesn't support the API's required to use the firebase SDK.", _a5[
  "failed-service-worker-registration"
  /* FAILED_DEFAULT_REGISTRATION */
] = "We are unable to register the default service worker. {$browserErrorMessage}", _a5[
  "token-subscribe-failed"
  /* TOKEN_SUBSCRIBE_FAILED */
] = "A problem occurred while subscribing the user to FCM: {$errorInfo}", _a5[
  "token-subscribe-no-token"
  /* TOKEN_SUBSCRIBE_NO_TOKEN */
] = "FCM returned no token when subscribing the user to push.", _a5[
  "token-unsubscribe-failed"
  /* TOKEN_UNSUBSCRIBE_FAILED */
] = "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", _a5[
  "token-update-failed"
  /* TOKEN_UPDATE_FAILED */
] = "A problem occurred while updating the user from FCM: {$errorInfo}", _a5[
  "token-update-no-token"
  /* TOKEN_UPDATE_NO_TOKEN */
] = "FCM returned no token when updating the user to push.", _a5[
  "use-sw-after-get-token"
  /* USE_SW_AFTER_GET_TOKEN */
] = "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", _a5[
  "invalid-sw-registration"
  /* INVALID_SW_REGISTRATION */
] = "The input to useServiceWorker() must be a ServiceWorkerRegistration.", _a5[
  "invalid-bg-handler"
  /* INVALID_BG_HANDLER */
] = "The input to setBackgroundMessageHandler() must be a function.", _a5[
  "invalid-vapid-key"
  /* INVALID_VAPID_KEY */
] = "The public VAPID key must be a string.", _a5[
  "use-vapid-key-after-get-token"
  /* USE_VAPID_KEY_AFTER_GET_TOKEN */
] = "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used.", _a5);
var ERROR_FACTORY3 = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
var DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
var FCM_MSG = "FCM_MSG";
var TAG = "FirebaseMessaging: ";
var CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
var CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
var CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
var BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS = 1e3;
var FOREGROUND_HANDLE_PREPARATION_TIME_MS = 3e3;
var MessageType;
(function(MessageType2) {
  MessageType2["PUSH_RECEIVED"] = "push-received";
  MessageType2["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
function arrayToBase64(array) {
  var uint8Array = new Uint8Array(array);
  var base64String = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(uint8Array))));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  var padding = "=".repeat((4 - base64String.length % 4) % 4);
  var base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  var rawData = atob(base642);
  var outputArray = new Uint8Array(rawData.length);
  for (var i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME = "fcm_token_details_db";
var OLD_DB_VERSION = 5;
var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
function migrateOldDatabase(senderId) {
  return __awaiter(this, void 0, void 0, function() {
    var databases, dbNames, tokenDetails, db2;
    var _this = this;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (!("databases" in indexedDB))
            return [3, 2];
          return [4, indexedDB.databases()];
        case 1:
          databases = _a9.sent();
          dbNames = databases.map(function(db3) {
            return db3.name;
          });
          if (!dbNames.includes(OLD_DB_NAME)) {
            return [2, null];
          }
          _a9.label = 2;
        case 2:
          tokenDetails = null;
          return [4, openDb(OLD_DB_NAME, OLD_DB_VERSION, function(db3) {
            return __awaiter(_this, void 0, void 0, function() {
              var objectStore, value, oldDetails, oldDetails, oldDetails;
              var _a10;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    if (db3.oldVersion < 2) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (!db3.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    objectStore = db3.transaction.objectStore(OLD_OBJECT_STORE_NAME);
                    return [4, objectStore.index("fcmSenderId").get(senderId)];
                  case 1:
                    value = _b.sent();
                    return [4, objectStore.clear()];
                  case 2:
                    _b.sent();
                    if (!value) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (db3.oldVersion === 2) {
                      oldDetails = value;
                      if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: (_a10 = oldDetails.createTime) !== null && _a10 !== void 0 ? _a10 : Date.now(),
                        subscriptionOptions: {
                          auth: oldDetails.auth,
                          p256dh: oldDetails.p256dh,
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db3.oldVersion === 3) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db3.oldVersion === 4) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    }
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          })];
        case 3:
          db2 = _a9.sent();
          db2.close();
          return [4, deleteDb(OLD_DB_NAME)];
        case 4:
          _a9.sent();
          return [4, deleteDb("fcm_vapid_details_db")];
        case 5:
          _a9.sent();
          return [4, deleteDb("undefined")];
        case 6:
          _a9.sent();
          return [2, checkTokenDetails(tokenDetails) ? tokenDetails : null];
      }
    });
  });
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  var subscriptionOptions = tokenDetails.subscriptionOptions;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME2 = "firebase-messaging-database";
var DATABASE_VERSION2 = 1;
var OBJECT_STORE_NAME2 = "firebase-messaging-store";
var dbPromise2 = null;
function getDbPromise2() {
  if (!dbPromise2) {
    dbPromise2 = openDb(DATABASE_NAME2, DATABASE_VERSION2, function(upgradeDb) {
      switch (upgradeDb.oldVersion) {
        case 0:
          upgradeDb.createObjectStore(OBJECT_STORE_NAME2);
      }
    });
  }
  return dbPromise2;
}
function dbGet(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tokenDetails, oldTokenDetails;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db2 = _a9.sent();
          return [4, db2.transaction(OBJECT_STORE_NAME2).objectStore(OBJECT_STORE_NAME2).get(key)];
        case 2:
          tokenDetails = _a9.sent();
          if (!tokenDetails)
            return [3, 3];
          return [2, tokenDetails];
        case 3:
          return [4, migrateOldDatabase(firebaseDependencies.appConfig.senderId)];
        case 4:
          oldTokenDetails = _a9.sent();
          if (!oldTokenDetails)
            return [3, 6];
          return [4, dbSet(firebaseDependencies, oldTokenDetails)];
        case 5:
          _a9.sent();
          return [2, oldTokenDetails];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function dbSet(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tx;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db2 = _a9.sent();
          tx = db2.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).put(tokenDetails, key)];
        case 2:
          _a9.sent();
          return [4, tx.complete];
        case 3:
          _a9.sent();
          return [2, tokenDetails];
      }
    });
  });
}
function dbRemove(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db2, tx;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db2 = _a9.sent();
          tx = db2.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).delete(key)];
        case 2:
          _a9.sent();
          return [4, tx.complete];
        case 3:
          _a9.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getKey2(_a9) {
  var appConfig = _a9.appConfig;
  return appConfig.appId;
}
function requestGetToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, subscribeOptions, responseData, response, err_1, message;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a9.sent();
          body = getBody(subscriptionOptions);
          subscribeOptions = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          _a9.label = 2;
        case 2:
          _a9.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions)];
        case 3:
          response = _a9.sent();
          return [4, response.json()];
        case 4:
          responseData = _a9.sent();
          return [3, 6];
        case 5:
          err_1 = _a9.sent();
          throw ERROR_FACTORY3.create("token-subscribe-failed", {
            errorInfo: err_1
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY3.create("token-subscribe-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY3.create(
              "token-subscribe-no-token"
              /* TOKEN_SUBSCRIBE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestUpdateToken(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, updateOptions, responseData, response, err_2, message;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a9.sent();
          body = getBody(tokenDetails.subscriptionOptions);
          updateOptions = {
            method: "PATCH",
            headers,
            body: JSON.stringify(body)
          };
          _a9.label = 2;
        case 2:
          _a9.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + tokenDetails.token, updateOptions)];
        case 3:
          response = _a9.sent();
          return [4, response.json()];
        case 4:
          responseData = _a9.sent();
          return [3, 6];
        case 5:
          err_2 = _a9.sent();
          throw ERROR_FACTORY3.create("token-update-failed", {
            errorInfo: err_2
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY3.create("token-update-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY3.create(
              "token-update-no-token"
              /* TOKEN_UPDATE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestDeleteToken(firebaseDependencies, token) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, unsubscribeOptions, response, responseData, message, err_3;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a9.sent();
          unsubscribeOptions = {
            method: "DELETE",
            headers
          };
          _a9.label = 2;
        case 2:
          _a9.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + token, unsubscribeOptions)];
        case 3:
          response = _a9.sent();
          return [4, response.json()];
        case 4:
          responseData = _a9.sent();
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY3.create("token-unsubscribe-failed", {
              errorInfo: message
            });
          }
          return [3, 6];
        case 5:
          err_3 = _a9.sent();
          throw ERROR_FACTORY3.create("token-unsubscribe-failed", {
            errorInfo: err_3
          });
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getEndpoint(_a9) {
  var projectId = _a9.projectId;
  return ENDPOINT + "/projects/" + projectId + "/registrations";
}
function getHeaders2(_a9) {
  var appConfig = _a9.appConfig, installations = _a9.installations;
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, installations.getToken()];
        case 1:
          authToken = _b.sent();
          return [2, new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-goog-api-key": appConfig.apiKey,
            "x-goog-firebase-installations-auth": "FIS " + authToken
          })];
      }
    });
  });
}
function getBody(_a9) {
  var p256dh = _a9.p256dh, auth = _a9.auth, endpoint = _a9.endpoint, vapidKey = _a9.vapidKey;
  var body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
function getToken2(firebaseDependencies, swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var pushSubscription, tokenDetails, subscriptionOptions, e_1;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (Notification.permission !== "granted") {
            throw ERROR_FACTORY3.create(
              "permission-blocked"
              /* PERMISSION_BLOCKED */
            );
          }
          return [4, getPushSubscription(swRegistration, vapidKey)];
        case 1:
          pushSubscription = _a9.sent();
          return [4, dbGet(firebaseDependencies)];
        case 2:
          tokenDetails = _a9.sent();
          subscriptionOptions = {
            vapidKey,
            swScope: swRegistration.scope,
            endpoint: pushSubscription.endpoint,
            auth: arrayToBase64(pushSubscription.getKey("auth")),
            p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
          };
          if (!!tokenDetails)
            return [3, 3];
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 3:
          if (!!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions))
            return [3, 8];
          _a9.label = 4;
        case 4:
          _a9.trys.push([4, 6, , 7]);
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 5:
          _a9.sent();
          return [3, 7];
        case 6:
          e_1 = _a9.sent();
          console.warn(e_1);
          return [3, 7];
        case 7:
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 8:
          if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
            return [2, updateToken({
              token: tokenDetails.token,
              createTime: Date.now(),
              subscriptionOptions
            }, firebaseDependencies, swRegistration)];
          } else {
            return [2, tokenDetails.token];
          }
        case 9:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteToken(firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var tokenDetails, pushSubscription;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, dbGet(firebaseDependencies)];
        case 1:
          tokenDetails = _a9.sent();
          if (!tokenDetails)
            return [3, 4];
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 2:
          _a9.sent();
          return [4, dbRemove(firebaseDependencies)];
        case 3:
          _a9.sent();
          _a9.label = 4;
        case 4:
          return [4, swRegistration.pushManager.getSubscription()];
        case 5:
          pushSubscription = _a9.sent();
          if (pushSubscription) {
            return [2, pushSubscription.unsubscribe()];
          }
          return [2, true];
      }
    });
  });
}
function updateToken(tokenDetails, firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var updatedToken, updatedTokenDetails, e_2;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          _a9.trys.push([0, 3, , 5]);
          return [4, requestUpdateToken(firebaseDependencies, tokenDetails)];
        case 1:
          updatedToken = _a9.sent();
          updatedTokenDetails = __assign(__assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
          return [4, dbSet(firebaseDependencies, updatedTokenDetails)];
        case 2:
          _a9.sent();
          return [2, updatedToken];
        case 3:
          e_2 = _a9.sent();
          return [4, deleteToken(firebaseDependencies, swRegistration)];
        case 4:
          _a9.sent();
          throw e_2;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getNewToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var token, tokenDetails;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, requestGetToken(firebaseDependencies, subscriptionOptions)];
        case 1:
          token = _a9.sent();
          tokenDetails = {
            token,
            createTime: Date.now(),
            subscriptionOptions
          };
          return [4, dbSet(firebaseDependencies, tokenDetails)];
        case 2:
          _a9.sent();
          return [2, tokenDetails.token];
      }
    });
  });
}
function getPushSubscription(swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var subscription;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, swRegistration.pushManager.getSubscription()];
        case 1:
          subscription = _a9.sent();
          if (subscription) {
            return [2, subscription];
          }
          return [2, swRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
            // submitted to pushManager#subscribe must be of type Uint8Array.
            applicationServerKey: base64ToArray(vapidKey)
          })];
      }
    });
  });
}
function isTokenValid(dbOptions, currentOptions) {
  var isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  var isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  var isAuthEqual = currentOptions.auth === dbOptions.auth;
  var isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload(internalPayload) {
  var payload = {
    from: internalPayload.from,
    // eslint-disable-next-line camelcase
    collapseKey: internalPayload.collapse_key
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  var title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  var body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  var image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.fcmOptions) {
    return;
  }
  payload.fcmOptions = {};
  var link = messagePayloadInternal.fcmOptions.link;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  var analyticsLabel = messagePayloadInternal.fcmOptions.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
function sleep2(ms2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms2);
  });
}
var SwController = (
  /** @class */
  function() {
    function SwController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.isOnBackgroundMessageUsed = null;
      this.vapidKey = null;
      this.bgMessageHandler = null;
      self.addEventListener("push", function(e) {
        e.waitUntil(_this.onPush(e));
      });
      self.addEventListener("pushsubscriptionchange", function(e) {
        e.waitUntil(_this.onSubChange(e));
      });
      self.addEventListener("notificationclick", function(e) {
        e.waitUntil(_this.onNotificationClick(e));
      });
    }
    Object.defineProperty(SwController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    SwController2.prototype.setBackgroundMessageHandler = function(callback) {
      this.isOnBackgroundMessageUsed = false;
      if (!callback || typeof callback !== "function") {
        throw ERROR_FACTORY3.create(
          "invalid-bg-handler"
          /* INVALID_BG_HANDLER */
        );
      }
      this.bgMessageHandler = callback;
    };
    SwController2.prototype.onBackgroundMessage = function(nextOrObserver) {
      var _this = this;
      this.isOnBackgroundMessageUsed = true;
      this.bgMessageHandler = nextOrObserver;
      return function() {
        _this.bgMessageHandler = null;
      };
    };
    SwController2.prototype.getToken = function() {
      var _a9, _b;
      return __awaiter(this, void 0, void 0, function() {
        var tokenDetails;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              if (!!this.vapidKey)
                return [3, 2];
              return [4, dbGet(this.firebaseDependencies)];
            case 1:
              tokenDetails = _c2.sent();
              this.vapidKey = (_b = (_a9 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a9 === void 0 ? void 0 : _a9.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY;
              _c2.label = 2;
            case 2:
              return [2, getToken2(this.firebaseDependencies, self.registration, this.vapidKey)];
          }
        });
      });
    };
    SwController2.prototype.deleteToken = function() {
      return deleteToken(this.firebaseDependencies, self.registration);
    };
    SwController2.prototype.requestPermission = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY3.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY3.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    SwController2.prototype.useServiceWorker = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onMessage = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onTokenRefresh = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onPush = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, clientList, isNotificationShown, payload;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              internalPayload = getMessagePayloadInternal(event);
              if (!internalPayload) {
                console.debug(TAG + "failed to get parsed MessagePayload from the PushEvent. Skip handling the push.");
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getClientList()];
            case 1:
              clientList = _a9.sent();
              if (hasVisibleClients(clientList)) {
                return [2, sendMessagePayloadInternalToWindows(clientList, internalPayload)];
              }
              isNotificationShown = false;
              if (!!!internalPayload.notification)
                return [3, 3];
              return [4, showNotification(wrapInternalPayload(internalPayload))];
            case 2:
              _a9.sent();
              isNotificationShown = true;
              _a9.label = 3;
            case 3:
              if (isNotificationShown === true && this.isOnBackgroundMessageUsed === false) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!!this.bgMessageHandler) {
                payload = externalizePayload(internalPayload);
                if (typeof this.bgMessageHandler === "function") {
                  this.bgMessageHandler(payload);
                } else {
                  this.bgMessageHandler.next(payload);
                }
              }
              return [4, sleep2(BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS)];
            case 4:
              _a9.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onSubChange = function(event) {
      var _a9, _b;
      return __awaiter(this, void 0, void 0, function() {
        var newSubscription, tokenDetails;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              newSubscription = event.newSubscription;
              if (!!newSubscription)
                return [3, 2];
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 1:
              _c2.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              return [4, dbGet(this.firebaseDependencies)];
            case 3:
              tokenDetails = _c2.sent();
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 4:
              _c2.sent();
              return [4, getToken2(this.firebaseDependencies, self.registration, (_b = (_a9 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a9 === void 0 ? void 0 : _a9.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY)];
            case 5:
              _c2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onNotificationClick = function(event) {
      var _a9, _b;
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, link, url, originUrl, client;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              internalPayload = (_b = (_a9 = event.notification) === null || _a9 === void 0 ? void 0 : _a9.data) === null || _b === void 0 ? void 0 : _b[FCM_MSG];
              if (!internalPayload) {
                return [
                  2
                  /*return*/
                ];
              } else if (event.action) {
                return [
                  2
                  /*return*/
                ];
              }
              event.stopImmediatePropagation();
              event.notification.close();
              link = getLink(internalPayload);
              if (!link) {
                return [
                  2
                  /*return*/
                ];
              }
              url = new URL(link, self.location.href);
              originUrl = new URL(self.location.origin);
              if (url.host !== originUrl.host) {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getWindowClient(url)];
            case 1:
              client = _c2.sent();
              if (!!client)
                return [3, 4];
              return [4, self.clients.openWindow(link)];
            case 2:
              client = _c2.sent();
              return [4, sleep2(FOREGROUND_HANDLE_PREPARATION_TIME_MS)];
            case 3:
              _c2.sent();
              return [3, 6];
            case 4:
              return [4, client.focus()];
            case 5:
              client = _c2.sent();
              _c2.label = 6;
            case 6:
              if (!client) {
                return [
                  2
                  /*return*/
                ];
              }
              internalPayload.messageType = MessageType.NOTIFICATION_CLICKED;
              internalPayload.isFirebaseMessaging = true;
              return [2, client.postMessage(internalPayload)];
          }
        });
      });
    };
    return SwController2;
  }()
);
function wrapInternalPayload(internalPayload) {
  var _a9;
  var wrappedInternalPayload = __assign({}, internalPayload.notification);
  wrappedInternalPayload.data = (_a9 = {}, _a9[FCM_MSG] = internalPayload, _a9);
  return wrappedInternalPayload;
}
function getMessagePayloadInternal(_a9) {
  var data = _a9.data;
  if (!data) {
    return null;
  }
  try {
    return data.json();
  } catch (err) {
    return null;
  }
}
function getWindowClient(url) {
  return __awaiter(this, void 0, void 0, function() {
    var clientList, clientList_1, clientList_1_1, client, clientUrl;
    var e_1, _a9;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getClientList()];
        case 1:
          clientList = _b.sent();
          try {
            for (clientList_1 = __values(clientList), clientList_1_1 = clientList_1.next(); !clientList_1_1.done; clientList_1_1 = clientList_1.next()) {
              client = clientList_1_1.value;
              clientUrl = new URL(client.url, self.location.href);
              if (url.host === clientUrl.host) {
                return [2, client];
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (clientList_1_1 && !clientList_1_1.done && (_a9 = clientList_1.return))
                _a9.call(clientList_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return [2, null];
      }
    });
  });
}
function hasVisibleClients(clientList) {
  return clientList.some(function(client) {
    return client.visibilityState === "visible" && // Ignore chrome-extension clients as that matches the background pages of extensions, which
    // are always considered visible for some reason.
    !client.url.startsWith("chrome-extension://");
  });
}
function sendMessagePayloadInternalToWindows(clientList, internalPayload) {
  var e_2, _a9;
  internalPayload.isFirebaseMessaging = true;
  internalPayload.messageType = MessageType.PUSH_RECEIVED;
  try {
    for (var clientList_2 = __values(clientList), clientList_2_1 = clientList_2.next(); !clientList_2_1.done; clientList_2_1 = clientList_2.next()) {
      var client = clientList_2_1.value;
      client.postMessage(internalPayload);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (clientList_2_1 && !clientList_2_1.done && (_a9 = clientList_2.return))
        _a9.call(clientList_2);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
}
function getClientList() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: true
    // TS doesn't know that "type: 'window'" means it'll return WindowClient[]
  });
}
function showNotification(notificationPayloadInternal) {
  var _a9;
  var actions = notificationPayloadInternal.actions;
  var maxActions = Notification.maxActions;
  if (actions && maxActions && actions.length > maxActions) {
    console.warn("This browser only supports " + maxActions + " actions. The remaining actions will not be displayed.");
  }
  return self.registration.showNotification(
    /* title= */
    (_a9 = notificationPayloadInternal.title) !== null && _a9 !== void 0 ? _a9 : "",
    notificationPayloadInternal
  );
}
function getLink(payload) {
  var _a9, _b, _c2;
  var link = (_b = (_a9 = payload.fcmOptions) === null || _a9 === void 0 ? void 0 : _a9.link) !== null && _b !== void 0 ? _b : (_c2 = payload.notification) === null || _c2 === void 0 ? void 0 : _c2.click_action;
  if (link) {
    return link;
  }
  if (isConsoleMessage(payload.data)) {
    return self.location.origin;
  } else {
    return null;
  }
}
var WindowController = (
  /** @class */
  function() {
    function WindowController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.vapidKey = null;
      this.onMessageCallback = null;
      navigator.serviceWorker.addEventListener("message", function(e) {
        return _this.messageEventListener(e);
      });
    }
    Object.defineProperty(WindowController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    WindowController2.prototype.messageEventListener = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, dataPayload;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              internalPayload = event.data;
              if (!internalPayload.isFirebaseMessaging) {
                return [
                  2
                  /*return*/
                ];
              }
              if (this.onMessageCallback && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
                if (typeof this.onMessageCallback === "function") {
                  this.onMessageCallback(stripInternalFields(Object.assign({}, internalPayload)));
                } else {
                  this.onMessageCallback.next(Object.assign({}, internalPayload));
                }
              }
              dataPayload = internalPayload.data;
              if (!(isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1"))
                return [3, 2];
              return [4, this.logEvent(internalPayload.messageType, dataPayload)];
            case 1:
              _a9.sent();
              _a9.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.getVapidKey = function() {
      return this.vapidKey;
    };
    WindowController2.prototype.getSwReg = function() {
      return this.swRegistration;
    };
    WindowController2.prototype.getToken = function(options) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              if (!(Notification.permission === "default"))
                return [3, 2];
              return [4, Notification.requestPermission()];
            case 1:
              _a9.sent();
              _a9.label = 2;
            case 2:
              if (Notification.permission !== "granted") {
                throw ERROR_FACTORY3.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              }
              return [4, this.updateVapidKey(options === null || options === void 0 ? void 0 : options.vapidKey)];
            case 3:
              _a9.sent();
              return [4, this.updateSwReg(options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration)];
            case 4:
              _a9.sent();
              return [2, getToken2(this.firebaseDependencies, this.swRegistration, this.vapidKey)];
          }
        });
      });
    };
    WindowController2.prototype.updateVapidKey = function(vapidKey) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          if (!!vapidKey) {
            this.vapidKey = vapidKey;
          } else if (!this.vapidKey) {
            this.vapidKey = DEFAULT_VAPID_KEY;
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    WindowController2.prototype.updateSwReg = function(swRegistration) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              if (!(!swRegistration && !this.swRegistration))
                return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a9.sent();
              _a9.label = 2;
            case 2:
              if (!swRegistration && !!this.swRegistration) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!(swRegistration instanceof ServiceWorkerRegistration)) {
                throw ERROR_FACTORY3.create(
                  "invalid-sw-registration"
                  /* INVALID_SW_REGISTRATION */
                );
              }
              this.swRegistration = swRegistration;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.registerDefaultSw = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a9, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 2, , 3]);
              _a9 = this;
              return [4, navigator.serviceWorker.register(DEFAULT_SW_PATH, {
                scope: DEFAULT_SW_SCOPE
              })];
            case 1:
              _a9.swRegistration = _b.sent();
              this.swRegistration.update().catch(function() {
              });
              return [3, 3];
            case 2:
              e_1 = _b.sent();
              throw ERROR_FACTORY3.create("failed-service-worker-registration", {
                browserErrorMessage: e_1.message
              });
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.deleteToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              if (!!this.swRegistration)
                return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a9.sent();
              _a9.label = 2;
            case 2:
              return [2, deleteToken(this.firebaseDependencies, this.swRegistration)];
          }
        });
      });
    };
    WindowController2.prototype.requestPermission = function() {
      return __awaiter(this, void 0, void 0, function() {
        var permissionResult;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              if (Notification.permission === "granted") {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, Notification.requestPermission()];
            case 1:
              permissionResult = _a9.sent();
              if (permissionResult === "granted") {
                return [
                  2
                  /*return*/
                ];
              } else if (permissionResult === "denied") {
                throw ERROR_FACTORY3.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              } else {
                throw ERROR_FACTORY3.create(
                  "permission-default"
                  /* PERMISSION_DEFAULT */
                );
              }
          }
        });
      });
    };
    WindowController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY3.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY3.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    WindowController2.prototype.useServiceWorker = function(swRegistration) {
      if (!(swRegistration instanceof ServiceWorkerRegistration)) {
        throw ERROR_FACTORY3.create(
          "invalid-sw-registration"
          /* INVALID_SW_REGISTRATION */
        );
      }
      if (this.swRegistration) {
        throw ERROR_FACTORY3.create(
          "use-sw-after-get-token"
          /* USE_SW_AFTER_GET_TOKEN */
        );
      }
      this.swRegistration = swRegistration;
    };
    WindowController2.prototype.onMessage = function(nextOrObserver) {
      var _this = this;
      this.onMessageCallback = nextOrObserver;
      return function() {
        _this.onMessageCallback = null;
      };
    };
    WindowController2.prototype.setBackgroundMessageHandler = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onBackgroundMessage = function() {
      throw ERROR_FACTORY3.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onTokenRefresh = function() {
      return function() {
      };
    };
    WindowController2.prototype.logEvent = function(messageType, data) {
      return __awaiter(this, void 0, void 0, function() {
        var eventType, analytics;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              eventType = getEventType(messageType);
              return [4, this.firebaseDependencies.analyticsProvider.get()];
            case 1:
              analytics = _a9.sent();
              analytics.logEvent(eventType, {
                /* eslint-disable camelcase */
                message_id: data[CONSOLE_CAMPAIGN_ID],
                message_name: data[CONSOLE_CAMPAIGN_NAME],
                message_time: data[CONSOLE_CAMPAIGN_TIME],
                message_device_time: Math.floor(Date.now() / 1e3)
                /* eslint-enable camelcase */
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return WindowController2;
  }()
);
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
function stripInternalFields(internalPayload) {
  delete internalPayload.messageType;
  delete internalPayload.isFirebaseMessaging;
  return internalPayload;
}
function extractAppConfig2(app) {
  var e_1, _a9;
  if (!app || !app.options) {
    throw getMissingValueError2("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError2("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  var options = app.options;
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!options[keyName]) {
        throw getMissingValueError2(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a9 = configKeys_1.return))
        _a9.call(configKeys_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError2(valueName) {
  return ERROR_FACTORY3.create("missing-app-config-values", {
    valueName
  });
}
var MESSAGING_NAME = "messaging";
function factoryMethod(container) {
  var app = container.getProvider("app").getImmediate();
  var appConfig = extractAppConfig2(app);
  var installations = container.getProvider("installations").getImmediate();
  var analyticsProvider = container.getProvider("analytics-internal");
  var firebaseDependencies = {
    app,
    appConfig,
    installations,
    analyticsProvider
  };
  if (!isSupported()) {
    throw ERROR_FACTORY3.create(
      "unsupported-browser"
      /* UNSUPPORTED_BROWSER */
    );
  }
  if (self && "ServiceWorkerGlobalScope" in self) {
    return new SwController(firebaseDependencies);
  } else {
    return new WindowController(firebaseDependencies);
  }
}
var NAMESPACE_EXPORTS = {
  isSupported
};
index_esm_default.INTERNAL.registerComponent(new Component(
  MESSAGING_NAME,
  factoryMethod,
  "PUBLIC"
  /* PUBLIC */
).setServiceProps(NAMESPACE_EXPORTS));
function isSupported() {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return isSWControllerSupported();
  } else {
    return isWindowControllerSupported();
  }
}
function isWindowControllerSupported() {
  return "indexedDB" in window && indexedDB !== null && navigator.cookieEnabled && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
function isSWControllerSupported() {
  return "indexedDB" in self && indexedDB !== null && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}

// node_modules/@firebase/storage/dist/index.esm.js
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var FirebaseStorageError = (
  /** @class */
  function(_super) {
    __extends(FirebaseStorageError2, _super);
    function FirebaseStorageError2(code, message) {
      var _this = _super.call(this, prependCode(code), "Firebase Storage: " + message + " (" + prependCode(code) + ")") || this;
      _this.customData = { serverResponse: null };
      Object.setPrototypeOf(_this, FirebaseStorageError2.prototype);
      return _this;
    }
    FirebaseStorageError2.prototype._codeEquals = function(code) {
      return prependCode(code) === this.code;
    };
    Object.defineProperty(FirebaseStorageError2.prototype, "message", {
      /**
       * Error message including serverResponse if available.
       */
      get: function() {
        if (this.customData.serverResponse) {
          return this.message + "\n" + this.customData.serverResponse;
        } else {
          return this.message;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageError2.prototype, "serverResponse", {
      /**
       * Optional response message that was added by the server.
       */
      get: function() {
        return this.customData.serverResponse;
      },
      set: function(serverResponse) {
        this.customData.serverResponse = serverResponse;
      },
      enumerable: false,
      configurable: true
    });
    return FirebaseStorageError2;
  }(FirebaseError)
);
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  var message = "An unknown error occurred, please check the error payload for server response.";
  return new FirebaseStorageError("unknown", message);
}
function objectNotFound(path) {
  return new FirebaseStorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new FirebaseStorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  var message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new FirebaseStorageError("unauthenticated", message);
}
function unauthorized(path) {
  return new FirebaseStorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new FirebaseStorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new FirebaseStorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new FirebaseStorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new FirebaseStorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new FirebaseStorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new FirebaseStorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new FirebaseStorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new FirebaseStorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new FirebaseStorageError("invalid-argument", message);
}
function appDeleted() {
  return new FirebaseStorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name10) {
  return new FirebaseStorageError("invalid-root-operation", "The operation '" + name10 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new FirebaseStorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new FirebaseStorageError("internal-error", "Internal error: " + message);
}
var StringFormat = {
  /**
   * Indicates the string should be interpreted "raw", that is, as normal text.
   * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte
   * sequence.
   * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence
   * 48 65 6c 6c 6f 21 20 f0 9f 98 8a
   */
  RAW: "raw",
  /**
   * Indicates the string should be interpreted as base64-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64: "base64",
  /**
   * Indicates the string should be interpreted as base64url-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64URL: "base64url",
  /**
   * Indicates the string is a data URL, such as one obtained from
   * canvas.toDataURL().
   * Example: the string 'data:application/octet-stream;base64,aaaa'
   * becomes the byte sequence
   * 69 a6 9a
   * (the content-type "application/octet-stream" is also applied, but can
   * be overridden in the metadata object).
   */
  DATA_URL: "data_url"
};
var StringData = (
  /** @class */
  /* @__PURE__ */ function() {
    function StringData2(data, contentType) {
      this.data = data;
      this.contentType = contentType || null;
    }
    return StringData2;
  }()
);
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  var b = [];
  for (var i = 0; i < value.length; i++) {
    var c = value.charCodeAt(i);
    if (c <= 127) {
      b.push(c);
    } else {
      if (c <= 2047) {
        b.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          var valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
          if (!valid) {
            b.push(239, 191, 189);
          } else {
            var hi2 = c;
            var lo2 = value.charCodeAt(++i);
            c = 65536 | (hi2 & 1023) << 10 | lo2 & 1023;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b.push(239, 191, 189);
          } else {
            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
  var decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      var hasMinus = value.indexOf("-") !== -1;
      var hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        var invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      var hasPlus = value.indexOf("+") !== -1;
      var hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        var invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  var bytes;
  try {
    bytes = atob(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  var array = new Uint8Array(bytes.length);
  for (var i = 0; i < bytes.length; i++) {
    array[i] = bytes.charCodeAt(i);
  }
  return array;
}
var DataURLParts = (
  /** @class */
  /* @__PURE__ */ function() {
    function DataURLParts2(dataURL) {
      this.base64 = false;
      this.contentType = null;
      var matches = dataURL.match(/^data:([^,]+)?,/);
      if (matches === null) {
        throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
      }
      var middle = matches[1] || null;
      if (middle != null) {
        this.base64 = endsWith(middle, ";base64");
        this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
      }
      this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
    }
    return DataURLParts2;
  }()
);
function dataURLBytes_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  var longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var TaskEvent = {
  /**
   * For this event,
   * <ul>
   *   <li>The `next` function is triggered on progress updates and when the
   *       task is paused/resumed with an `UploadTaskSnapshot` as the first
   *       argument.</li>
   *   <li>The `error` function is triggered if the upload is canceled or fails
   *       for another reason.</li>
   *   <li>The `complete` function is triggered if the upload completes
   *       successfully.</li>
   * </ul>
   */
  STATE_CHANGED: "state_changed"
};
var TaskState = {
  /** The task is currently transferring data. */
  RUNNING: "running",
  /** The task was paused by the user. */
  PAUSED: "paused",
  /** The task completed successfully. */
  SUCCESS: "success",
  /** The task was canceled. */
  CANCELED: "canceled",
  /** The task failed with an error. */
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case "running":
    case "pausing":
    case "canceling":
      return TaskState.RUNNING;
    case "paused":
      return TaskState.PAUSED;
    case "success":
      return TaskState.SUCCESS;
    case "canceled":
      return TaskState.CANCELED;
    case "error":
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
var ErrorCode2;
(function(ErrorCode3) {
  ErrorCode3[ErrorCode3["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode3[ErrorCode3["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode3[ErrorCode3["ABORT"] = 2] = "ABORT";
})(ErrorCode2 || (ErrorCode2 = {}));
var NetworkXhrIo = (
  /** @class */
  function() {
    function NetworkXhrIo2() {
      var _this = this;
      this.sent_ = false;
      this.xhr_ = new XMLHttpRequest();
      this.errorCode_ = ErrorCode2.NO_ERROR;
      this.sendPromise_ = new Promise(function(resolve) {
        _this.xhr_.addEventListener("abort", function() {
          _this.errorCode_ = ErrorCode2.ABORT;
          resolve(_this);
        });
        _this.xhr_.addEventListener("error", function() {
          _this.errorCode_ = ErrorCode2.NETWORK_ERROR;
          resolve(_this);
        });
        _this.xhr_.addEventListener("load", function() {
          resolve(_this);
        });
      });
    }
    NetworkXhrIo2.prototype.send = function(url, method, body, headers) {
      if (this.sent_) {
        throw internalError("cannot .send() more than once");
      }
      this.sent_ = true;
      this.xhr_.open(method, url, true);
      if (headers !== void 0) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            this.xhr_.setRequestHeader(key, headers[key].toString());
          }
        }
      }
      if (body !== void 0) {
        this.xhr_.send(body);
      } else {
        this.xhr_.send();
      }
      return this.sendPromise_;
    };
    NetworkXhrIo2.prototype.getErrorCode = function() {
      if (!this.sent_) {
        throw internalError("cannot .getErrorCode() before sending");
      }
      return this.errorCode_;
    };
    NetworkXhrIo2.prototype.getStatus = function() {
      if (!this.sent_) {
        throw internalError("cannot .getStatus() before sending");
      }
      try {
        return this.xhr_.status;
      } catch (e) {
        return -1;
      }
    };
    NetworkXhrIo2.prototype.getResponseText = function() {
      if (!this.sent_) {
        throw internalError("cannot .getResponseText() before sending");
      }
      return this.xhr_.responseText;
    };
    NetworkXhrIo2.prototype.abort = function() {
      this.xhr_.abort();
    };
    NetworkXhrIo2.prototype.getResponseHeader = function(header) {
      return this.xhr_.getResponseHeader(header);
    };
    NetworkXhrIo2.prototype.addUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.addEventListener("progress", listener);
      }
    };
    NetworkXhrIo2.prototype.removeUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.removeEventListener("progress", listener);
      }
    };
    return NetworkXhrIo2;
  }()
);
var XhrIoPool = (
  /** @class */
  function() {
    function XhrIoPool2() {
    }
    XhrIoPool2.prototype.createXhrIo = function() {
      return new NetworkXhrIo();
    };
    return XhrIoPool2;
  }()
);
var Location = (
  /** @class */
  function() {
    function Location2(bucket, path) {
      this.bucket = bucket;
      this.path_ = path;
    }
    Object.defineProperty(Location2.prototype, "path", {
      get: function() {
        return this.path_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Location2.prototype, "isRoot", {
      get: function() {
        return this.path.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Location2.prototype.fullServerUrl = function() {
      var encode2 = encodeURIComponent;
      return "/b/" + encode2(this.bucket) + "/o/" + encode2(this.path);
    };
    Location2.prototype.bucketOnlyServerUrl = function() {
      var encode2 = encodeURIComponent;
      return "/b/" + encode2(this.bucket) + "/o";
    };
    Location2.makeFromBucketSpec = function(bucketString) {
      var bucketLocation;
      try {
        bucketLocation = Location2.makeFromUrl(bucketString);
      } catch (e) {
        return new Location2(bucketString, "");
      }
      if (bucketLocation.path === "") {
        return bucketLocation;
      } else {
        throw invalidDefaultBucket(bucketString);
      }
    };
    Location2.makeFromUrl = function(url) {
      var location2 = null;
      var bucketDomain = "([A-Za-z0-9.\\-_]+)";
      function gsModify(loc) {
        if (loc.path.charAt(loc.path.length - 1) === "/") {
          loc.path_ = loc.path_.slice(0, -1);
        }
      }
      var gsPath = "(/(.*))?$";
      var gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
      var gsIndices = { bucket: 1, path: 3 };
      function httpModify(loc) {
        loc.path_ = decodeURIComponent(loc.path);
      }
      var version10 = "v[A-Za-z0-9_]+";
      var firebaseStorageHost = DEFAULT_HOST.replace(/[.]/g, "\\.");
      var firebaseStoragePath = "(/([^?#]*).*)?$";
      var firebaseStorageRegExp = new RegExp("^https?://" + firebaseStorageHost + "/" + version10 + "/b/" + bucketDomain + "/o" + firebaseStoragePath, "i");
      var firebaseStorageIndices = { bucket: 1, path: 3 };
      var cloudStorageHost = "(?:storage.googleapis.com|storage.cloud.google.com)";
      var cloudStoragePath = "([^?#]*)";
      var cloudStorageRegExp = new RegExp("^https?://" + cloudStorageHost + "/" + bucketDomain + "/" + cloudStoragePath, "i");
      var cloudStorageIndices = { bucket: 1, path: 2 };
      var groups = [
        { regex: gsRegex, indices: gsIndices, postModify: gsModify },
        {
          regex: firebaseStorageRegExp,
          indices: firebaseStorageIndices,
          postModify: httpModify
        },
        {
          regex: cloudStorageRegExp,
          indices: cloudStorageIndices,
          postModify: httpModify
        }
      ];
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var captures = group.regex.exec(url);
        if (captures) {
          var bucketValue = captures[group.indices.bucket];
          var pathValue = captures[group.indices.path];
          if (!pathValue) {
            pathValue = "";
          }
          location2 = new Location2(bucketValue, pathValue);
          group.postModify(location2);
          break;
        }
      }
      if (location2 == null) {
        throw invalidUrl(url);
      }
      return location2;
    };
    return Location2;
  }()
);
var FailRequest = (
  /** @class */
  function() {
    function FailRequest2(error2) {
      this.promise_ = Promise.reject(error2);
    }
    FailRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    FailRequest2.prototype.cancel = function(_appDelete) {
    };
    return FailRequest2;
  }()
);
function start(f, callback, timeout) {
  var waitSeconds = 1;
  var timeoutId = null;
  var hitTimeout = false;
  var cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  var triggeredCallback = false;
  function triggerCallback() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    timeoutId = setTimeout(function() {
      timeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function handler(success) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    if (triggeredCallback) {
      return;
    }
    if (success) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    var mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    var waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  var stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    if (triggeredCallback) {
      return;
    }
    if (timeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(timeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  setTimeout(function() {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id2) {
  id2(false);
}
function isJustDef(p2) {
  return p2 !== void 0;
}
function isFunction(p2) {
  return typeof p2 === "function";
}
function isNonArrayObject(p2) {
  return typeof p2 === "object" && !Array.isArray(p2);
}
function isString(p2) {
  return typeof p2 === "string" || p2 instanceof String;
}
function isNativeBlob(p2) {
  return isNativeBlobDefined() && p2 instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + minValue + " or greater.");
  }
  if (value > maxValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + maxValue + " or less.");
  }
}
function makeUrl(urlPart) {
  return "https://" + DEFAULT_HOST + "/v0" + urlPart;
}
function makeQueryString(params) {
  var encode2 = encodeURIComponent;
  var queryPart = "?";
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var nextPart = encode2(key) + "=" + encode2(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var NetworkRequest = (
  /** @class */
  function() {
    function NetworkRequest2(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
      var _this = this;
      this.pendingXhr_ = null;
      this.backoffId_ = null;
      this.canceled_ = false;
      this.appDelete_ = false;
      this.url_ = url;
      this.method_ = method;
      this.headers_ = headers;
      this.body_ = body;
      this.successCodes_ = successCodes.slice();
      this.additionalRetryCodes_ = additionalRetryCodes.slice();
      this.callback_ = callback;
      this.errorCallback_ = errorCallback;
      this.progressCallback_ = progressCallback;
      this.timeout_ = timeout;
      this.pool_ = pool;
      this.promise_ = new Promise(function(resolve, reject) {
        _this.resolve_ = resolve;
        _this.reject_ = reject;
        _this.start_();
      });
    }
    NetworkRequest2.prototype.start_ = function() {
      var self2 = this;
      function doTheRequest(backoffCallback, canceled2) {
        if (canceled2) {
          backoffCallback(false, new RequestEndStatus(false, null, true));
          return;
        }
        var xhr = self2.pool_.createXhrIo();
        self2.pendingXhr_ = xhr;
        function progressListener(progressEvent) {
          var loaded = progressEvent.loaded;
          var total = progressEvent.lengthComputable ? progressEvent.total : -1;
          if (self2.progressCallback_ !== null) {
            self2.progressCallback_(loaded, total);
          }
        }
        if (self2.progressCallback_ !== null) {
          xhr.addUploadProgressListener(progressListener);
        }
        xhr.send(self2.url_, self2.method_, self2.body_, self2.headers_).then(function(xhr2) {
          if (self2.progressCallback_ !== null) {
            xhr2.removeUploadProgressListener(progressListener);
          }
          self2.pendingXhr_ = null;
          xhr2 = xhr2;
          var hitServer = xhr2.getErrorCode() === ErrorCode2.NO_ERROR;
          var status = xhr2.getStatus();
          if (!hitServer || self2.isRetryStatusCode_(status)) {
            var wasCanceled = xhr2.getErrorCode() === ErrorCode2.ABORT;
            backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
            return;
          }
          var successCode = self2.successCodes_.indexOf(status) !== -1;
          backoffCallback(true, new RequestEndStatus(successCode, xhr2));
        });
      }
      function backoffDone(requestWentThrough, status) {
        var resolve = self2.resolve_;
        var reject = self2.reject_;
        var xhr = status.xhr;
        if (status.wasSuccessCode) {
          try {
            var result = self2.callback_(xhr, xhr.getResponseText());
            if (isJustDef(result)) {
              resolve(result);
            } else {
              resolve();
            }
          } catch (e) {
            reject(e);
          }
        } else {
          if (xhr !== null) {
            var err = unknown();
            err.serverResponse = xhr.getResponseText();
            if (self2.errorCallback_) {
              reject(self2.errorCallback_(xhr, err));
            } else {
              reject(err);
            }
          } else {
            if (status.canceled) {
              var err = self2.appDelete_ ? appDeleted() : canceled();
              reject(err);
            } else {
              var err = retryLimitExceeded();
              reject(err);
            }
          }
        }
      }
      if (this.canceled_) {
        backoffDone(false, new RequestEndStatus(false, null, true));
      } else {
        this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      }
    };
    NetworkRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    NetworkRequest2.prototype.cancel = function(appDelete) {
      this.canceled_ = true;
      this.appDelete_ = appDelete || false;
      if (this.backoffId_ !== null) {
        stop(this.backoffId_);
      }
      if (this.pendingXhr_ !== null) {
        this.pendingXhr_.abort();
      }
    };
    NetworkRequest2.prototype.isRetryStatusCode_ = function(status) {
      var isFiveHundredCode = status >= 500 && status < 600;
      var extraRetryCodes = [
        // Request Timeout: web server didn't receive full request in time.
        408,
        // Too Many Requests: you're getting rate-limited, basically.
        429
      ];
      var isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
      var isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
      return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest2;
  }()
);
var RequestEndStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestEndStatus2(wasSuccessCode, xhr, canceled2) {
      this.wasSuccessCode = wasSuccessCode;
      this.xhr = xhr;
      this.canceled = !!canceled2;
    }
    return RequestEndStatus2;
  }()
);
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function makeRequest(requestInfo, appId, authToken, pool, firebaseVersion) {
  var queryPart = makeQueryString(requestInfo.urlParams);
  var url = requestInfo.url + queryPart;
  var headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    var bb2 = new BlobBuilder2();
    for (var i = 0; i < args.length; i++) {
      bb2.append(args[i]);
    }
    return bb2.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new FirebaseStorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
var FbsBlob = (
  /** @class */
  function() {
    function FbsBlob2(data, elideCopy) {
      var size = 0;
      var blobType = "";
      if (isNativeBlob(data)) {
        this.data_ = data;
        size = data.size;
        blobType = data.type;
      } else if (data instanceof ArrayBuffer) {
        if (elideCopy) {
          this.data_ = new Uint8Array(data);
        } else {
          this.data_ = new Uint8Array(data.byteLength);
          this.data_.set(new Uint8Array(data));
        }
        size = this.data_.length;
      } else if (data instanceof Uint8Array) {
        if (elideCopy) {
          this.data_ = data;
        } else {
          this.data_ = new Uint8Array(data.length);
          this.data_.set(data);
        }
        size = data.length;
      }
      this.size_ = size;
      this.type_ = blobType;
    }
    FbsBlob2.prototype.size = function() {
      return this.size_;
    };
    FbsBlob2.prototype.type = function() {
      return this.type_;
    };
    FbsBlob2.prototype.slice = function(startByte, endByte) {
      if (isNativeBlob(this.data_)) {
        var realBlob = this.data_;
        var sliced = sliceBlob(realBlob, startByte, endByte);
        if (sliced === null) {
          return null;
        }
        return new FbsBlob2(sliced);
      } else {
        var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
        return new FbsBlob2(slice, true);
      }
    };
    FbsBlob2.getBlob = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      if (isNativeBlobDefined()) {
        var blobby = args.map(function(val) {
          if (val instanceof FbsBlob2) {
            return val.data_;
          } else {
            return val;
          }
        });
        return new FbsBlob2(getBlob.apply(null, blobby));
      } else {
        var uint8Arrays = args.map(function(val) {
          if (isString(val)) {
            return dataFromString(StringFormat.RAW, val).data;
          } else {
            return val.data_;
          }
        });
        var finalLength_1 = 0;
        uint8Arrays.forEach(function(array) {
          finalLength_1 += array.byteLength;
        });
        var merged_1 = new Uint8Array(finalLength_1);
        var index_1 = 0;
        uint8Arrays.forEach(function(array) {
          for (var i = 0; i < array.length; i++) {
            merged_1[index_1++] = array[i];
          }
        });
        return new FbsBlob2(merged_1, true);
      }
    };
    FbsBlob2.prototype.uploadData = function() {
      return this.data_;
    };
    return FbsBlob2;
  }()
);
function jsonObjectOrNull(s) {
  var obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  var index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  var newPath = path.slice(0, index);
  return newPath;
}
function child(path, childPath) {
  var canonicalChildPath = childPath.split("/").filter(function(component) {
    return component.length > 0;
  }).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  var index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mapping2(server, local, writable, xform) {
      this.server = server;
      this.local = local || server;
      this.writable = !!writable;
      this.xform = xform || noXform_;
    }
    return Mapping2;
  }()
);
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  var mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  var nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  var sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  var metadata = {};
  metadata["type"] = "file";
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  var tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  var encode2 = encodeURIComponent;
  var tokensList = tokens.split(",");
  var urls = tokensList.map(function(token) {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var urlPart = "/b/" + encode2(bucket) + "/o/" + encode2(path);
    var base = makeUrl(urlPart);
    var queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  var resource = {};
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  var listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (var _i2 = 0, _a9 = resource[PREFIXES_KEY]; _i2 < _a9.length; _i2++) {
      var path = _a9[_i2];
      var pathWithoutTrailingSlash = path.replace(/\/$/, "");
      var reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (var _b = 0, _c2 = resource[ITEMS_KEY]; _b < _c2.length; _b++) {
      var item = _c2[_b];
      var reference = service._makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
var RequestInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestInfo2(url, method, handler, timeout) {
      this.url = url;
      this.method = method;
      this.handler = handler;
      this.timeout = timeout;
      this.urlParams = {};
      this.headers = {};
      this.body = null;
      this.errorHandler = null;
      this.progressCallback = null;
      this.successCodes = [200];
      this.additionalRetryCodes = [];
    }
    return RequestInfo2;
  }()
);
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    var listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text);
  }
  return handler;
}
function sharedErrorHandler(location2) {
  function errorHandler(xhr, err) {
    var newErr;
    if (xhr.getStatus() === 401) {
      newErr = unauthenticated();
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location2.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location2.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location2) {
  var shared = sharedErrorHandler(location2);
  function errorHandler(xhr, err) {
    var newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location2.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getMetadata(service, location2, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function list(service, location2, delimiter, pageToken, maxResults) {
  var urlParams = {};
  if (location2.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location2.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  var urlPart = location2.bucketOnlyServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, listHandler(service, location2.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
function getDownloadUrl(service, location2, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function updateMetadata(service, location2, metadata, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "PATCH";
  var body = toResourceString(metadata, mappings);
  var headers = { "Content-Type": "application/json; charset=utf-8" };
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function deleteObject(service, location2) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart);
  var method = "DELETE";
  var timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location2, blob, metadata) {
  var metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location2.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location2, mappings, blob, metadata) {
  var urlPart = location2.bucketOnlyServerUrl();
  var headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    var str = "";
    for (var i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  var boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  var metadata_ = metadataForUpload_(location2, blob, metadata);
  var metadataString = toResourceString(metadata_, mappings);
  var preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  var postBlobPart = "\r\n--" + boundary + "--";
  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  var urlParams = { name: metadata_["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var ResumableUploadStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResumableUploadStatus2(current, total, finalized, metadata) {
      this.current = current;
      this.total = total;
      this.finalized = !!finalized;
      this.metadata = metadata || null;
    }
    return ResumableUploadStatus2;
  }()
);
function checkResumeHeader_(xhr, allowed) {
  var status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  var allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location2, mappings, blob, metadata) {
  var urlPart = location2.bucketOnlyServerUrl();
  var metadataForUpload = metadataForUpload_(location2, blob, metadata);
  var urlParams = { name: metadataForUpload["fullPath"] };
  var url = makeUrl(urlPart);
  var method = "POST";
  var headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": blob.size(),
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  var body = toResourceString(metadataForUpload, mappings);
  var timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    var url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
function getResumableUploadStatus(service, location2, url, blob) {
  var headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    var status = checkResumeHeader_(xhr, ["active", "final"]);
    var sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    var size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
function continueResumableUpload(location2, service, url, blob, chunkSize, mappings, status, progressCallback) {
  var status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  var bytesLeft = status_.total - status_.current;
  var bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  var startByte = status_.current;
  var endByte = startByte + bytesToUpload;
  var uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  var headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": status_.current
  };
  var body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    var uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    var newCurrent = status_.current + bytesToUpload;
    var size = blob.size();
    var metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var Observer = (
  /** @class */
  /* @__PURE__ */ function() {
    function Observer2(nextOrObserver, error2, complete) {
      var asFunctions = isFunction(nextOrObserver) || error2 != null || complete != null;
      if (asFunctions) {
        this.next = nextOrObserver;
        this.error = error2;
        this.complete = complete;
      } else {
        var observer = nextOrObserver;
        this.next = observer.next;
        this.error = observer.error;
        this.complete = observer.complete;
      }
    }
    return Observer2;
  }()
);
function async(f) {
  return function() {
    var argsToForward = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      argsToForward[_i2] = arguments[_i2];
    }
    Promise.resolve().then(function() {
      return f.apply(void 0, argsToForward);
    });
  };
}
var UploadTask = (
  /** @class */
  function() {
    function UploadTask2(ref2, blob, metadata) {
      var _this = this;
      if (metadata === void 0) {
        metadata = null;
      }
      this._transferred = 0;
      this._needToFetchStatus = false;
      this._needToFetchMetadata = false;
      this._observers = [];
      this._error = void 0;
      this._uploadUrl = void 0;
      this._request = void 0;
      this._chunkMultiplier = 1;
      this._resolve = void 0;
      this._reject = void 0;
      this._ref = ref2;
      this._blob = blob;
      this._metadata = metadata;
      this._mappings = getMappings();
      this._resumable = this._shouldDoResumable(this._blob);
      this._state = "running";
      this._errorHandler = function(error2) {
        _this._request = void 0;
        _this._chunkMultiplier = 1;
        if (error2._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this._needToFetchStatus = true;
          _this.completeTransitions_();
        } else {
          _this._error = error2;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._metadataErrorHandler = function(error2) {
        _this._request = void 0;
        if (error2._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this.completeTransitions_();
        } else {
          _this._error = error2;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._promise = new Promise(function(resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject;
        _this._start();
      });
      this._promise.then(null, function() {
      });
    }
    UploadTask2.prototype._makeProgressCallback = function() {
      var _this = this;
      var sizeBefore = this._transferred;
      return function(loaded) {
        return _this._updateProgress(sizeBefore + loaded);
      };
    };
    UploadTask2.prototype._shouldDoResumable = function(blob) {
      return blob.size() > 256 * 1024;
    };
    UploadTask2.prototype._start = function() {
      if (this._state !== "running") {
        return;
      }
      if (this._request !== void 0) {
        return;
      }
      if (this._resumable) {
        if (this._uploadUrl === void 0) {
          this._createResumable();
        } else {
          if (this._needToFetchStatus) {
            this._fetchStatus();
          } else {
            if (this._needToFetchMetadata) {
              this._fetchMetadata();
            } else {
              this._continueUpload();
            }
          }
        }
      } else {
        this._oneShotUpload();
      }
    };
    UploadTask2.prototype._resolveToken = function(callback) {
      var _this = this;
      this._ref.storage._getAuthToken().then(function(authToken) {
        switch (_this._state) {
          case "running":
            callback(authToken);
            break;
          case "canceling":
            _this._transition(
              "canceled"
              /* CANCELED */
            );
            break;
          case "pausing":
            _this._transition(
              "paused"
              /* PAUSED */
            );
            break;
        }
      });
    };
    UploadTask2.prototype._createResumable = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = createResumableUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var createRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = createRequest;
        createRequest.getPromise().then(function(url) {
          _this._request = void 0;
          _this._uploadUrl = url;
          _this._needToFetchStatus = false;
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._fetchStatus = function() {
      var _this = this;
      var url = this._uploadUrl;
      this._resolveToken(function(authToken) {
        var requestInfo = getResumableUploadStatus(_this._ref.storage, _this._ref._location, url, _this._blob);
        var statusRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = statusRequest;
        statusRequest.getPromise().then(function(status) {
          status = status;
          _this._request = void 0;
          _this._updateProgress(status.current);
          _this._needToFetchStatus = false;
          if (status.finalized) {
            _this._needToFetchMetadata = true;
          }
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._continueUpload = function() {
      var _this = this;
      var chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      var status = new ResumableUploadStatus(this._transferred, this._blob.size());
      var url = this._uploadUrl;
      this._resolveToken(function(authToken) {
        var requestInfo;
        try {
          requestInfo = continueResumableUpload(_this._ref._location, _this._ref.storage, url, _this._blob, chunkSize, _this._mappings, status, _this._makeProgressCallback());
        } catch (e) {
          _this._error = e;
          _this._transition(
            "error"
            /* ERROR */
          );
          return;
        }
        var uploadRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = uploadRequest;
        uploadRequest.getPromise().then(function(newStatus) {
          _this._increaseMultiplier();
          _this._request = void 0;
          _this._updateProgress(newStatus.current);
          if (newStatus.finalized) {
            _this._metadata = newStatus.metadata;
            _this._transition(
              "success"
              /* SUCCESS */
            );
          } else {
            _this.completeTransitions_();
          }
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._increaseMultiplier = function() {
      var currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      if (currentSize < 32 * 1024 * 1024) {
        this._chunkMultiplier *= 2;
      }
    };
    UploadTask2.prototype._fetchMetadata = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = getMetadata(_this._ref.storage, _this._ref._location, _this._mappings);
        var metadataRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = metadataRequest;
        metadataRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._metadataErrorHandler);
      });
    };
    UploadTask2.prototype._oneShotUpload = function() {
      var _this = this;
      this._resolveToken(function(authToken) {
        var requestInfo = multipartUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var multipartRequest = _this._ref.storage._makeRequest(requestInfo, authToken);
        _this._request = multipartRequest;
        multipartRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._updateProgress(_this._blob.size());
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._updateProgress = function(transferred) {
      var old = this._transferred;
      this._transferred = transferred;
      if (this._transferred !== old) {
        this._notifyObservers();
      }
    };
    UploadTask2.prototype._transition = function(state) {
      if (this._state === state) {
        return;
      }
      switch (state) {
        case "canceling":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "pausing":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "running":
          var wasPaused = this._state === "paused";
          this._state = state;
          if (wasPaused) {
            this._notifyObservers();
            this._start();
          }
          break;
        case "paused":
          this._state = state;
          this._notifyObservers();
          break;
        case "canceled":
          this._error = canceled();
          this._state = state;
          this._notifyObservers();
          break;
        case "error":
          this._state = state;
          this._notifyObservers();
          break;
        case "success":
          this._state = state;
          this._notifyObservers();
          break;
      }
    };
    UploadTask2.prototype.completeTransitions_ = function() {
      switch (this._state) {
        case "pausing":
          this._transition(
            "paused"
            /* PAUSED */
          );
          break;
        case "canceling":
          this._transition(
            "canceled"
            /* CANCELED */
          );
          break;
        case "running":
          this._start();
          break;
      }
    };
    Object.defineProperty(UploadTask2.prototype, "snapshot", {
      /**
       * A snapshot of the current task state.
       */
      get: function() {
        var externalState = taskStateFromInternalTaskState(this._state);
        return {
          bytesTransferred: this._transferred,
          totalBytes: this._blob.size(),
          state: externalState,
          metadata: this._metadata,
          task: this,
          ref: this._ref
        };
      },
      enumerable: false,
      configurable: true
    });
    UploadTask2.prototype.on = function(type, nextOrObserver, error2, completed) {
      var _this = this;
      var observer = new Observer(nextOrObserver, error2, completed);
      this._addObserver(observer);
      return function() {
        _this._removeObserver(observer);
      };
    };
    UploadTask2.prototype.then = function(onFulfilled, onRejected) {
      return this._promise.then(onFulfilled, onRejected);
    };
    UploadTask2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    UploadTask2.prototype._addObserver = function(observer) {
      this._observers.push(observer);
      this._notifyObserver(observer);
    };
    UploadTask2.prototype._removeObserver = function(observer) {
      var i = this._observers.indexOf(observer);
      if (i !== -1) {
        this._observers.splice(i, 1);
      }
    };
    UploadTask2.prototype._notifyObservers = function() {
      var _this = this;
      this._finishPromise();
      var observers = this._observers.slice();
      observers.forEach(function(observer) {
        _this._notifyObserver(observer);
      });
    };
    UploadTask2.prototype._finishPromise = function() {
      if (this._resolve !== void 0) {
        var triggered = true;
        switch (taskStateFromInternalTaskState(this._state)) {
          case TaskState.SUCCESS:
            async(this._resolve.bind(null, this.snapshot))();
            break;
          case TaskState.CANCELED:
          case TaskState.ERROR:
            var toCall = this._reject;
            async(toCall.bind(null, this._error))();
            break;
          default:
            triggered = false;
            break;
        }
        if (triggered) {
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
    };
    UploadTask2.prototype._notifyObserver = function(observer) {
      var externalState = taskStateFromInternalTaskState(this._state);
      switch (externalState) {
        case TaskState.RUNNING:
        case TaskState.PAUSED:
          if (observer.next) {
            async(observer.next.bind(observer, this.snapshot))();
          }
          break;
        case TaskState.SUCCESS:
          if (observer.complete) {
            async(observer.complete.bind(observer))();
          }
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
          break;
        default:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
      }
    };
    UploadTask2.prototype.resume = function() {
      var valid = this._state === "paused" || this._state === "pausing";
      if (valid) {
        this._transition(
          "running"
          /* RUNNING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.pause = function() {
      var valid = this._state === "running";
      if (valid) {
        this._transition(
          "pausing"
          /* PAUSING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.cancel = function() {
      var valid = this._state === "running" || this._state === "pausing";
      if (valid) {
        this._transition(
          "canceling"
          /* CANCELING */
        );
      }
      return valid;
    };
    return UploadTask2;
  }()
);
var Reference2 = (
  /** @class */
  function() {
    function Reference3(_service, location2) {
      this._service = _service;
      if (location2 instanceof Location) {
        this._location = location2;
      } else {
        this._location = Location.makeFromUrl(location2);
      }
    }
    Reference3.prototype.toString = function() {
      return "gs://" + this._location.bucket + "/" + this._location.path;
    };
    Reference3.prototype._newRef = function(service, location2) {
      return new Reference3(service, location2);
    };
    Object.defineProperty(Reference3.prototype, "root", {
      /**
       * A reference to the root of this object's bucket.
       */
      get: function() {
        var location2 = new Location(this._location.bucket, "");
        return this._newRef(this._service, location2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "bucket", {
      /**
       * The name of the bucket containing this reference's object.
       */
      get: function() {
        return this._location.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "fullPath", {
      /**
       * The full path of this object.
       */
      get: function() {
        return this._location.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "name", {
      /**
       * The short name of this object, which is the last component of the full path.
       * For example, if fullPath is 'full/path/image.png', name is 'image.png'.
       */
      get: function() {
        return lastComponent(this._location.path);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "storage", {
      /**
       * The `StorageService` instance this `StorageReference` is associated with.
       */
      get: function() {
        return this._service;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "parent", {
      /**
       * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
       * this reference is the root.
       */
      get: function() {
        var newPath = parent(this._location.path);
        if (newPath === null) {
          return null;
        }
        var location2 = new Location(this._location.bucket, newPath);
        return new Reference3(this._service, location2);
      },
      enumerable: false,
      configurable: true
    });
    Reference3.prototype._throwIfRoot = function(name10) {
      if (this._location.path === "") {
        throw invalidRootOperation(name10);
      }
    };
    return Reference3;
  }()
);
function uploadBytesResumable(ref2, data, metadata) {
  ref2._throwIfRoot("uploadBytesResumable");
  return new UploadTask(ref2, new FbsBlob(data), metadata);
}
function listAll(ref2) {
  var accumulator = {
    prefixes: [],
    items: []
  };
  return listAllHelper(ref2, accumulator).then(function() {
    return accumulator;
  });
}
function listAllHelper(ref2, accumulator, pageToken) {
  return __awaiter(this, void 0, void 0, function() {
    var opt, nextPage;
    var _a9, _b;
    return __generator(this, function(_c2) {
      switch (_c2.label) {
        case 0:
          opt = {
            // maxResults is 1000 by default.
            pageToken
          };
          return [4, list$1(ref2, opt)];
        case 1:
          nextPage = _c2.sent();
          (_a9 = accumulator.prefixes).push.apply(_a9, nextPage.prefixes);
          (_b = accumulator.items).push.apply(_b, nextPage.items);
          if (!(nextPage.nextPageToken != null))
            return [3, 3];
          return [4, listAllHelper(ref2, accumulator, nextPage.nextPageToken)];
        case 2:
          _c2.sent();
          _c2.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function list$1(ref2, options) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, op, requestInfo;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (options != null) {
            if (typeof options.maxResults === "number") {
              validateNumber(
                "options.maxResults",
                /* minValue= */
                1,
                /* maxValue= */
                1e3,
                options.maxResults
              );
            }
          }
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a9.sent();
          op = options || {};
          requestInfo = list(
            ref2.storage,
            ref2._location,
            /*delimiter= */
            "/",
            op.pageToken,
            op.maxResults
          );
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function getMetadata$1(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          ref2._throwIfRoot("getMetadata");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a9.sent();
          requestInfo = getMetadata(ref2.storage, ref2._location, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function updateMetadata$1(ref2, metadata) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          ref2._throwIfRoot("updateMetadata");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a9.sent();
          requestInfo = updateMetadata(ref2.storage, ref2._location, metadata, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function getDownloadURL(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          ref2._throwIfRoot("getDownloadURL");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a9.sent();
          requestInfo = getDownloadUrl(ref2.storage, ref2._location, getMappings());
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise().then(function(url) {
            if (url === null) {
              throw noDownloadURL();
            }
            return url;
          })];
      }
    });
  });
}
function deleteObject$1(ref2) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, requestInfo;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          ref2._throwIfRoot("deleteObject");
          return [4, ref2.storage._getAuthToken()];
        case 1:
          authToken = _a9.sent();
          requestInfo = deleteObject(ref2.storage, ref2._location);
          return [2, ref2.storage._makeRequest(requestInfo, authToken).getPromise()];
      }
    });
  });
}
function _getChild(ref2, childPath) {
  var newPath = child(ref2._location.path, childPath);
  var location2 = new Location(ref2._location.bucket, newPath);
  return new Reference2(ref2.storage, location2);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL(service, url) {
  return new Reference2(service, url);
}
function refFromPath(ref2, path) {
  if (ref2 instanceof StorageService) {
    var service = ref2;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    var reference = new Reference2(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      if (path.includes("..")) {
        throw invalidArgument('`path` param cannot contain ".."');
      }
      return _getChild(ref2, path);
    } else {
      return ref2;
    }
  }
}
function ref(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof StorageService) {
      return refFromURL(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(config) {
  var bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString);
}
var StorageService = (
  /** @class */
  function() {
    function StorageService2(app, _authProvider, _pool, _url, _firebaseVersion) {
      this.app = app;
      this._authProvider = _authProvider;
      this._pool = _pool;
      this._url = _url;
      this._firebaseVersion = _firebaseVersion;
      this._bucket = null;
      this._appId = null;
      this._deleted = false;
      this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
      this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
      this._requests = /* @__PURE__ */ new Set();
      if (_url != null) {
        this._bucket = Location.makeFromBucketSpec(_url);
      } else {
        this._bucket = extractBucket(this.app.options);
      }
    }
    Object.defineProperty(StorageService2.prototype, "maxUploadRetryTime", {
      /**
       * The maximum time to retry uploads in milliseconds.
       */
      get: function() {
        return this._maxUploadRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxUploadRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageService2.prototype, "maxOperationRetryTime", {
      /**
       * The maximum time to retry operations other than uploads or downloads in
       * milliseconds.
       */
      get: function() {
        return this._maxOperationRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxOperationRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    StorageService2.prototype._getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var auth, tokenData;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              auth = this._authProvider.getImmediate({ optional: true });
              if (!auth)
                return [3, 2];
              return [4, auth.getToken()];
            case 1:
              tokenData = _a9.sent();
              if (tokenData !== null) {
                return [2, tokenData.accessToken];
              }
              _a9.label = 2;
            case 2:
              return [2, null];
          }
        });
      });
    };
    StorageService2.prototype._delete = function() {
      this._deleted = true;
      this._requests.forEach(function(request) {
        return request.cancel();
      });
      this._requests.clear();
      return Promise.resolve();
    };
    StorageService2.prototype._makeStorageReference = function(loc) {
      return new Reference2(this, loc);
    };
    StorageService2.prototype._makeRequest = function(requestInfo, authToken) {
      var _this = this;
      if (!this._deleted) {
        var request_1 = makeRequest(requestInfo, this._appId, authToken, this._pool, this._firebaseVersion);
        this._requests.add(request_1);
        request_1.getPromise().then(function() {
          return _this._requests.delete(request_1);
        }, function() {
          return _this._requests.delete(request_1);
        });
        return request_1;
      } else {
        return new FailRequest(appDeleted());
      }
    };
    return StorageService2;
  }()
);
function uploadBytesResumable$1(ref2, data, metadata) {
  return uploadBytesResumable(ref2, data, metadata);
}
function getMetadata$2(ref2) {
  return getMetadata$1(ref2);
}
function updateMetadata$2(ref2, metadata) {
  return updateMetadata$1(ref2, metadata);
}
function list$2(ref2, options) {
  return list$1(ref2, options);
}
function listAll$1(ref2) {
  return listAll(ref2);
}
function getDownloadURL$1(ref2) {
  return getDownloadURL(ref2);
}
function deleteObject$2(ref2) {
  return deleteObject$1(ref2);
}
function ref$1(serviceOrRef, pathOrUrl) {
  return ref(serviceOrRef, pathOrUrl);
}
function _getChild$1(ref2, childPath) {
  return _getChild(ref2, childPath);
}
var UploadTaskSnapshotCompat = (
  /** @class */
  function() {
    function UploadTaskSnapshotCompat2(_delegate, task, ref2) {
      this._delegate = _delegate;
      this.task = task;
      this.ref = ref2;
    }
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "bytesTransferred", {
      get: function() {
        return this._delegate.bytesTransferred;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "state", {
      get: function() {
        return this._delegate.state;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "totalBytes", {
      get: function() {
        return this._delegate.totalBytes;
      },
      enumerable: false,
      configurable: true
    });
    return UploadTaskSnapshotCompat2;
  }()
);
var UploadTaskCompat = (
  /** @class */
  function() {
    function UploadTaskCompat2(_delegate, _ref) {
      this._delegate = _delegate;
      this._ref = _ref;
      this.cancel = this._delegate.cancel.bind(this._delegate);
      this.catch = this._delegate.catch.bind(this._delegate);
      this.pause = this._delegate.pause.bind(this._delegate);
      this.resume = this._delegate.resume.bind(this._delegate);
    }
    Object.defineProperty(UploadTaskCompat2.prototype, "snapshot", {
      get: function() {
        return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
      },
      enumerable: false,
      configurable: true
    });
    UploadTaskCompat2.prototype.then = function(onFulfilled, onRejected) {
      var _this = this;
      return this._delegate.then(function(snapshot) {
        if (onFulfilled) {
          return onFulfilled(new UploadTaskSnapshotCompat(snapshot, _this, _this._ref));
        }
      }, onRejected);
    };
    UploadTaskCompat2.prototype.on = function(type, nextOrObserver, error2, completed) {
      var _this = this;
      var wrappedNextOrObserver = void 0;
      if (!!nextOrObserver) {
        if (typeof nextOrObserver === "function") {
          wrappedNextOrObserver = function(taskSnapshot) {
            return nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
          };
        } else {
          wrappedNextOrObserver = {
            next: !!nextOrObserver.next ? function(taskSnapshot) {
              return nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
            } : void 0,
            complete: nextOrObserver.complete || void 0,
            error: nextOrObserver.error || void 0
          };
        }
      }
      return this._delegate.on(type, wrappedNextOrObserver, error2 || void 0, completed || void 0);
    };
    return UploadTaskCompat2;
  }()
);
var ListResultCompat = (
  /** @class */
  function() {
    function ListResultCompat2(_delegate, _service) {
      this._delegate = _delegate;
      this._service = _service;
    }
    Object.defineProperty(ListResultCompat2.prototype, "prefixes", {
      get: function() {
        var _this = this;
        return this._delegate.prefixes.map(function(ref2) {
          return new ReferenceCompat(ref2, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "items", {
      get: function() {
        var _this = this;
        return this._delegate.items.map(function(ref2) {
          return new ReferenceCompat(ref2, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "nextPageToken", {
      get: function() {
        return this._delegate.nextPageToken || null;
      },
      enumerable: false,
      configurable: true
    });
    return ListResultCompat2;
  }()
);
var ReferenceCompat = (
  /** @class */
  function() {
    function ReferenceCompat2(_delegate, storage) {
      this._delegate = _delegate;
      this.storage = storage;
    }
    Object.defineProperty(ReferenceCompat2.prototype, "name", {
      get: function() {
        return this._delegate.name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "bucket", {
      get: function() {
        return this._delegate.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "fullPath", {
      get: function() {
        return this._delegate.fullPath;
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.toString = function() {
      return this._delegate.toString();
    };
    ReferenceCompat2.prototype.child = function(childPath) {
      var reference = _getChild$1(this._delegate, childPath);
      return new ReferenceCompat2(reference, this.storage);
    };
    Object.defineProperty(ReferenceCompat2.prototype, "root", {
      get: function() {
        return new ReferenceCompat2(this._delegate.root, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "parent", {
      /**
       * @returns A reference to the parent of the
       * current object, or null if the current object is the root.
       */
      get: function() {
        var reference = this._delegate.parent;
        if (reference == null) {
          return null;
        }
        return new ReferenceCompat2(reference, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.put = function(data, metadata) {
      this._throwIfRoot("put");
      return new UploadTaskCompat(uploadBytesResumable$1(this._delegate, data, metadata), this);
    };
    ReferenceCompat2.prototype.putString = function(value, format, metadata) {
      if (format === void 0) {
        format = StringFormat.RAW;
      }
      this._throwIfRoot("putString");
      var data = dataFromString(format, value);
      var metadataClone = __assign({}, metadata);
      if (metadataClone["contentType"] == null && data.contentType != null) {
        metadataClone["contentType"] = data.contentType;
      }
      return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
    };
    ReferenceCompat2.prototype.listAll = function() {
      var _this = this;
      return listAll$1(this._delegate).then(function(r2) {
        return new ListResultCompat(r2, _this.storage);
      });
    };
    ReferenceCompat2.prototype.list = function(options) {
      var _this = this;
      return list$2(this._delegate, options || void 0).then(function(r2) {
        return new ListResultCompat(r2, _this.storage);
      });
    };
    ReferenceCompat2.prototype.getMetadata = function() {
      return getMetadata$2(this._delegate);
    };
    ReferenceCompat2.prototype.updateMetadata = function(metadata) {
      return updateMetadata$2(this._delegate, metadata);
    };
    ReferenceCompat2.prototype.getDownloadURL = function() {
      return getDownloadURL$1(this._delegate);
    };
    ReferenceCompat2.prototype.delete = function() {
      this._throwIfRoot("delete");
      return deleteObject$2(this._delegate);
    };
    ReferenceCompat2.prototype._throwIfRoot = function(name10) {
      if (this._delegate._location.path === "") {
        throw invalidRootOperation(name10);
      }
    };
    return ReferenceCompat2;
  }()
);
var StorageServiceCompat = (
  /** @class */
  function() {
    function StorageServiceCompat2(app, _delegate) {
      var _this = this;
      this.app = app;
      this._delegate = _delegate;
      this.INTERNAL = {
        /**
         * Called when the associated app is deleted.
         */
        delete: function() {
          return _this._delegate._delete();
        }
      };
    }
    Object.defineProperty(StorageServiceCompat2.prototype, "maxOperationRetryTime", {
      get: function() {
        return this._delegate.maxOperationRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageServiceCompat2.prototype, "maxUploadRetryTime", {
      get: function() {
        return this._delegate.maxUploadRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    StorageServiceCompat2.prototype.ref = function(path) {
      if (isUrl(path)) {
        throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
      }
      return new ReferenceCompat(ref$1(this._delegate, path), this);
    };
    StorageServiceCompat2.prototype.refFromURL = function(url) {
      if (!isUrl(url)) {
        throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
      }
      try {
        Location.makeFromUrl(url);
      } catch (e) {
        throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
      }
      return new ReferenceCompat(ref$1(this._delegate, url), this);
    };
    StorageServiceCompat2.prototype.setMaxUploadRetryTime = function(time) {
      this._delegate.maxUploadRetryTime = time;
    };
    StorageServiceCompat2.prototype.setMaxOperationRetryTime = function(time) {
      this._delegate.maxOperationRetryTime = time;
    };
    return StorageServiceCompat2;
  }()
);
var name5 = "@firebase/storage";
var version5 = "0.4.5";
var STORAGE_TYPE = "storage";
function factory(container, _a9) {
  var url = _a9.instanceIdentifier;
  var app = container.getProvider("app").getImmediate();
  var authProvider = container.getProvider("auth-internal");
  var storageServiceCompat = new StorageServiceCompat(app, new StorageService(app, authProvider, new XhrIoPool(), url, index_esm_default.SDK_VERSION));
  return storageServiceCompat;
}
function registerStorage(instance) {
  var namespaceExports = {
    // no-inline
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: StorageService,
    Reference: ReferenceCompat
  };
  instance.INTERNAL.registerComponent(new Component(
    STORAGE_TYPE,
    factory,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name5, version5);
}
registerStorage(index_esm_default);

// node_modules/@firebase/performance/dist/index.esm.js
var name6 = "@firebase/performance";
var version6 = "0.4.8";
var SDK_VERSION2 = version6;
var TRACE_START_MARK_PREFIX = "FB-PERF-TRACE-START";
var TRACE_STOP_MARK_PREFIX = "FB-PERF-TRACE-STOP";
var TRACE_MEASURE_PREFIX = "FB-PERF-TRACE-MEASURE";
var OOB_TRACE_PAGE_LOAD_PREFIX = "_wt_";
var FIRST_PAINT_COUNTER_NAME = "_fp";
var FIRST_CONTENTFUL_PAINT_COUNTER_NAME = "_fcp";
var FIRST_INPUT_DELAY_COUNTER_NAME = "_fid";
var CONFIG_LOCAL_STORAGE_KEY = "@firebase/performance/config";
var CONFIG_EXPIRY_LOCAL_STORAGE_KEY = "@firebase/performance/configexpire";
var SERVICE2 = "performance";
var SERVICE_NAME2 = "Performance";
var _a6;
var ERROR_DESCRIPTION_MAP2 = (_a6 = {}, _a6[
  "trace started"
  /* TRACE_STARTED_BEFORE */
] = "Trace {$traceName} was started before.", _a6[
  "trace stopped"
  /* TRACE_STOPPED_BEFORE */
] = "Trace {$traceName} is not running.", _a6[
  "nonpositive trace startTime"
  /* NONPOSITIVE_TRACE_START_TIME */
] = "Trace {$traceName} startTime should be positive.", _a6[
  "nonpositive trace duration"
  /* NONPOSITIVE_TRACE_DURATION */
] = "Trace {$traceName} duration should be positive.", _a6[
  "no window"
  /* NO_WINDOW */
] = "Window is not available.", _a6[
  "no app id"
  /* NO_APP_ID */
] = "App id is not available.", _a6[
  "no project id"
  /* NO_PROJECT_ID */
] = "Project id is not available.", _a6[
  "no api key"
  /* NO_API_KEY */
] = "Api key is not available.", _a6[
  "invalid cc log"
  /* INVALID_CC_LOG */
] = "Attempted to queue invalid cc event", _a6[
  "FB not default"
  /* FB_NOT_DEFAULT */
] = "Performance can only start when Firebase app instance is the default one.", _a6[
  "RC response not ok"
  /* RC_NOT_OK */
] = "RC response is not ok", _a6[
  "invalid attribute name"
  /* INVALID_ATTRIBUTE_NAME */
] = "Attribute name {$attributeName} is invalid.", _a6[
  "invalid attribute value"
  /* INVALID_ATTRIBUTE_VALUE */
] = "Attribute value {$attributeValue} is invalid.", _a6[
  "invalid custom metric name"
  /* INVALID_CUSTOM_METRIC_NAME */
] = "Custom metric name {$customMetricName} is invalid", _a6[
  "invalid String merger input"
  /* INVALID_STRING_MERGER_PARAMETER */
] = "Input for String merger is invalid, contact support team to resolve.", _a6);
var ERROR_FACTORY4 = new ErrorFactory(SERVICE2, SERVICE_NAME2, ERROR_DESCRIPTION_MAP2);
var consoleLogger = new Logger(SERVICE_NAME2);
consoleLogger.logLevel = LogLevel.INFO;
var apiInstance;
var windowInstance;
var Api = (
  /** @class */
  function() {
    function Api2(window2) {
      this.window = window2;
      if (!window2) {
        throw ERROR_FACTORY4.create(
          "no window"
          /* NO_WINDOW */
        );
      }
      this.performance = window2.performance;
      this.PerformanceObserver = window2.PerformanceObserver;
      this.windowLocation = window2.location;
      this.navigator = window2.navigator;
      this.document = window2.document;
      if (this.navigator && this.navigator.cookieEnabled) {
        this.localStorage = window2.localStorage;
      }
      if (window2.perfMetrics && window2.perfMetrics.onFirstInputDelay) {
        this.onFirstInputDelay = window2.perfMetrics.onFirstInputDelay;
      }
    }
    Api2.prototype.getUrl = function() {
      return this.windowLocation.href.split("?")[0];
    };
    Api2.prototype.mark = function(name10) {
      if (!this.performance || !this.performance.mark) {
        return;
      }
      this.performance.mark(name10);
    };
    Api2.prototype.measure = function(measureName, mark1, mark2) {
      if (!this.performance || !this.performance.measure) {
        return;
      }
      this.performance.measure(measureName, mark1, mark2);
    };
    Api2.prototype.getEntriesByType = function(type) {
      if (!this.performance || !this.performance.getEntriesByType) {
        return [];
      }
      return this.performance.getEntriesByType(type);
    };
    Api2.prototype.getEntriesByName = function(name10) {
      if (!this.performance || !this.performance.getEntriesByName) {
        return [];
      }
      return this.performance.getEntriesByName(name10);
    };
    Api2.prototype.getTimeOrigin = function() {
      return this.performance && (this.performance.timeOrigin || this.performance.timing.navigationStart);
    };
    Api2.prototype.requiredApisAvailable = function() {
      if (!fetch || !Promise || !this.navigator || !this.navigator.cookieEnabled) {
        consoleLogger.info("Firebase Performance cannot start if browser does not support fetch and Promise or cookie is disabled.");
        return false;
      }
      if (!isIndexedDBAvailable()) {
        consoleLogger.info("IndexedDB is not supported by current browswer");
        return false;
      }
      return true;
    };
    Api2.prototype.setupObserver = function(entryType, callback) {
      if (!this.PerformanceObserver) {
        return;
      }
      var observer = new this.PerformanceObserver(function(list2) {
        for (var _i2 = 0, _a9 = list2.getEntries(); _i2 < _a9.length; _i2++) {
          var entry = _a9[_i2];
          callback(entry);
        }
      });
      observer.observe({ entryTypes: [entryType] });
    };
    Api2.getInstance = function() {
      if (apiInstance === void 0) {
        apiInstance = new Api2(windowInstance);
      }
      return apiInstance;
    };
    return Api2;
  }()
);
function setupApi(window2) {
  windowInstance = window2;
}
function mergeStrings(part1, part2) {
  var sizeDiff = part1.length - part2.length;
  if (sizeDiff < 0 || sizeDiff > 1) {
    throw ERROR_FACTORY4.create(
      "invalid String merger input"
      /* INVALID_STRING_MERGER_PARAMETER */
    );
  }
  var resultArray = [];
  for (var i = 0; i < part1.length; i++) {
    resultArray.push(part1.charAt(i));
    if (part2.length > i) {
      resultArray.push(part2.charAt(i));
    }
  }
  return resultArray.join("");
}
var settingsServiceInstance;
var SettingsService = (
  /** @class */
  function() {
    function SettingsService2() {
      this.instrumentationEnabled = true;
      this.dataCollectionEnabled = true;
      this.loggingEnabled = false;
      this.tracesSamplingRate = 1;
      this.networkRequestsSamplingRate = 1;
      this.logEndPointUrl = "https://firebaselogging.googleapis.com/v0cc/log?format=json_proto";
      this.flTransportEndpointUrl = mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
      this.transportKey = mergeStrings("AzSC8r6ReiGqFMyfvgow", "Iayx0u-XT3vksVM-pIV");
      this.logSource = 462;
      this.logTraceAfterSampling = false;
      this.logNetworkAfterSampling = false;
      this.configTimeToLive = 12;
    }
    SettingsService2.prototype.getAppId = function() {
      var appId = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.appId;
      if (!appId) {
        throw ERROR_FACTORY4.create(
          "no app id"
          /* NO_APP_ID */
        );
      }
      return appId;
    };
    SettingsService2.prototype.getProjectId = function() {
      var projectId = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.projectId;
      if (!projectId) {
        throw ERROR_FACTORY4.create(
          "no project id"
          /* NO_PROJECT_ID */
        );
      }
      return projectId;
    };
    SettingsService2.prototype.getApiKey = function() {
      var apiKey = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.apiKey;
      if (!apiKey) {
        throw ERROR_FACTORY4.create(
          "no api key"
          /* NO_API_KEY */
        );
      }
      return apiKey;
    };
    SettingsService2.prototype.getFlTransportFullUrl = function() {
      return this.flTransportEndpointUrl.concat("?key=", this.transportKey);
    };
    SettingsService2.getInstance = function() {
      if (settingsServiceInstance === void 0) {
        settingsServiceInstance = new SettingsService2();
      }
      return settingsServiceInstance;
    };
    return SettingsService2;
  }()
);
var iid;
function getIidPromise() {
  var iidPromise = SettingsService.getInstance().installationsService.getId();
  iidPromise.then(function(iidVal) {
    iid = iidVal;
  });
  return iidPromise;
}
function getIid() {
  return iid;
}
function getAuthTokenPromise() {
  var authTokenPromise = SettingsService.getInstance().installationsService.getToken();
  authTokenPromise.then(function(authTokenVal) {
  });
  return authTokenPromise;
}
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2[VisibilityState2["UNKNOWN"] = 0] = "UNKNOWN";
  VisibilityState2[VisibilityState2["VISIBLE"] = 1] = "VISIBLE";
  VisibilityState2[VisibilityState2["HIDDEN"] = 2] = "HIDDEN";
})(VisibilityState || (VisibilityState = {}));
var RESERVED_ATTRIBUTE_PREFIXES = ["firebase_", "google_", "ga_"];
var ATTRIBUTE_FORMAT_REGEX = new RegExp("^[a-zA-Z]\\w*$");
var MAX_ATTRIBUTE_NAME_LENGTH = 40;
var MAX_ATTRIBUTE_VALUE_LENGTH = 100;
function getServiceWorkerStatus() {
  var navigator2 = Api.getInstance().navigator;
  if ("serviceWorker" in navigator2) {
    if (navigator2.serviceWorker.controller) {
      return 2;
    } else {
      return 3;
    }
  } else {
    return 1;
  }
}
function getVisibilityState() {
  var document2 = Api.getInstance().document;
  var visibilityState = document2.visibilityState;
  switch (visibilityState) {
    case "visible":
      return VisibilityState.VISIBLE;
    case "hidden":
      return VisibilityState.HIDDEN;
    default:
      return VisibilityState.UNKNOWN;
  }
}
function getEffectiveConnectionType() {
  var navigator2 = Api.getInstance().navigator;
  var navigatorConnection = navigator2.connection;
  var effectiveType = navigatorConnection && navigatorConnection.effectiveType;
  switch (effectiveType) {
    case "slow-2g":
      return 1;
    case "2g":
      return 2;
    case "3g":
      return 3;
    case "4g":
      return 4;
    default:
      return 0;
  }
}
function isValidCustomAttributeName(name10) {
  if (name10.length === 0 || name10.length > MAX_ATTRIBUTE_NAME_LENGTH) {
    return false;
  }
  var matchesReservedPrefix = RESERVED_ATTRIBUTE_PREFIXES.some(function(prefix) {
    return name10.startsWith(prefix);
  });
  return !matchesReservedPrefix && !!name10.match(ATTRIBUTE_FORMAT_REGEX);
}
function isValidCustomAttributeValue(value) {
  return value.length !== 0 && value.length <= MAX_ATTRIBUTE_VALUE_LENGTH;
}
var REMOTE_CONFIG_SDK_VERSION = "0.0.1";
var DEFAULT_CONFIGS = {
  loggingEnabled: true
};
var FIS_AUTH_PREFIX = "FIREBASE_INSTALLATIONS_AUTH";
function getConfig(iid2) {
  var config = getStoredConfig();
  if (config) {
    processConfig(config);
    return Promise.resolve();
  }
  return getRemoteConfig(iid2).then(processConfig).then(
    function(config2) {
      return storeConfig(config2);
    },
    /** Do nothing for error, use defaults set in settings service. */
    function() {
    }
  );
}
function getStoredConfig() {
  var localStorage = Api.getInstance().localStorage;
  if (!localStorage) {
    return;
  }
  var expiryString = localStorage.getItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY);
  if (!expiryString || !configValid(expiryString)) {
    return;
  }
  var configStringified = localStorage.getItem(CONFIG_LOCAL_STORAGE_KEY);
  if (!configStringified) {
    return;
  }
  try {
    var configResponse = JSON.parse(configStringified);
    return configResponse;
  } catch (_a9) {
    return;
  }
}
function storeConfig(config) {
  var localStorage = Api.getInstance().localStorage;
  if (!config || !localStorage) {
    return;
  }
  localStorage.setItem(CONFIG_LOCAL_STORAGE_KEY, JSON.stringify(config));
  localStorage.setItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY, String(Date.now() + SettingsService.getInstance().configTimeToLive * 60 * 60 * 1e3));
}
var COULD_NOT_GET_CONFIG_MSG = "Could not fetch config, will use default configs";
function getRemoteConfig(iid2) {
  return getAuthTokenPromise().then(function(authToken) {
    var projectId = SettingsService.getInstance().getProjectId();
    var configEndPoint = "https://firebaseremoteconfig.googleapis.com/v1/projects/" + projectId + "/namespaces/fireperf:fetch?key=" + SettingsService.getInstance().getApiKey();
    var request = new Request(configEndPoint, {
      method: "POST",
      headers: { Authorization: FIS_AUTH_PREFIX + " " + authToken },
      /* eslint-disable camelcase */
      body: JSON.stringify({
        app_instance_id: iid2,
        app_instance_id_token: authToken,
        app_id: SettingsService.getInstance().getAppId(),
        app_version: SDK_VERSION2,
        sdk_version: REMOTE_CONFIG_SDK_VERSION
      })
      /* eslint-enable camelcase */
    });
    return fetch(request).then(function(response) {
      if (response.ok) {
        return response.json();
      }
      throw ERROR_FACTORY4.create(
        "RC response not ok"
        /* RC_NOT_OK */
      );
    });
  }).catch(function() {
    consoleLogger.info(COULD_NOT_GET_CONFIG_MSG);
    return void 0;
  });
}
function processConfig(config) {
  if (!config) {
    return config;
  }
  var settingsServiceInstance2 = SettingsService.getInstance();
  var entries = config.entries || {};
  if (entries.fpr_enabled !== void 0) {
    settingsServiceInstance2.loggingEnabled = String(entries.fpr_enabled) === "true";
  } else {
    settingsServiceInstance2.loggingEnabled = DEFAULT_CONFIGS.loggingEnabled;
  }
  if (entries.fpr_log_source) {
    settingsServiceInstance2.logSource = Number(entries.fpr_log_source);
  }
  if (entries.fpr_log_endpoint_url) {
    settingsServiceInstance2.logEndPointUrl = entries.fpr_log_endpoint_url;
  }
  if (entries.fpr_log_transport_key) {
    settingsServiceInstance2.transportKey = entries.fpr_log_transport_key;
  }
  if (entries.fpr_vc_network_request_sampling_rate !== void 0) {
    settingsServiceInstance2.networkRequestsSamplingRate = Number(entries.fpr_vc_network_request_sampling_rate);
  }
  if (entries.fpr_vc_trace_sampling_rate !== void 0) {
    settingsServiceInstance2.tracesSamplingRate = Number(entries.fpr_vc_trace_sampling_rate);
  }
  settingsServiceInstance2.logTraceAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.tracesSamplingRate);
  settingsServiceInstance2.logNetworkAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.networkRequestsSamplingRate);
  return config;
}
function configValid(expiry) {
  return Number(expiry) > Date.now();
}
function shouldLogAfterSampling(samplingRate) {
  return Math.random() <= samplingRate;
}
var initializationStatus = 1;
var initializationPromise;
function getInitializationPromise() {
  initializationStatus = 2;
  initializationPromise = initializationPromise || initializePerf();
  return initializationPromise;
}
function isPerfInitialized() {
  return initializationStatus === 3;
}
function initializePerf() {
  return getDocumentReadyComplete().then(function() {
    return getIidPromise();
  }).then(function(iid2) {
    return getConfig(iid2);
  }).then(function() {
    return changeInitializationStatus();
  }, function() {
    return changeInitializationStatus();
  });
}
function getDocumentReadyComplete() {
  var document2 = Api.getInstance().document;
  return new Promise(function(resolve) {
    if (document2 && document2.readyState !== "complete") {
      var handler_1 = function() {
        if (document2.readyState === "complete") {
          document2.removeEventListener("readystatechange", handler_1);
          resolve();
        }
      };
      document2.addEventListener("readystatechange", handler_1);
    } else {
      resolve();
    }
  });
}
function changeInitializationStatus() {
  initializationStatus = 3;
}
var DEFAULT_SEND_INTERVAL_MS = 10 * 1e3;
var INITIAL_SEND_TIME_DELAY_MS = 5.5 * 1e3;
var DEFAULT_REMAINING_TRIES = 3;
var MAX_EVENT_COUNT_PER_REQUEST = 1e3;
var remainingTries = DEFAULT_REMAINING_TRIES;
var queue = [];
var isTransportSetup = false;
function setupTransportService() {
  if (!isTransportSetup) {
    processQueue(INITIAL_SEND_TIME_DELAY_MS);
    isTransportSetup = true;
  }
}
function processQueue(timeOffset) {
  setTimeout(function() {
    if (remainingTries === 0) {
      return;
    }
    if (!queue.length) {
      return processQueue(DEFAULT_SEND_INTERVAL_MS);
    }
    dispatchQueueEvents();
  }, timeOffset);
}
function dispatchQueueEvents() {
  var staged = queue.splice(0, MAX_EVENT_COUNT_PER_REQUEST);
  var log_event = staged.map(function(evt) {
    return {
      source_extension_json_proto3: evt.message,
      event_time_ms: String(evt.eventTime)
    };
  });
  var data = {
    request_time_ms: String(Date.now()),
    client_info: {
      client_type: 1,
      js_client_info: {}
    },
    log_source: SettingsService.getInstance().logSource,
    log_event
  };
  sendEventsToFl(data, staged).catch(function() {
    queue = __spreadArray(__spreadArray([], staged), queue);
    remainingTries--;
    consoleLogger.info("Tries left: " + remainingTries + ".");
    processQueue(DEFAULT_SEND_INTERVAL_MS);
  });
}
function sendEventsToFl(data, staged) {
  return postToFlEndpoint(data).then(function(res) {
    if (!res.ok) {
      consoleLogger.info("Call to Firebase backend failed.");
    }
    return res.json();
  }).then(function(res) {
    var transportWait = Number(res.nextRequestWaitMillis);
    var requestOffset = DEFAULT_SEND_INTERVAL_MS;
    if (!isNaN(transportWait)) {
      requestOffset = Math.max(transportWait, requestOffset);
    }
    var logResponseDetails = res.logResponseDetails;
    if (Array.isArray(logResponseDetails) && logResponseDetails.length > 0 && logResponseDetails[0].responseAction === "RETRY_REQUEST_LATER") {
      queue = __spreadArray(__spreadArray([], staged), queue);
      consoleLogger.info("Retry transport request later.");
    }
    remainingTries = DEFAULT_REMAINING_TRIES;
    processQueue(requestOffset);
  });
}
function postToFlEndpoint(data) {
  var flTransportFullUrl = SettingsService.getInstance().getFlTransportFullUrl();
  return fetch(flTransportFullUrl, {
    method: "POST",
    body: JSON.stringify(data)
  });
}
function addToQueue(evt) {
  if (!evt.eventTime || !evt.message) {
    throw ERROR_FACTORY4.create(
      "invalid cc log"
      /* INVALID_CC_LOG */
    );
  }
  queue = __spreadArray(__spreadArray([], queue), [evt]);
}
function transportHandler(serializer2) {
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var message = serializer2.apply(void 0, args);
    addToQueue({
      message,
      eventTime: Date.now()
    });
  };
}
var logger3;
function sendLog(resource, resourceType) {
  if (!logger3) {
    logger3 = transportHandler(serializer);
  }
  logger3(resource, resourceType);
}
function logTrace(trace) {
  var settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled && trace.isAuto) {
    return;
  }
  if (!settingsService.dataCollectionEnabled && !trace.isAuto) {
    return;
  }
  if (!Api.getInstance().requiredApisAvailable()) {
    return;
  }
  if (trace.isAuto && getVisibilityState() !== VisibilityState.VISIBLE) {
    return;
  }
  if (isPerfInitialized()) {
    sendTraceLog(trace);
  } else {
    getInitializationPromise().then(function() {
      return sendTraceLog(trace);
    }, function() {
      return sendTraceLog(trace);
    });
  }
}
function sendTraceLog(trace) {
  if (!getIid()) {
    return;
  }
  var settingsService = SettingsService.getInstance();
  if (!settingsService.loggingEnabled || !settingsService.logTraceAfterSampling) {
    return;
  }
  setTimeout(function() {
    return sendLog(
      trace,
      1
      /* Trace */
    );
  }, 0);
}
function logNetworkRequest(networkRequest) {
  var settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled) {
    return;
  }
  var networkRequestUrl = networkRequest.url;
  var logEndpointUrl = settingsService.logEndPointUrl.split("?")[0];
  var flEndpointUrl = settingsService.flTransportEndpointUrl.split("?")[0];
  if (networkRequestUrl === logEndpointUrl || networkRequestUrl === flEndpointUrl) {
    return;
  }
  if (!settingsService.loggingEnabled || !settingsService.logNetworkAfterSampling) {
    return;
  }
  setTimeout(function() {
    return sendLog(
      networkRequest,
      0
      /* NetworkRequest */
    );
  }, 0);
}
function serializer(resource, resourceType) {
  if (resourceType === 0) {
    return serializeNetworkRequest(resource);
  }
  return serializeTrace(resource);
}
function serializeNetworkRequest(networkRequest) {
  var networkRequestMetric = {
    url: networkRequest.url,
    http_method: networkRequest.httpMethod || 0,
    http_response_code: 200,
    response_payload_bytes: networkRequest.responsePayloadBytes,
    client_start_time_us: networkRequest.startTimeUs,
    time_to_response_initiated_us: networkRequest.timeToResponseInitiatedUs,
    time_to_response_completed_us: networkRequest.timeToResponseCompletedUs
  };
  var perfMetric = {
    application_info: getApplicationInfo(),
    network_request_metric: networkRequestMetric
  };
  return JSON.stringify(perfMetric);
}
function serializeTrace(trace) {
  var traceMetric = {
    name: trace.name,
    is_auto: trace.isAuto,
    client_start_time_us: trace.startTimeUs,
    duration_us: trace.durationUs
  };
  if (Object.keys(trace.counters).length !== 0) {
    traceMetric.counters = trace.counters;
  }
  var customAttributes = trace.getAttributes();
  if (Object.keys(customAttributes).length !== 0) {
    traceMetric.custom_attributes = customAttributes;
  }
  var perfMetric = {
    application_info: getApplicationInfo(),
    trace_metric: traceMetric
  };
  return JSON.stringify(perfMetric);
}
function getApplicationInfo() {
  return {
    google_app_id: SettingsService.getInstance().getAppId(),
    app_instance_id: getIid(),
    web_app_info: {
      sdk_version: SDK_VERSION2,
      page_url: Api.getInstance().getUrl(),
      service_worker_status: getServiceWorkerStatus(),
      visibility_state: getVisibilityState(),
      effective_connection_type: getEffectiveConnectionType()
    },
    application_process_state: 0
  };
}
var MAX_METRIC_NAME_LENGTH = 100;
var RESERVED_AUTO_PREFIX = "_";
var oobMetrics = [
  FIRST_PAINT_COUNTER_NAME,
  FIRST_CONTENTFUL_PAINT_COUNTER_NAME,
  FIRST_INPUT_DELAY_COUNTER_NAME
];
function isValidMetricName(name10, traceName) {
  if (name10.length === 0 || name10.length > MAX_METRIC_NAME_LENGTH) {
    return false;
  }
  return traceName && traceName.startsWith(OOB_TRACE_PAGE_LOAD_PREFIX) && oobMetrics.indexOf(name10) > -1 || !name10.startsWith(RESERVED_AUTO_PREFIX);
}
function convertMetricValueToInteger(providedValue) {
  var valueAsInteger = Math.floor(providedValue);
  if (valueAsInteger < providedValue) {
    consoleLogger.info("Metric value should be an Integer, setting the value as : " + valueAsInteger + ".");
  }
  return valueAsInteger;
}
var Trace = (
  /** @class */
  function() {
    function Trace2(name10, isAuto, traceMeasureName) {
      if (isAuto === void 0) {
        isAuto = false;
      }
      this.name = name10;
      this.isAuto = isAuto;
      this.state = 1;
      this.customAttributes = {};
      this.counters = {};
      this.api = Api.getInstance();
      this.randomId = Math.floor(Math.random() * 1e6);
      if (!this.isAuto) {
        this.traceStartMark = TRACE_START_MARK_PREFIX + "-" + this.randomId + "-" + this.name;
        this.traceStopMark = TRACE_STOP_MARK_PREFIX + "-" + this.randomId + "-" + this.name;
        this.traceMeasure = traceMeasureName || TRACE_MEASURE_PREFIX + "-" + this.randomId + "-" + this.name;
        if (traceMeasureName) {
          this.calculateTraceMetrics();
        }
      }
    }
    Trace2.prototype.start = function() {
      if (this.state !== 1) {
        throw ERROR_FACTORY4.create("trace started", {
          traceName: this.name
        });
      }
      this.api.mark(this.traceStartMark);
      this.state = 2;
    };
    Trace2.prototype.stop = function() {
      if (this.state !== 2) {
        throw ERROR_FACTORY4.create("trace stopped", {
          traceName: this.name
        });
      }
      this.state = 3;
      this.api.mark(this.traceStopMark);
      this.api.measure(this.traceMeasure, this.traceStartMark, this.traceStopMark);
      this.calculateTraceMetrics();
      logTrace(this);
    };
    Trace2.prototype.record = function(startTime, duration, options) {
      if (startTime <= 0) {
        throw ERROR_FACTORY4.create("nonpositive trace startTime", {
          traceName: this.name
        });
      }
      if (duration <= 0) {
        throw ERROR_FACTORY4.create("nonpositive trace duration", {
          traceName: this.name
        });
      }
      this.durationUs = Math.floor(duration * 1e3);
      this.startTimeUs = Math.floor(startTime * 1e3);
      if (options && options.attributes) {
        this.customAttributes = __assign({}, options.attributes);
      }
      if (options && options.metrics) {
        for (var _i2 = 0, _a9 = Object.keys(options.metrics); _i2 < _a9.length; _i2++) {
          var metric = _a9[_i2];
          if (!isNaN(Number(options.metrics[metric]))) {
            this.counters[metric] = Number(Math.floor(options.metrics[metric]));
          }
        }
      }
      logTrace(this);
    };
    Trace2.prototype.incrementMetric = function(counter, numAsInteger) {
      if (numAsInteger === void 0) {
        numAsInteger = 1;
      }
      if (this.counters[counter] === void 0) {
        this.putMetric(counter, numAsInteger);
      } else {
        this.putMetric(counter, this.counters[counter] + numAsInteger);
      }
    };
    Trace2.prototype.putMetric = function(counter, numAsInteger) {
      if (isValidMetricName(counter, this.name)) {
        this.counters[counter] = convertMetricValueToInteger(numAsInteger);
      } else {
        throw ERROR_FACTORY4.create("invalid custom metric name", {
          customMetricName: counter
        });
      }
    };
    Trace2.prototype.getMetric = function(counter) {
      return this.counters[counter] || 0;
    };
    Trace2.prototype.putAttribute = function(attr, value) {
      var isValidName = isValidCustomAttributeName(attr);
      var isValidValue = isValidCustomAttributeValue(value);
      if (isValidName && isValidValue) {
        this.customAttributes[attr] = value;
        return;
      }
      if (!isValidName) {
        throw ERROR_FACTORY4.create("invalid attribute name", {
          attributeName: attr
        });
      }
      if (!isValidValue) {
        throw ERROR_FACTORY4.create("invalid attribute value", {
          attributeValue: value
        });
      }
    };
    Trace2.prototype.getAttribute = function(attr) {
      return this.customAttributes[attr];
    };
    Trace2.prototype.removeAttribute = function(attr) {
      if (this.customAttributes[attr] === void 0) {
        return;
      }
      delete this.customAttributes[attr];
    };
    Trace2.prototype.getAttributes = function() {
      return __assign({}, this.customAttributes);
    };
    Trace2.prototype.setStartTime = function(startTime) {
      this.startTimeUs = startTime;
    };
    Trace2.prototype.setDuration = function(duration) {
      this.durationUs = duration;
    };
    Trace2.prototype.calculateTraceMetrics = function() {
      var perfMeasureEntries = this.api.getEntriesByName(this.traceMeasure);
      var perfMeasureEntry = perfMeasureEntries && perfMeasureEntries[0];
      if (perfMeasureEntry) {
        this.durationUs = Math.floor(perfMeasureEntry.duration * 1e3);
        this.startTimeUs = Math.floor((perfMeasureEntry.startTime + this.api.getTimeOrigin()) * 1e3);
      }
    };
    Trace2.createOobTrace = function(navigationTimings, paintTimings, firstInputDelay) {
      var route = Api.getInstance().getUrl();
      if (!route) {
        return;
      }
      var trace = new Trace2(OOB_TRACE_PAGE_LOAD_PREFIX + route, true);
      var timeOriginUs = Math.floor(Api.getInstance().getTimeOrigin() * 1e3);
      trace.setStartTime(timeOriginUs);
      if (navigationTimings && navigationTimings[0]) {
        trace.setDuration(Math.floor(navigationTimings[0].duration * 1e3));
        trace.putMetric("domInteractive", Math.floor(navigationTimings[0].domInteractive * 1e3));
        trace.putMetric("domContentLoadedEventEnd", Math.floor(navigationTimings[0].domContentLoadedEventEnd * 1e3));
        trace.putMetric("loadEventEnd", Math.floor(navigationTimings[0].loadEventEnd * 1e3));
      }
      var FIRST_PAINT = "first-paint";
      var FIRST_CONTENTFUL_PAINT = "first-contentful-paint";
      if (paintTimings) {
        var firstPaint = paintTimings.find(function(paintObject) {
          return paintObject.name === FIRST_PAINT;
        });
        if (firstPaint && firstPaint.startTime) {
          trace.putMetric(FIRST_PAINT_COUNTER_NAME, Math.floor(firstPaint.startTime * 1e3));
        }
        var firstContentfulPaint = paintTimings.find(function(paintObject) {
          return paintObject.name === FIRST_CONTENTFUL_PAINT;
        });
        if (firstContentfulPaint && firstContentfulPaint.startTime) {
          trace.putMetric(FIRST_CONTENTFUL_PAINT_COUNTER_NAME, Math.floor(firstContentfulPaint.startTime * 1e3));
        }
        if (firstInputDelay) {
          trace.putMetric(FIRST_INPUT_DELAY_COUNTER_NAME, Math.floor(firstInputDelay * 1e3));
        }
      }
      logTrace(trace);
    };
    Trace2.createUserTimingTrace = function(measureName) {
      var trace = new Trace2(measureName, false, measureName);
      logTrace(trace);
    };
    return Trace2;
  }()
);
function createNetworkRequestEntry(entry) {
  var performanceEntry = entry;
  if (!performanceEntry || performanceEntry.responseStart === void 0) {
    return;
  }
  var timeOrigin = Api.getInstance().getTimeOrigin();
  var startTimeUs = Math.floor((performanceEntry.startTime + timeOrigin) * 1e3);
  var timeToResponseInitiatedUs = performanceEntry.responseStart ? Math.floor((performanceEntry.responseStart - performanceEntry.startTime) * 1e3) : void 0;
  var timeToResponseCompletedUs = Math.floor((performanceEntry.responseEnd - performanceEntry.startTime) * 1e3);
  var url = performanceEntry.name && performanceEntry.name.split("?")[0];
  var networkRequest = {
    url,
    responsePayloadBytes: performanceEntry.transferSize,
    startTimeUs,
    timeToResponseInitiatedUs,
    timeToResponseCompletedUs
  };
  logNetworkRequest(networkRequest);
}
var FID_WAIT_TIME_MS = 5e3;
function setupOobResources() {
  if (!getIid()) {
    return;
  }
  setTimeout(function() {
    return setupOobTraces();
  }, 0);
  setTimeout(function() {
    return setupNetworkRequests();
  }, 0);
  setTimeout(function() {
    return setupUserTimingTraces();
  }, 0);
}
function setupNetworkRequests() {
  var api = Api.getInstance();
  var resources = api.getEntriesByType("resource");
  for (var _i2 = 0, resources_1 = resources; _i2 < resources_1.length; _i2++) {
    var resource = resources_1[_i2];
    createNetworkRequestEntry(resource);
  }
  api.setupObserver("resource", createNetworkRequestEntry);
}
function setupOobTraces() {
  var api = Api.getInstance();
  var navigationTimings = api.getEntriesByType("navigation");
  var paintTimings = api.getEntriesByType("paint");
  if (api.onFirstInputDelay) {
    var timeoutId_1 = setTimeout(function() {
      Trace.createOobTrace(navigationTimings, paintTimings);
      timeoutId_1 = void 0;
    }, FID_WAIT_TIME_MS);
    api.onFirstInputDelay(function(fid) {
      if (timeoutId_1) {
        clearTimeout(timeoutId_1);
        Trace.createOobTrace(navigationTimings, paintTimings, fid);
      }
    });
  } else {
    Trace.createOobTrace(navigationTimings, paintTimings);
  }
}
function setupUserTimingTraces() {
  var api = Api.getInstance();
  var measures = api.getEntriesByType("measure");
  for (var _i2 = 0, measures_1 = measures; _i2 < measures_1.length; _i2++) {
    var measure = measures_1[_i2];
    createUserTimingTrace(measure);
  }
  api.setupObserver("measure", createUserTimingTrace);
}
function createUserTimingTrace(measure) {
  var measureName = measure.name;
  if (measureName.substring(0, TRACE_MEASURE_PREFIX.length) === TRACE_MEASURE_PREFIX) {
    return;
  }
  Trace.createUserTimingTrace(measureName);
}
var PerformanceController = (
  /** @class */
  function() {
    function PerformanceController2(app) {
      this.app = app;
      if (Api.getInstance().requiredApisAvailable()) {
        validateIndexedDBOpenable().then(function(isAvailable) {
          if (isAvailable) {
            setupTransportService();
            getInitializationPromise().then(setupOobResources, setupOobResources);
          }
        }).catch(function(error2) {
          consoleLogger.info("Environment doesn't support IndexedDB: " + error2);
        });
      }
    }
    PerformanceController2.prototype.trace = function(name10) {
      return new Trace(name10);
    };
    Object.defineProperty(PerformanceController2.prototype, "instrumentationEnabled", {
      get: function() {
        return SettingsService.getInstance().instrumentationEnabled;
      },
      set: function(val) {
        SettingsService.getInstance().instrumentationEnabled = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PerformanceController2.prototype, "dataCollectionEnabled", {
      get: function() {
        return SettingsService.getInstance().dataCollectionEnabled;
      },
      set: function(val) {
        SettingsService.getInstance().dataCollectionEnabled = val;
      },
      enumerable: false,
      configurable: true
    });
    return PerformanceController2;
  }()
);
var DEFAULT_ENTRY_NAME3 = "[DEFAULT]";
function registerPerformance(instance) {
  var factoryMethod2 = function(app, installations) {
    if (app.name !== DEFAULT_ENTRY_NAME3) {
      throw ERROR_FACTORY4.create(
        "FB not default"
        /* FB_NOT_DEFAULT */
      );
    }
    if (typeof window === "undefined") {
      throw ERROR_FACTORY4.create(
        "no window"
        /* NO_WINDOW */
      );
    }
    setupApi(window);
    SettingsService.getInstance().firebaseAppInstance = app;
    SettingsService.getInstance().installationsService = installations;
    return new PerformanceController(app);
  };
  instance.INTERNAL.registerComponent(new Component(
    "performance",
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var installations = container.getProvider("installations").getImmediate();
      return factoryMethod2(app, installations);
    },
    "PUBLIC"
    /* PUBLIC */
  ));
  instance.registerVersion(name6, version6);
}
registerPerformance(index_esm_default);

// node_modules/@firebase/analytics/dist/index.esm.js
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var GtagCommand;
(function(GtagCommand2) {
  GtagCommand2["EVENT"] = "event";
  GtagCommand2["SET"] = "set";
  GtagCommand2["CONFIG"] = "config";
})(GtagCommand || (GtagCommand = {}));
var EventName;
(function(EventName2) {
  EventName2["ADD_SHIPPING_INFO"] = "add_shipping_info";
  EventName2["ADD_PAYMENT_INFO"] = "add_payment_info";
  EventName2["ADD_TO_CART"] = "add_to_cart";
  EventName2["ADD_TO_WISHLIST"] = "add_to_wishlist";
  EventName2["BEGIN_CHECKOUT"] = "begin_checkout";
  EventName2["CHECKOUT_PROGRESS"] = "checkout_progress";
  EventName2["EXCEPTION"] = "exception";
  EventName2["GENERATE_LEAD"] = "generate_lead";
  EventName2["LOGIN"] = "login";
  EventName2["PAGE_VIEW"] = "page_view";
  EventName2["PURCHASE"] = "purchase";
  EventName2["REFUND"] = "refund";
  EventName2["REMOVE_FROM_CART"] = "remove_from_cart";
  EventName2["SCREEN_VIEW"] = "screen_view";
  EventName2["SEARCH"] = "search";
  EventName2["SELECT_CONTENT"] = "select_content";
  EventName2["SELECT_ITEM"] = "select_item";
  EventName2["SELECT_PROMOTION"] = "select_promotion";
  EventName2["SET_CHECKOUT_OPTION"] = "set_checkout_option";
  EventName2["SHARE"] = "share";
  EventName2["SIGN_UP"] = "sign_up";
  EventName2["TIMING_COMPLETE"] = "timing_complete";
  EventName2["VIEW_CART"] = "view_cart";
  EventName2["VIEW_ITEM"] = "view_item";
  EventName2["VIEW_ITEM_LIST"] = "view_item_list";
  EventName2["VIEW_PROMOTION"] = "view_promotion";
  EventName2["VIEW_SEARCH_RESULTS"] = "view_search_results";
})(EventName || (EventName = {}));
function logEvent(gtagFunction, initializationPromise2, eventName, eventParams, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId, params;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.EVENT, eventName, eventParams);
          return [
            2
            /*return*/
          ];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a9.sent();
          params = __assign(__assign({}, eventParams), { "send_to": measurementId });
          gtagFunction(GtagCommand.EVENT, eventName, params);
          _a9.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setCurrentScreen(gtagFunction, initializationPromise2, screenName, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.SET, { "screen_name": screenName });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a9.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "screen_name": screenName
          });
          _a9.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setUserId(gtagFunction, initializationPromise2, id2, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.SET, { "user_id": id2 });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a9.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_id": id2
          });
          _a9.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setUserProperties(gtagFunction, initializationPromise2, properties, options) {
  return __awaiter(this, void 0, void 0, function() {
    var flatProperties, _i2, _a9, key, measurementId;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          flatProperties = {};
          for (_i2 = 0, _a9 = Object.keys(properties); _i2 < _a9.length; _i2++) {
            key = _a9[_i2];
            flatProperties["user_properties." + key] = properties[key];
          }
          gtagFunction(GtagCommand.SET, flatProperties);
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _b.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_properties": properties
          });
          _b.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setAnalyticsCollectionEnabled(initializationPromise2, enabled) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          return [4, initializationPromise2];
        case 1:
          measurementId = _a9.sent();
          window["ga-disable-" + measurementId] = !enabled;
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
var logger4 = new Logger("@firebase/analytics");
function insertScriptTag(dataLayerName2, measurementId) {
  var script = document.createElement("script");
  script.src = GTAG_URL + "?l=" + dataLayerName2 + "&id=" + measurementId;
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  var dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var correspondingAppId, dynamicConfigResults, foundConfig, e_1;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          correspondingAppId = measurementIdToAppId2[measurementId];
          _a9.label = 1;
        case 1:
          _a9.trys.push([1, 7, , 8]);
          if (!correspondingAppId)
            return [3, 3];
          return [4, initializationPromisesMap2[correspondingAppId]];
        case 2:
          _a9.sent();
          return [3, 6];
        case 3:
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 4:
          dynamicConfigResults = _a9.sent();
          foundConfig = dynamicConfigResults.find(function(config) {
            return config.measurementId === measurementId;
          });
          if (!foundConfig)
            return [3, 6];
          return [4, initializationPromisesMap2[foundConfig.appId]];
        case 5:
          _a9.sent();
          _a9.label = 6;
        case 6:
          return [3, 8];
        case 7:
          e_1 = _a9.sent();
          logger4.error(e_1);
          return [3, 8];
        case 8:
          gtagCore(GtagCommand.CONFIG, measurementId, gtagParams);
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var initializationPromisesToWaitFor, gaSendToList, dynamicConfigResults, _loop_1, _i2, gaSendToList_1, sendToId, state_1, e_2;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          _a9.trys.push([0, 4, , 5]);
          initializationPromisesToWaitFor = [];
          if (!(gtagParams && gtagParams["send_to"]))
            return [3, 2];
          gaSendToList = gtagParams["send_to"];
          if (!Array.isArray(gaSendToList)) {
            gaSendToList = [gaSendToList];
          }
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 1:
          dynamicConfigResults = _a9.sent();
          _loop_1 = function(sendToId2) {
            var foundConfig = dynamicConfigResults.find(function(config) {
              return config.measurementId === sendToId2;
            });
            var initializationPromise2 = foundConfig && initializationPromisesMap2[foundConfig.appId];
            if (initializationPromise2) {
              initializationPromisesToWaitFor.push(initializationPromise2);
            } else {
              initializationPromisesToWaitFor = [];
              return "break";
            }
          };
          for (_i2 = 0, gaSendToList_1 = gaSendToList; _i2 < gaSendToList_1.length; _i2++) {
            sendToId = gaSendToList_1[_i2];
            state_1 = _loop_1(sendToId);
            if (state_1 === "break")
              break;
          }
          _a9.label = 2;
        case 2:
          if (initializationPromisesToWaitFor.length === 0) {
            initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
          }
          return [4, Promise.all(initializationPromisesToWaitFor)];
        case 3:
          _a9.sent();
          gtagCore(GtagCommand.EVENT, measurementId, gtagParams || {});
          return [3, 5];
        case 4:
          e_2 = _a9.sent();
          logger4.error(e_2);
          return [3, 5];
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  function gtagWrapper(command, idOrNameOrParams, gtagParams) {
    return __awaiter(this, void 0, void 0, function() {
      var e_3;
      return __generator(this, function(_a9) {
        switch (_a9.label) {
          case 0:
            _a9.trys.push([0, 6, , 7]);
            if (!(command === GtagCommand.EVENT))
              return [3, 2];
            return [4, gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, idOrNameOrParams, gtagParams)];
          case 1:
            _a9.sent();
            return [3, 5];
          case 2:
            if (!(command === GtagCommand.CONFIG))
              return [3, 4];
            return [4, gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, idOrNameOrParams, gtagParams)];
          case 3:
            _a9.sent();
            return [3, 5];
          case 4:
            gtagCore(GtagCommand.SET, idOrNameOrParams);
            _a9.label = 5;
          case 5:
            return [3, 7];
          case 6:
            e_3 = _a9.sent();
            logger4.error(e_3);
            return [3, 7];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  var gtagCore = function() {
    var _args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      _args[_i2] = arguments[_i2];
    }
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage() {
  var scriptTags = window.document.getElementsByTagName("script");
  for (var _i2 = 0, _a9 = Object.values(scriptTags); _i2 < _a9.length; _i2++) {
    var tag = _a9[_i2];
    if (tag.src && tag.src.includes(GTAG_URL)) {
      return tag;
    }
  }
  return null;
}
var _a7;
var ERRORS2 = (_a7 = {}, _a7[
  "already-exists"
  /* ALREADY_EXISTS */
] = "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.", _a7[
  "already-initialized"
  /* ALREADY_INITIALIZED */
] = "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", _a7[
  "interop-component-reg-failed"
  /* INTEROP_COMPONENT_REG_FAILED */
] = "Firebase Analytics Interop Component failed to instantiate: {$reason}", _a7[
  "invalid-analytics-context"
  /* INVALID_ANALYTICS_CONTEXT */
] = "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a7[
  "indexeddb-unavailable"
  /* INDEXEDDB_UNAVAILABLE */
] = "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a7[
  "fetch-throttle"
  /* FETCH_THROTTLE */
] = "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", _a7[
  "config-fetch-failed"
  /* CONFIG_FETCH_FAILED */
] = "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", _a7[
  "no-api-key"
  /* NO_API_KEY */
] = 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.', _a7[
  "no-app-id"
  /* NO_APP_ID */
] = 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.', _a7);
var ERROR_FACTORY5 = new ErrorFactory("analytics", "Analytics", ERRORS2);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = (
  /** @class */
  function() {
    function RetryData2(throttleMetadata, intervalMillis) {
      if (throttleMetadata === void 0) {
        throttleMetadata = {};
      }
      if (intervalMillis === void 0) {
        intervalMillis = BASE_INTERVAL_MILLIS;
      }
      this.throttleMetadata = throttleMetadata;
      this.intervalMillis = intervalMillis;
    }
    RetryData2.prototype.getThrottleMetadata = function(appId) {
      return this.throttleMetadata[appId];
    };
    RetryData2.prototype.setThrottleMetadata = function(appId, metadata) {
      this.throttleMetadata[appId] = metadata;
    };
    RetryData2.prototype.deleteThrottleMetadata = function(appId) {
      delete this.throttleMetadata[appId];
    };
    return RetryData2;
  }()
);
var defaultRetryData = new RetryData();
function getHeaders3(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function fetchDynamicConfig(appFields) {
  var _a9;
  return __awaiter(this, void 0, void 0, function() {
    var appId, apiKey, request, appUrl, response, errorMessage, jsonResponse, _ignored_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, apiKey = appFields.apiKey;
          request = {
            method: "GET",
            headers: getHeaders3(apiKey)
          };
          appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
          return [4, fetch(appUrl, request)];
        case 1:
          response = _b.sent();
          if (!(response.status !== 200 && response.status !== 304))
            return [3, 6];
          errorMessage = "";
          _b.label = 2;
        case 2:
          _b.trys.push([2, 4, , 5]);
          return [4, response.json()];
        case 3:
          jsonResponse = _b.sent();
          if ((_a9 = jsonResponse.error) === null || _a9 === void 0 ? void 0 : _a9.message) {
            errorMessage = jsonResponse.error.message;
          }
          return [3, 5];
        case 4:
          _ignored_1 = _b.sent();
          return [3, 5];
        case 5:
          throw ERROR_FACTORY5.create("config-fetch-failed", {
            httpStatus: response.status,
            responseMessage: errorMessage
          });
        case 6:
          return [2, response.json()];
      }
    });
  });
}
function fetchDynamicConfigWithRetry(app, retryData, timeoutMillis) {
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var _a9, appId, apiKey, measurementId, throttleMetadata, signal;
    var _this = this;
    return __generator(this, function(_b) {
      _a9 = app.options, appId = _a9.appId, apiKey = _a9.apiKey, measurementId = _a9.measurementId;
      if (!appId) {
        throw ERROR_FACTORY5.create(
          "no-app-id"
          /* NO_APP_ID */
        );
      }
      if (!apiKey) {
        if (measurementId) {
          return [2, {
            measurementId,
            appId
          }];
        }
        throw ERROR_FACTORY5.create(
          "no-api-key"
          /* NO_API_KEY */
        );
      }
      throttleMetadata = retryData.getThrottleMetadata(appId) || {
        backoffCount: 0,
        throttleEndTimeMillis: Date.now()
      };
      signal = new AnalyticsAbortSignal();
      setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a10) {
            signal.abort();
            return [
              2
              /*return*/
            ];
          });
        });
      }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
      return [2, attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData)];
    });
  });
}
function attemptFetchDynamicConfigWithRetry(appFields, _a9, signal, retryData) {
  var throttleEndTimeMillis = _a9.throttleEndTimeMillis, backoffCount = _a9.backoffCount;
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var appId, measurementId, e_1, response, e_2, backoffMillis, throttleMetadata;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, measurementId = appFields.measurementId;
          _b.label = 1;
        case 1:
          _b.trys.push([1, 3, , 4]);
          return [4, setAbortableTimeout(signal, throttleEndTimeMillis)];
        case 2:
          _b.sent();
          return [3, 4];
        case 3:
          e_1 = _b.sent();
          if (measurementId) {
            logger4.warn("Timed out fetching this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_1.message + "]"));
            return [2, { appId, measurementId }];
          }
          throw e_1;
        case 4:
          _b.trys.push([4, 6, , 7]);
          return [4, fetchDynamicConfig(appFields)];
        case 5:
          response = _b.sent();
          retryData.deleteThrottleMetadata(appId);
          return [2, response];
        case 6:
          e_2 = _b.sent();
          if (!isRetriableError(e_2)) {
            retryData.deleteThrottleMetadata(appId);
            if (measurementId) {
              logger4.warn("Failed to fetch this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_2.message + "]"));
              return [2, { appId, measurementId }];
            } else {
              throw e_2;
            }
          }
          backoffMillis = Number(e_2.customData.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
          throttleMetadata = {
            throttleEndTimeMillis: Date.now() + backoffMillis,
            backoffCount: backoffCount + 1
          };
          retryData.setThrottleMetadata(appId, throttleMetadata);
          logger4.debug("Calling attemptFetch again in " + backoffMillis + " millis");
          return [2, attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData)];
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise(function(resolve, reject) {
    var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    var timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(function() {
      clearTimeout(timeout);
      reject(ERROR_FACTORY5.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  var httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = (
  /** @class */
  function() {
    function AnalyticsAbortSignal2() {
      this.listeners = [];
    }
    AnalyticsAbortSignal2.prototype.addEventListener = function(listener) {
      this.listeners.push(listener);
    };
    AnalyticsAbortSignal2.prototype.abort = function() {
      this.listeners.forEach(function(listener) {
        return listener();
      });
    };
    return AnalyticsAbortSignal2;
  }()
);
function validateIndexedDB() {
  return __awaiter(this, void 0, void 0, function() {
    var e_1;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (!!isIndexedDBAvailable())
            return [3, 1];
          logger4.warn(ERROR_FACTORY5.create("indexeddb-unavailable", {
            errorInfo: "IndexedDB is not available in this environment."
          }).message);
          return [2, false];
        case 1:
          _a9.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          _a9.sent();
          return [3, 4];
        case 3:
          e_1 = _a9.sent();
          logger4.warn(ERROR_FACTORY5.create("indexeddb-unavailable", {
            errorInfo: e_1
          }).message);
          return [2, false];
        case 4:
          return [2, true];
      }
    });
  });
}
function initializeIds(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2) {
  return __awaiter(this, void 0, void 0, function() {
    var dynamicConfigPromise, fidPromise, _a9, dynamicConfig, fid, configProperties;
    var _b;
    return __generator(this, function(_c2) {
      switch (_c2.label) {
        case 0:
          dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
          dynamicConfigPromise.then(function(config) {
            measurementIdToAppId2[config.measurementId] = config.appId;
            if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
              logger4.warn("The measurement ID in the local Firebase config (" + app.options.measurementId + ")" + (" does not match the measurement ID fetched from the server (" + config.measurementId + ").") + " To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.");
            }
          }).catch(function(e) {
            return logger4.error(e);
          });
          dynamicConfigPromisesList2.push(dynamicConfigPromise);
          fidPromise = validateIndexedDB().then(function(envIsValid) {
            if (envIsValid) {
              return installations.getId();
            } else {
              return void 0;
            }
          });
          return [4, Promise.all([
            dynamicConfigPromise,
            fidPromise
          ])];
        case 1:
          _a9 = _c2.sent(), dynamicConfig = _a9[0], fid = _a9[1];
          if (!findGtagScriptOnPage()) {
            insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
          }
          gtagCore("js", /* @__PURE__ */ new Date());
          configProperties = (_b = {}, // guard against developers accidentally setting properties with prefix `firebase_`
          _b[ORIGIN_KEY] = "firebase", _b.update = true, _b);
          if (fid != null) {
            configProperties[GA_FID_KEY] = fid;
          }
          gtagCore(GtagCommand.CONFIG, dynamicConfig.measurementId, configProperties);
          return [2, dynamicConfig.measurementId];
      }
    });
  });
}
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY5.create(
      "already-initialized"
      /* ALREADY_INITIALIZED */
    );
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  var mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    var details = mismatchedEnvMessages.map(function(message, index) {
      return "(" + (index + 1) + ") " + message;
    }).join(" ");
    var err = ERROR_FACTORY5.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger4.warn(err.message);
  }
}
function factory2(app, installations) {
  warnOnBrowserContextMismatch();
  var appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY5.create(
      "no-app-id"
      /* NO_APP_ID */
    );
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger4.warn('The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest' + (" measurement ID for this Firebase app. Falling back to the measurement ID " + app.options.measurementId) + ' provided in the "measurementId" field in the local Firebase config.');
    } else {
      throw ERROR_FACTORY5.create(
        "no-api-key"
        /* NO_API_KEY */
      );
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY5.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    var _a9 = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName), wrappedGtag = _a9.wrappedGtag, gtagCore = _a9.gtagCore;
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = initializeIds(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName);
  var analyticsInstance = {
    app,
    // Public methods return void for API simplicity and to better match gtag,
    // while internal implementations return promises.
    logEvent: function(eventName, eventParams, options) {
      logEvent(wrappedGtagFunction, initializationPromisesMap[appId], eventName, eventParams, options).catch(function(e) {
        return logger4.error(e);
      });
    },
    setCurrentScreen: function(screenName, options) {
      setCurrentScreen(wrappedGtagFunction, initializationPromisesMap[appId], screenName, options).catch(function(e) {
        return logger4.error(e);
      });
    },
    setUserId: function(id2, options) {
      setUserId(wrappedGtagFunction, initializationPromisesMap[appId], id2, options).catch(function(e) {
        return logger4.error(e);
      });
    },
    setUserProperties: function(properties, options) {
      setUserProperties(wrappedGtagFunction, initializationPromisesMap[appId], properties, options).catch(function(e) {
        return logger4.error(e);
      });
    },
    setAnalyticsCollectionEnabled: function(enabled) {
      setAnalyticsCollectionEnabled(initializationPromisesMap[appId], enabled).catch(function(e) {
        return logger4.error(e);
      });
    },
    INTERNAL: {
      delete: function() {
        delete initializationPromisesMap[appId];
        return Promise.resolve();
      }
    }
  };
  return analyticsInstance;
}
var name7 = "@firebase/analytics";
var version7 = "0.6.6";
var ANALYTICS_TYPE = "analytics";
function registerAnalytics(instance) {
  instance.INTERNAL.registerComponent(new Component(
    ANALYTICS_TYPE,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var installations = container.getProvider("installations").getImmediate();
      return factory2(app, installations);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps({
    settings,
    EventName,
    isSupported: isSupported2
  }));
  instance.INTERNAL.registerComponent(new Component(
    "analytics-internal",
    internalFactory,
    "PRIVATE"
    /* PRIVATE */
  ));
  instance.registerVersion(name7, version7);
  function internalFactory(container) {
    try {
      var analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: analytics.logEvent
      };
    } catch (e) {
      throw ERROR_FACTORY5.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics(index_esm_default);
function isSupported2() {
  return __awaiter(this, void 0, void 0, function() {
    var isDBOpenable, error_1;
    return __generator(this, function(_a9) {
      switch (_a9.label) {
        case 0:
          if (isBrowserExtension()) {
            return [2, false];
          }
          if (!areCookiesEnabled()) {
            return [2, false];
          }
          if (!isIndexedDBAvailable()) {
            return [2, false];
          }
          _a9.label = 1;
        case 1:
          _a9.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          isDBOpenable = _a9.sent();
          return [2, isDBOpenable];
        case 3:
          error_1 = _a9.sent();
          return [2, false];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}

// node_modules/@firebase/remote-config/dist/index.esm.js
var CachingClient = (
  /** @class */
  function() {
    function CachingClient2(client, storage, storageCache, logger5) {
      this.client = client;
      this.storage = storage;
      this.storageCache = storageCache;
      this.logger = logger5;
    }
    CachingClient2.prototype.isCachedDataFresh = function(cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {
      if (!lastSuccessfulFetchTimestampMillis) {
        this.logger.debug("Config fetch cache check. Cache unpopulated.");
        return false;
      }
      var cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;
      var isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;
      this.logger.debug("Config fetch cache check." + (" Cache age millis: " + cacheAgeMillis + ".") + (" Cache max age millis (minimumFetchIntervalMillis setting): " + cacheMaxAgeMillis + ".") + (" Is cache hit: " + isCachedDataFresh + "."));
      return isCachedDataFresh;
    };
    CachingClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var _a9, lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse, response, storageOperations;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this.storage.getLastSuccessfulFetchTimestampMillis(),
                this.storage.getLastSuccessfulFetchResponse()
              ])];
            case 1:
              _a9 = _b.sent(), lastSuccessfulFetchTimestampMillis = _a9[0], lastSuccessfulFetchResponse = _a9[1];
              if (lastSuccessfulFetchResponse && this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {
                return [2, lastSuccessfulFetchResponse];
              }
              request.eTag = lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag;
              return [4, this.client.fetch(request)];
            case 2:
              response = _b.sent();
              storageOperations = [
                // Uses write-through cache for consistency with synchronous public API.
                this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())
              ];
              if (response.status === 200) {
                storageOperations.push(this.storage.setLastSuccessfulFetchResponse(response));
              }
              return [4, Promise.all(storageOperations)];
            case 3:
              _b.sent();
              return [2, response];
          }
        });
      });
    };
    return CachingClient2;
  }()
);
var _a8;
var ERROR_DESCRIPTION_MAP3 = (_a8 = {}, _a8[
  "registration-window"
  /* REGISTRATION_WINDOW */
] = "Undefined window object. This SDK only supports usage in a browser environment.", _a8[
  "registration-project-id"
  /* REGISTRATION_PROJECT_ID */
] = "Undefined project identifier. Check Firebase app initialization.", _a8[
  "registration-api-key"
  /* REGISTRATION_API_KEY */
] = "Undefined API key. Check Firebase app initialization.", _a8[
  "registration-app-id"
  /* REGISTRATION_APP_ID */
] = "Undefined app identifier. Check Firebase app initialization.", _a8[
  "storage-open"
  /* STORAGE_OPEN */
] = "Error thrown when opening storage. Original error: {$originalErrorMessage}.", _a8[
  "storage-get"
  /* STORAGE_GET */
] = "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", _a8[
  "storage-set"
  /* STORAGE_SET */
] = "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", _a8[
  "storage-delete"
  /* STORAGE_DELETE */
] = "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.", _a8[
  "fetch-client-network"
  /* FETCH_NETWORK */
] = "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", _a8[
  "fetch-timeout"
  /* FETCH_TIMEOUT */
] = 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.', _a8[
  "fetch-throttle"
  /* FETCH_THROTTLE */
] = 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.', _a8[
  "fetch-client-parse"
  /* FETCH_PARSE */
] = "Fetch client could not parse response. Original error: {$originalErrorMessage}.", _a8[
  "fetch-status"
  /* FETCH_STATUS */
] = "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", _a8);
var ERROR_FACTORY6 = new ErrorFactory("remoteconfig", "Remote Config", ERROR_DESCRIPTION_MAP3);
function hasErrorCode(e, errorCode) {
  return e instanceof FirebaseError && e.code.indexOf(errorCode) !== -1;
}
function getUserLanguage(navigatorLanguage) {
  if (navigatorLanguage === void 0) {
    navigatorLanguage = navigator;
  }
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    navigatorLanguage.language
  );
}
var RestClient = (
  /** @class */
  function() {
    function RestClient2(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {
      this.firebaseInstallations = firebaseInstallations;
      this.sdkVersion = sdkVersion;
      this.namespace = namespace;
      this.projectId = projectId;
      this.apiKey = apiKey;
      this.appId = appId;
    }
    RestClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var _a9, installationId, installationToken, urlBase, url, headers, requestBody, options, fetchPromise, timeoutPromise, response, originalError_1, errorCode, status, responseEtag, config, state, responseBody, originalError_2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this.firebaseInstallations.getId(),
                this.firebaseInstallations.getToken()
              ])];
            case 1:
              _a9 = _b.sent(), installationId = _a9[0], installationToken = _a9[1];
              urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com";
              url = urlBase + "/v1/projects/" + this.projectId + "/namespaces/" + this.namespace + ":fetch?key=" + this.apiKey;
              headers = {
                "Content-Type": "application/json",
                "Content-Encoding": "gzip",
                // Deviates from pure decorator by not passing max-age header since we don't currently have
                // service behavior using that header.
                "If-None-Match": request.eTag || "*"
              };
              requestBody = {
                /* eslint-disable camelcase */
                sdk_version: this.sdkVersion,
                app_instance_id: installationId,
                app_instance_id_token: installationToken,
                app_id: this.appId,
                language_code: getUserLanguage()
                /* eslint-enable camelcase */
              };
              options = {
                method: "POST",
                headers,
                body: JSON.stringify(requestBody)
              };
              fetchPromise = fetch(url, options);
              timeoutPromise = new Promise(function(_resolve, reject) {
                request.signal.addEventListener(function() {
                  var error2 = new Error("The operation was aborted.");
                  error2.name = "AbortError";
                  reject(error2);
                });
              });
              _b.label = 2;
            case 2:
              _b.trys.push([2, 5, , 6]);
              return [4, Promise.race([fetchPromise, timeoutPromise])];
            case 3:
              _b.sent();
              return [4, fetchPromise];
            case 4:
              response = _b.sent();
              return [3, 6];
            case 5:
              originalError_1 = _b.sent();
              errorCode = "fetch-client-network";
              if (originalError_1.name === "AbortError") {
                errorCode = "fetch-timeout";
              }
              throw ERROR_FACTORY6.create(errorCode, {
                originalErrorMessage: originalError_1.message
              });
            case 6:
              status = response.status;
              responseEtag = response.headers.get("ETag") || void 0;
              if (!(response.status === 200))
                return [3, 11];
              responseBody = void 0;
              _b.label = 7;
            case 7:
              _b.trys.push([7, 9, , 10]);
              return [4, response.json()];
            case 8:
              responseBody = _b.sent();
              return [3, 10];
            case 9:
              originalError_2 = _b.sent();
              throw ERROR_FACTORY6.create("fetch-client-parse", {
                originalErrorMessage: originalError_2.message
              });
            case 10:
              config = responseBody["entries"];
              state = responseBody["state"];
              _b.label = 11;
            case 11:
              if (state === "INSTANCE_STATE_UNSPECIFIED") {
                status = 500;
              } else if (state === "NO_CHANGE") {
                status = 304;
              } else if (state === "NO_TEMPLATE" || state === "EMPTY_CONFIG") {
                config = {};
              }
              if (status !== 304 && status !== 200) {
                throw ERROR_FACTORY6.create("fetch-status", {
                  httpStatus: status
                });
              }
              return [2, { status, eTag: responseEtag, config }];
          }
        });
      });
    };
    return RestClient2;
  }()
);
var RemoteConfigAbortSignal = (
  /** @class */
  function() {
    function RemoteConfigAbortSignal2() {
      this.listeners = [];
    }
    RemoteConfigAbortSignal2.prototype.addEventListener = function(listener) {
      this.listeners.push(listener);
    };
    RemoteConfigAbortSignal2.prototype.abort = function() {
      this.listeners.forEach(function(listener) {
        return listener();
      });
    };
    return RemoteConfigAbortSignal2;
  }()
);
var DEFAULT_VALUE_FOR_BOOLEAN = false;
var DEFAULT_VALUE_FOR_STRING = "";
var DEFAULT_VALUE_FOR_NUMBER = 0;
var BOOLEAN_TRUTHY_VALUES = ["1", "true", "t", "yes", "y", "on"];
var Value = (
  /** @class */
  function() {
    function Value2(_source, _value) {
      if (_value === void 0) {
        _value = DEFAULT_VALUE_FOR_STRING;
      }
      this._source = _source;
      this._value = _value;
    }
    Value2.prototype.asString = function() {
      return this._value;
    };
    Value2.prototype.asBoolean = function() {
      if (this._source === "static") {
        return DEFAULT_VALUE_FOR_BOOLEAN;
      }
      return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;
    };
    Value2.prototype.asNumber = function() {
      if (this._source === "static") {
        return DEFAULT_VALUE_FOR_NUMBER;
      }
      var num = Number(this._value);
      if (isNaN(num)) {
        num = DEFAULT_VALUE_FOR_NUMBER;
      }
      return num;
    };
    Value2.prototype.getSource = function() {
      return this._source;
    };
    return Value2;
  }()
);
var DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1e3;
var RemoteConfig = (
  /** @class */
  function() {
    function RemoteConfig2(app, _client, _storageCache, _storage, _logger) {
      this.app = app;
      this._client = _client;
      this._storageCache = _storageCache;
      this._storage = _storage;
      this._logger = _logger;
      this._isInitializationComplete = false;
      this.settings = {
        fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,
        minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS
      };
      this.defaultConfig = {};
    }
    RemoteConfig2.prototype.setLogLevel = function(logLevel) {
      switch (logLevel) {
        case "debug":
          this._logger.logLevel = LogLevel.DEBUG;
          break;
        case "silent":
          this._logger.logLevel = LogLevel.SILENT;
          break;
        default:
          this._logger.logLevel = LogLevel.ERROR;
      }
    };
    Object.defineProperty(RemoteConfig2.prototype, "fetchTimeMillis", {
      get: function() {
        return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RemoteConfig2.prototype, "lastFetchStatus", {
      get: function() {
        return this._storageCache.getLastFetchStatus() || "no-fetch-yet";
      },
      enumerable: false,
      configurable: true
    });
    RemoteConfig2.prototype.activate = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a9, lastSuccessfulFetchResponse, activeConfigEtag;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this._storage.getLastSuccessfulFetchResponse(),
                this._storage.getActiveConfigEtag()
              ])];
            case 1:
              _a9 = _b.sent(), lastSuccessfulFetchResponse = _a9[0], activeConfigEtag = _a9[1];
              if (!lastSuccessfulFetchResponse || !lastSuccessfulFetchResponse.config || !lastSuccessfulFetchResponse.eTag || lastSuccessfulFetchResponse.eTag === activeConfigEtag) {
                return [2, false];
              }
              return [4, Promise.all([
                this._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config),
                this._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)
              ])];
            case 2:
              _b.sent();
              return [2, true];
          }
        });
      });
    };
    RemoteConfig2.prototype.ensureInitialized = function() {
      var _this = this;
      if (!this._initializePromise) {
        this._initializePromise = this._storageCache.loadFromStorage().then(function() {
          _this._isInitializationComplete = true;
        });
      }
      return this._initializePromise;
    };
    RemoteConfig2.prototype.fetch = function() {
      return __awaiter(this, void 0, void 0, function() {
        var abortSignal, e_1, lastFetchStatus;
        var _this = this;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              abortSignal = new RemoteConfigAbortSignal();
              setTimeout(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a10) {
                    abortSignal.abort();
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              }, this.settings.fetchTimeoutMillis);
              _a9.label = 1;
            case 1:
              _a9.trys.push([1, 4, , 6]);
              return [4, this._client.fetch({
                cacheMaxAgeMillis: this.settings.minimumFetchIntervalMillis,
                signal: abortSignal
              })];
            case 2:
              _a9.sent();
              return [4, this._storageCache.setLastFetchStatus("success")];
            case 3:
              _a9.sent();
              return [3, 6];
            case 4:
              e_1 = _a9.sent();
              lastFetchStatus = hasErrorCode(
                e_1,
                "fetch-throttle"
                /* FETCH_THROTTLE */
              ) ? "throttle" : "failure";
              return [4, this._storageCache.setLastFetchStatus(lastFetchStatus)];
            case 5:
              _a9.sent();
              throw e_1;
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    RemoteConfig2.prototype.fetchAndActivate = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.fetch()];
            case 1:
              _a9.sent();
              return [2, this.activate()];
          }
        });
      });
    };
    RemoteConfig2.prototype.getAll = function() {
      var _this = this;
      return getAllKeys(this._storageCache.getActiveConfig(), this.defaultConfig).reduce(function(allConfigs, key) {
        allConfigs[key] = _this.getValue(key);
        return allConfigs;
      }, {});
    };
    RemoteConfig2.prototype.getBoolean = function(key) {
      return this.getValue(key).asBoolean();
    };
    RemoteConfig2.prototype.getNumber = function(key) {
      return this.getValue(key).asNumber();
    };
    RemoteConfig2.prototype.getString = function(key) {
      return this.getValue(key).asString();
    };
    RemoteConfig2.prototype.getValue = function(key) {
      if (!this._isInitializationComplete) {
        this._logger.debug('A value was requested for key "' + key + '" before SDK initialization completed. Await on ensureInitialized if the intent was to get a previously activated value.');
      }
      var activeConfig = this._storageCache.getActiveConfig();
      if (activeConfig && activeConfig[key] !== void 0) {
        return new Value("remote", activeConfig[key]);
      } else if (this.defaultConfig && this.defaultConfig[key] !== void 0) {
        return new Value("default", String(this.defaultConfig[key]));
      }
      this._logger.debug('Returning static value for key "' + key + '". Define a default or remote value if this is unintentional.');
      return new Value("static");
    };
    return RemoteConfig2;
  }()
);
function getAllKeys(obj1, obj2) {
  if (obj1 === void 0) {
    obj1 = {};
  }
  if (obj2 === void 0) {
    obj2 = {};
  }
  return Object.keys(__assign(__assign({}, obj1), obj2));
}
function toFirebaseError(event, errorCode) {
  var originalError = event.target.error || void 0;
  return ERROR_FACTORY6.create(errorCode, {
    originalErrorMessage: originalError && originalError.message
  });
}
var APP_NAMESPACE_STORE = "app_namespace_store";
var DB_NAME = "firebase_remote_config";
var DB_VERSION = 1;
function openDatabase() {
  return new Promise(function(resolve, reject) {
    var request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = function(event) {
      reject(toFirebaseError(
        event,
        "storage-open"
        /* STORAGE_OPEN */
      ));
    };
    request.onsuccess = function(event) {
      resolve(event.target.result);
    };
    request.onupgradeneeded = function(event) {
      var db2 = event.target.result;
      switch (event.oldVersion) {
        case 0:
          db2.createObjectStore(APP_NAMESPACE_STORE, {
            keyPath: "compositeKey"
          });
      }
    };
  });
}
var Storage = (
  /** @class */
  function() {
    function Storage2(appId, appName, namespace, openDbPromise) {
      if (openDbPromise === void 0) {
        openDbPromise = openDatabase();
      }
      this.appId = appId;
      this.appName = appName;
      this.namespace = namespace;
      this.openDbPromise = openDbPromise;
    }
    Storage2.prototype.getLastFetchStatus = function() {
      return this.get("last_fetch_status");
    };
    Storage2.prototype.setLastFetchStatus = function(status) {
      return this.set("last_fetch_status", status);
    };
    Storage2.prototype.getLastSuccessfulFetchTimestampMillis = function() {
      return this.get("last_successful_fetch_timestamp_millis");
    };
    Storage2.prototype.setLastSuccessfulFetchTimestampMillis = function(timestamp) {
      return this.set("last_successful_fetch_timestamp_millis", timestamp);
    };
    Storage2.prototype.getLastSuccessfulFetchResponse = function() {
      return this.get("last_successful_fetch_response");
    };
    Storage2.prototype.setLastSuccessfulFetchResponse = function(response) {
      return this.set("last_successful_fetch_response", response);
    };
    Storage2.prototype.getActiveConfig = function() {
      return this.get("active_config");
    };
    Storage2.prototype.setActiveConfig = function(config) {
      return this.set("active_config", config);
    };
    Storage2.prototype.getActiveConfigEtag = function() {
      return this.get("active_config_etag");
    };
    Storage2.prototype.setActiveConfigEtag = function(etag) {
      return this.set("active_config_etag", etag);
    };
    Storage2.prototype.getThrottleMetadata = function() {
      return this.get("throttle_metadata");
    };
    Storage2.prototype.setThrottleMetadata = function(metadata) {
      return this.set("throttle_metadata", metadata);
    };
    Storage2.prototype.deleteThrottleMetadata = function() {
      return this.delete("throttle_metadata");
    };
    Storage2.prototype.get = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var db2;
        var _this = this;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db2 = _a9.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db2.transaction([APP_NAMESPACE_STORE], "readonly");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.get(compositeKey);
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-get"
                      /* STORAGE_GET */
                    ));
                  };
                  request.onsuccess = function(event) {
                    var result = event.target.result;
                    if (result) {
                      resolve(result.value);
                    } else {
                      resolve(void 0);
                    }
                  };
                } catch (e) {
                  reject(ERROR_FACTORY6.create("storage-get", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.set = function(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        var db2;
        var _this = this;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db2 = _a9.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db2.transaction([APP_NAMESPACE_STORE], "readwrite");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.put({
                    compositeKey,
                    value
                  });
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-set"
                      /* STORAGE_SET */
                    ));
                  };
                  request.onsuccess = function() {
                    resolve();
                  };
                } catch (e) {
                  reject(ERROR_FACTORY6.create("storage-set", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.delete = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var db2;
        var _this = this;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db2 = _a9.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db2.transaction([APP_NAMESPACE_STORE], "readwrite");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.delete(compositeKey);
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-delete"
                      /* STORAGE_DELETE */
                    ));
                  };
                  request.onsuccess = function() {
                    resolve();
                  };
                } catch (e) {
                  reject(ERROR_FACTORY6.create("storage-delete", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.createCompositeKey = function(key) {
      return [this.appId, this.appName, this.namespace, key].join();
    };
    return Storage2;
  }()
);
var StorageCache = (
  /** @class */
  function() {
    function StorageCache2(storage) {
      this.storage = storage;
    }
    StorageCache2.prototype.getLastFetchStatus = function() {
      return this.lastFetchStatus;
    };
    StorageCache2.prototype.getLastSuccessfulFetchTimestampMillis = function() {
      return this.lastSuccessfulFetchTimestampMillis;
    };
    StorageCache2.prototype.getActiveConfig = function() {
      return this.activeConfig;
    };
    StorageCache2.prototype.loadFromStorage = function() {
      return __awaiter(this, void 0, void 0, function() {
        var lastFetchStatusPromise, lastSuccessfulFetchTimestampMillisPromise, activeConfigPromise, lastFetchStatus, lastSuccessfulFetchTimestampMillis, activeConfig;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              lastFetchStatusPromise = this.storage.getLastFetchStatus();
              lastSuccessfulFetchTimestampMillisPromise = this.storage.getLastSuccessfulFetchTimestampMillis();
              activeConfigPromise = this.storage.getActiveConfig();
              return [4, lastFetchStatusPromise];
            case 1:
              lastFetchStatus = _a9.sent();
              if (lastFetchStatus) {
                this.lastFetchStatus = lastFetchStatus;
              }
              return [4, lastSuccessfulFetchTimestampMillisPromise];
            case 2:
              lastSuccessfulFetchTimestampMillis = _a9.sent();
              if (lastSuccessfulFetchTimestampMillis) {
                this.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;
              }
              return [4, activeConfigPromise];
            case 3:
              activeConfig = _a9.sent();
              if (activeConfig) {
                this.activeConfig = activeConfig;
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    StorageCache2.prototype.setLastFetchStatus = function(status) {
      this.lastFetchStatus = status;
      return this.storage.setLastFetchStatus(status);
    };
    StorageCache2.prototype.setLastSuccessfulFetchTimestampMillis = function(timestampMillis) {
      this.lastSuccessfulFetchTimestampMillis = timestampMillis;
      return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);
    };
    StorageCache2.prototype.setActiveConfig = function(activeConfig) {
      this.activeConfig = activeConfig;
      return this.storage.setActiveConfig(activeConfig);
    };
    return StorageCache2;
  }()
);
function setAbortableTimeout2(signal, throttleEndTimeMillis) {
  return new Promise(function(resolve, reject) {
    var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    var timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(function() {
      clearTimeout(timeout);
      reject(ERROR_FACTORY6.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError2(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  var httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var RetryingClient = (
  /** @class */
  function() {
    function RetryingClient2(client, storage) {
      this.client = client;
      this.storage = storage;
    }
    RetryingClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var throttleMetadata;
        return __generator(this, function(_a9) {
          switch (_a9.label) {
            case 0:
              return [4, this.storage.getThrottleMetadata()];
            case 1:
              throttleMetadata = _a9.sent() || {
                backoffCount: 0,
                throttleEndTimeMillis: Date.now()
              };
              return [2, this.attemptFetch(request, throttleMetadata)];
          }
        });
      });
    };
    RetryingClient2.prototype.attemptFetch = function(request, _a9) {
      var throttleEndTimeMillis = _a9.throttleEndTimeMillis, backoffCount = _a9.backoffCount;
      return __awaiter(this, void 0, void 0, function() {
        var response, e_1, throttleMetadata;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, setAbortableTimeout2(request.signal, throttleEndTimeMillis)];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              _b.trys.push([2, 5, , 7]);
              return [4, this.client.fetch(request)];
            case 3:
              response = _b.sent();
              return [4, this.storage.deleteThrottleMetadata()];
            case 4:
              _b.sent();
              return [2, response];
            case 5:
              e_1 = _b.sent();
              if (!isRetriableError2(e_1)) {
                throw e_1;
              }
              throttleMetadata = {
                throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),
                backoffCount: backoffCount + 1
              };
              return [4, this.storage.setThrottleMetadata(throttleMetadata)];
            case 6:
              _b.sent();
              return [2, this.attemptFetch(request, throttleMetadata)];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return RetryingClient2;
  }()
);
var name8 = "@firebase/remote-config";
var version8 = "0.1.33";
function registerRemoteConfig(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component(
    "remoteConfig",
    remoteConfigFactory,
    "PUBLIC"
    /* PUBLIC */
  ).setMultipleInstances(true));
  firebaseInstance.registerVersion(name8, version8);
  function remoteConfigFactory(container, _a9) {
    var namespace = _a9.instanceIdentifier;
    var app = container.getProvider("app").getImmediate();
    var installations = container.getProvider("installations").getImmediate();
    if (typeof window === "undefined") {
      throw ERROR_FACTORY6.create(
        "registration-window"
        /* REGISTRATION_WINDOW */
      );
    }
    var _b = app.options, projectId = _b.projectId, apiKey = _b.apiKey, appId = _b.appId;
    if (!projectId) {
      throw ERROR_FACTORY6.create(
        "registration-project-id"
        /* REGISTRATION_PROJECT_ID */
      );
    }
    if (!apiKey) {
      throw ERROR_FACTORY6.create(
        "registration-api-key"
        /* REGISTRATION_API_KEY */
      );
    }
    if (!appId) {
      throw ERROR_FACTORY6.create(
        "registration-app-id"
        /* REGISTRATION_APP_ID */
      );
    }
    namespace = namespace || "firebase";
    var storage = new Storage(appId, app.name, namespace);
    var storageCache = new StorageCache(storage);
    var logger5 = new Logger(name8);
    logger5.logLevel = LogLevel.ERROR;
    var restClient = new RestClient(
      installations,
      // Uses the JS SDK version, by which the RC package version can be deduced, if necessary.
      firebaseInstance.SDK_VERSION,
      namespace,
      projectId,
      apiKey,
      appId
    );
    var retryingClient = new RetryingClient(restClient, storage);
    var cachingClient = new CachingClient(retryingClient, storage, storageCache, logger5);
    var remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage, logger5);
    remoteConfigInstance.ensureInitialized();
    return remoteConfigInstance;
  }
}
registerRemoteConfig(index_esm_default);

// node_modules/firebase/dist/index.esm.js
var name9 = "firebase";
var version9 = "8.3.1";
index_esm_default.registerVersion(name9, version9, "app");
var name$12 = "firebase";
var version$12 = "8.3.1";
console.warn("\nIt looks like you're using the development build of the Firebase JS SDK.\nWhen deploying Firebase apps to production, it is advisable to only import\nthe individual SDK components you intend to use.\n\nFor the module builds, these are available in the following manner\n(replace <PACKAGE> with the name of a component - i.e. auth, database, etc):\n\nCommonJS Modules:\nconst firebase = require('firebase/app');\nrequire('firebase/<PACKAGE>');\n\nES Modules:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n\nTypescript:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n");
index_esm_default.registerVersion(name$12, version$12);
export {
  index_esm_default as default
};
/*! Bundled license information:

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/util/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/component/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/logger/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/database/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/webchannel-wrapper/dist/index.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@firebase/firestore/dist/esm5/prebuilt-7525c6cb-cb60b4b9.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/firestore/dist/esm5/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/firestore/dist/esm5/bundle.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/functions/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/messaging/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/storage/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/performance/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/analytics/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/remote-config/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase/dist/index.esm.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase.js.map
